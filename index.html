<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-聚合搜索" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/15/%E8%81%9A%E5%90%88%E6%90%9C%E7%B4%A2/" class="article-date">
  <time class="dt-published" datetime="2024-07-15T03:20:52.705Z" itemprop="datePublished">2024-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="聚合搜索接口优化"><a href="#聚合搜索接口优化" class="headerlink" title="聚合搜索接口优化"></a>聚合搜索接口优化</h3><p>如何让前端能一次搜出所有的数据，又能分别搜出某一类的数据？</p>
<p>在现有接口的基础上再添加参数，前端传不同的type的数据来获取不同的参数。</p>
<p>前端的type是什么值就传什么数据</p>
<p>企业开发：如果在企业当中一个接口的很多功能都差不多，可以考虑添加一个参数来区分前端需要的数据，而不用再重新建一个新的接口。</p>
<p> 1.给SearchRequest加一个参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 查询请求</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@EqualsAndHashCode(callSuper = true)</span><br><span class="line">@Data</span><br><span class="line">public class SearchRequest extends PageRequest implements Serializable &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 搜索词</span><br><span class="line">     */</span><br><span class="line">    private String searchText;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于区分前端需要的数据类型</span><br><span class="line">     */</span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.创建前端参数类型枚举</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搜索类型枚举</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public enum SearchTypeEnum &#123;</span><br><span class="line"></span><br><span class="line">    POST(&quot;帖子&quot;, &quot;post&quot;),</span><br><span class="line">    USER(&quot;用户&quot;, &quot;user&quot;),</span><br><span class="line">    PICTURE(&quot;图片&quot;, &quot;picture&quot;);</span><br><span class="line"></span><br><span class="line">    private final String text;</span><br><span class="line"></span><br><span class="line">    private final String value;</span><br><span class="line"></span><br><span class="line">    SearchTypeEnum(String text, String value) &#123;</span><br><span class="line">        this.text = text;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取值列表</span><br><span class="line">     * 便于根据字符串去获取对应的枚举类</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;String&gt; getValues() &#123;</span><br><span class="line">        return Arrays.stream(values()).map(item -&gt; item.value).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据 value 获取枚举</span><br><span class="line">     *</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static SearchTypeEnum getEnumByValue(String value) &#123;</span><br><span class="line">        if (ObjectUtils.isEmpty(value)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        for (SearchTypeEnum anEnum : SearchTypeEnum.values()) &#123;</span><br><span class="line">            if (anEnum.value.equals(value)) &#123;</span><br><span class="line">                return anEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getText() &#123;</span><br><span class="line">        return text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3.新增SearchController的业务</p>
<p>​	1.判断search是否合法</p>
<p>​		如果type为空，那么搜索所有的数据</p>
<p>​		如果type不为空</p>
<p>​			a.如果type合法，那么查出对应的数据</p>
<p>​			b.否则报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 图片接口</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/search&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class SearchController &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private PostService postService;</span><br><span class="line"></span><br><span class="line">    //注入</span><br><span class="line">    @Resource</span><br><span class="line">    private PictureService pictureService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/all&quot;)</span><br><span class="line">    public BaseResponse&lt;SearchVO&gt; searchALL(@RequestBody SearchRequest searchRequest, HttpServletRequest request)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String type = searchRequest.getType();</span><br><span class="line">        //判断取出的type值中是否有对应的参数类型</span><br><span class="line">        SearchTypeEnum searchTypeEnum = SearchTypeEnum.getEnumByValue(type);</span><br><span class="line">        ThrowUtils.throwIf(StringUtils.isBlank(type),ErrorCode.PARAMS_ERROR);</span><br><span class="line">        String searchText = searchRequest.getSearchText();</span><br><span class="line">        //如果为空则输出所有数据</span><br><span class="line">        if (searchTypeEnum == null)&#123;</span><br><span class="line">//异步将所有前端的请求进行封装</span><br><span class="line">            CompletableFuture&lt;Page&lt;UserVO&gt;&gt; userTask = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">                UserQueryRequest userQueryRequest = new UserQueryRequest();</span><br><span class="line">                userQueryRequest.setUserName(searchText);</span><br><span class="line">                Page&lt;UserVO&gt; userVOPage = userService.listUserVoByPage(userQueryRequest);</span><br><span class="line">                return userVOPage;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            CompletableFuture&lt;Page&lt;PostVO&gt;&gt; postTask = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">                PostQueryRequest postQueryRequest = new PostQueryRequest();</span><br><span class="line">                postQueryRequest.setSearchText(searchText);</span><br><span class="line">                Page&lt;PostVO&gt; postVOPage = postService.listPostVOByPage(postQueryRequest,request);</span><br><span class="line">                return postVOPage;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            CompletableFuture&lt;Page&lt;Picture&gt;&gt; pictureTask = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">                UserQueryRequest userQueryRequest = new UserQueryRequest();</span><br><span class="line">                userQueryRequest.setUserName(searchText);</span><br><span class="line">                Page&lt;Picture&gt; picturePage = pictureService.searchPicture(searchText,1,10);</span><br><span class="line">                return picturePage;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            try&#123;</span><br><span class="line">                //将所有的任务装在一起后才能继续往下执行</span><br><span class="line">                CompletableFuture.allOf(userTask,postTask,pictureTask).join();</span><br><span class="line"></span><br><span class="line">                Page&lt;UserVO&gt; userVOPage = userTask.get();</span><br><span class="line">                Page&lt;PostVO&gt; postVOPage = postTask.get();</span><br><span class="line">                Page&lt;Picture&gt; picturePage = pictureTask.get();</span><br><span class="line">                SearchVO searchVO = new SearchVO();</span><br><span class="line">                searchVO.setUserList(userVOPage.getRecords());</span><br><span class="line">                searchVO.setPostList(postVOPage.getRecords());</span><br><span class="line">                searchVO.setPictureList(picturePage.getRecords());</span><br><span class="line">                return ResultUtils.success(searchVO);</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                log.error(&quot;查询异常&quot;,e);</span><br><span class="line">                throw new BusinessException(ErrorCode.SYSTEM_ERROR,&quot;查询异常&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //如果不为空</span><br><span class="line">            SearchVO searchVO = new SearchVO();</span><br><span class="line">            switch (searchTypeEnum) &#123;</span><br><span class="line">                case POST:</span><br><span class="line">                    PostQueryRequest postQueryRequest = new PostQueryRequest();</span><br><span class="line">                    postQueryRequest.setSearchText(searchText);</span><br><span class="line">                    Page&lt;PostVO&gt; postVOPage = postService.listPostVOByPage(postQueryRequest, request);</span><br><span class="line">                    searchVO.setPostList(postVOPage.getRecords());</span><br><span class="line">                    break;</span><br><span class="line">                case USER:</span><br><span class="line">                    UserQueryRequest userQueryRequest = new UserQueryRequest();</span><br><span class="line">                    userQueryRequest.setUserName(searchText);</span><br><span class="line">                    Page&lt;UserVO&gt; userVOPage = userService.listUserVoByPage(userQueryRequest);</span><br><span class="line">                    searchVO.setUserList(userVOPage.getRecords());</span><br><span class="line">                    break;</span><br><span class="line">                case PICTURE:</span><br><span class="line">                    Page&lt;Picture&gt; picturePage = pictureService.searchPicture(searchText, 1, 10);</span><br><span class="line">                    searchVO.setPictureList(picturePage.getRecords());</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return ResultUtils.success(searchVO);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p>思考：上述代码还有什么问题？</p>
<p>Statistic插件</p>
<p>问题：type增多后，要把查询逻辑堆积controller里</p>
<p>解决：</p>
<p>1.可以使用策略模式（干掉if-else）</p>
<h3 id="本质：如何让系统增加更多的数据源"><a href="#本质：如何让系统增加更多的数据源" class="headerlink" title="本质：如何让系统增加更多的数据源"></a>本质：如何让系统增加更多的数据源</h3><h4 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h4><p>前台（门面）帮助我们用户（客户端（要发送请求））去更轻松地实现功能，不需要关心门面背后的细节</p>
<p>其实已经实现：</p>
<p>前端不知道后端处理用户列表，图片，文章列表的接口在哪里，因为都放在一个接口上去发送请求给前端，前端只需要用一个type字段去得到对应的数据即可，不需要根据type类型去找接口。<strong>即前端不用关心后端从哪里，怎么取不同来源、聚合不同来源的数据，更方便的获取内容。</strong></p>
<p>基本上所有聚合类业务都是门面模式（@slf4j也用到了门面模式）。</p>
<p>上述代码不够优雅，用门面模式抽取类</p>
<p>不在Controller里的代码不用BaseResponse</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">package com.yupi.springbootinit.manager;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line">import com.yupi.springbootinit.common.BaseResponse;</span><br><span class="line">import com.yupi.springbootinit.common.ErrorCode;</span><br><span class="line">import com.yupi.springbootinit.common.ResultUtils;</span><br><span class="line">import com.yupi.springbootinit.exception.BusinessException;</span><br><span class="line">import com.yupi.springbootinit.exception.ThrowUtils;</span><br><span class="line">import com.yupi.springbootinit.model.dto.post.PostQueryRequest;</span><br><span class="line">import com.yupi.springbootinit.model.dto.search.SearchRequest;</span><br><span class="line">import com.yupi.springbootinit.model.dto.user.UserQueryRequest;</span><br><span class="line">import com.yupi.springbootinit.model.entity.Picture;</span><br><span class="line">import com.yupi.springbootinit.model.enums.SearchTypeEnum;</span><br><span class="line">import com.yupi.springbootinit.model.vo.PostVO;</span><br><span class="line">import com.yupi.springbootinit.model.vo.SearchVO;</span><br><span class="line">import com.yupi.springbootinit.model.vo.UserVO;</span><br><span class="line">import com.yupi.springbootinit.service.PictureService;</span><br><span class="line">import com.yupi.springbootinit.service.PostService;</span><br><span class="line">import com.yupi.springbootinit.service.UserService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 搜索门面</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class SearchFacade &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private PostService postService;</span><br><span class="line"></span><br><span class="line">    //注入</span><br><span class="line">    @Resource</span><br><span class="line">    private PictureService pictureService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/all&quot;)</span><br><span class="line">    public SearchVO searchALL(@RequestBody SearchRequest searchRequest, HttpServletRequest request)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String type = searchRequest.getType();</span><br><span class="line">        //判断取出的type值中是否有对应的参数类型</span><br><span class="line">        SearchTypeEnum searchTypeEnum = SearchTypeEnum.getEnumByValue(type);</span><br><span class="line">        ThrowUtils.throwIf(StringUtils.isBlank(type), ErrorCode.PARAMS_ERROR);</span><br><span class="line">        String searchText = searchRequest.getSearchText();</span><br><span class="line">        //如果为空则输出所有数据</span><br><span class="line">        if (searchTypeEnum == null)&#123;</span><br><span class="line">            //同步将所有前端的请求进行封装</span><br><span class="line">//        Page&lt;Picture&gt; picturePage = pictureService.searchPicture(searchText, 1, 10);</span><br><span class="line">//</span><br><span class="line">//        UserQueryRequest userQueryRequest = new UserQueryRequest();</span><br><span class="line">//        userQueryRequest.setUserName(searchText);</span><br><span class="line">//        Page&lt;UserVO&gt; userVOPage = userService.listUserVoByPage(userQueryRequest);</span><br><span class="line">//        PostQueryRequest postQueryRequest = new PostQueryRequest();</span><br><span class="line">//        postQueryRequest.setSearchText(searchText);</span><br><span class="line">//        Page&lt;PostVO&gt; postVOPage = postService.listPostVOByPage(postQueryRequest, request);</span><br><span class="line">//</span><br><span class="line">//        SearchVO searchVO = new SearchVO();</span><br><span class="line">//        searchVO.setUserList(userVOPage.getRecords());</span><br><span class="line">//        searchVO.setPostList(postVOPage.getRecords());</span><br><span class="line">//        searchVO.setPictureList(picturePage.getRecords());</span><br><span class="line"></span><br><span class="line">            //异步将所有前端的请求进行封装</span><br><span class="line">            CompletableFuture&lt;Page&lt;UserVO&gt;&gt; userTask = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">                UserQueryRequest userQueryRequest = new UserQueryRequest();</span><br><span class="line">                userQueryRequest.setUserName(searchText);</span><br><span class="line">                Page&lt;UserVO&gt; userVOPage = userService.listUserVoByPage(userQueryRequest);</span><br><span class="line">                return userVOPage;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            CompletableFuture&lt;Page&lt;PostVO&gt;&gt; postTask = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">                PostQueryRequest postQueryRequest = new PostQueryRequest();</span><br><span class="line">                postQueryRequest.setSearchText(searchText);</span><br><span class="line">                Page&lt;PostVO&gt; postVOPage = postService.listPostVOByPage(postQueryRequest,request);</span><br><span class="line">                return postVOPage;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            CompletableFuture&lt;Page&lt;Picture&gt;&gt; pictureTask = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">                UserQueryRequest userQueryRequest = new UserQueryRequest();</span><br><span class="line">                userQueryRequest.setUserName(searchText);</span><br><span class="line">                Page&lt;Picture&gt; picturePage = pictureService.searchPicture(searchText,1,10);</span><br><span class="line">                return picturePage;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            try&#123;</span><br><span class="line">                //将所有的任务装在一起后才能继续往下执行</span><br><span class="line">                CompletableFuture.allOf(userTask,postTask,pictureTask).join();</span><br><span class="line"></span><br><span class="line">                Page&lt;UserVO&gt; userVOPage = userTask.get();</span><br><span class="line">                Page&lt;PostVO&gt; postVOPage = postTask.get();</span><br><span class="line">                Page&lt;Picture&gt; picturePage = pictureTask.get();</span><br><span class="line">                SearchVO searchVO = new SearchVO();</span><br><span class="line">                searchVO.setUserList(userVOPage.getRecords());</span><br><span class="line">                searchVO.setPostList(postVOPage.getRecords());</span><br><span class="line">                searchVO.setPictureList(picturePage.getRecords());</span><br><span class="line">                return searchVO;</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                log.error(&quot;查询异常&quot;,e);</span><br><span class="line">                throw new BusinessException(ErrorCode.SYSTEM_ERROR,&quot;查询异常&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //如果不为空</span><br><span class="line">            SearchVO searchVO = new SearchVO();</span><br><span class="line">            switch (searchTypeEnum) &#123;</span><br><span class="line">                case POST:</span><br><span class="line">                    PostQueryRequest postQueryRequest = new PostQueryRequest();</span><br><span class="line">                    postQueryRequest.setSearchText(searchText);</span><br><span class="line">                    Page&lt;PostVO&gt; postVOPage = postService.listPostVOByPage(postQueryRequest, request);</span><br><span class="line">                    searchVO.setPostList(postVOPage.getRecords());</span><br><span class="line">                    break;</span><br><span class="line">                case USER:</span><br><span class="line">                    UserQueryRequest userQueryRequest = new UserQueryRequest();</span><br><span class="line">                    userQueryRequest.setUserName(searchText);</span><br><span class="line">                    Page&lt;UserVO&gt; userVOPage = userService.listUserVoByPage(userQueryRequest);</span><br><span class="line">                    searchVO.setUserList(userVOPage.getRecords());</span><br><span class="line">                    break;</span><br><span class="line">                case PICTURE:</span><br><span class="line">                    Page&lt;Picture&gt; picturePage = pictureService.searchPicture(searchText, 1, 10);</span><br><span class="line">                    searchVO.setPictureList(picturePage.getRecords());</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            return searchVO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package com.yupi.springbootinit.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line">import com.yupi.springbootinit.common.BaseResponse;</span><br><span class="line">import com.yupi.springbootinit.common.ErrorCode;</span><br><span class="line">import com.yupi.springbootinit.common.ResultUtils;</span><br><span class="line">import com.yupi.springbootinit.exception.BusinessException;</span><br><span class="line">import com.yupi.springbootinit.exception.ThrowUtils;</span><br><span class="line">import com.yupi.springbootinit.manager.SearchFacade;</span><br><span class="line">import com.yupi.springbootinit.model.dto.post.PostQueryRequest;</span><br><span class="line">import com.yupi.springbootinit.model.dto.search.SearchRequest;</span><br><span class="line">import com.yupi.springbootinit.model.dto.user.UserQueryRequest;</span><br><span class="line">import com.yupi.springbootinit.model.entity.Picture;</span><br><span class="line">import com.yupi.springbootinit.model.enums.SearchTypeEnum;</span><br><span class="line">import com.yupi.springbootinit.model.vo.PostVO;</span><br><span class="line">import com.yupi.springbootinit.model.vo.SearchVO;</span><br><span class="line">import com.yupi.springbootinit.model.vo.UserVO;</span><br><span class="line">import com.yupi.springbootinit.service.PictureService;</span><br><span class="line">import com.yupi.springbootinit.service.PostService;</span><br><span class="line">import com.yupi.springbootinit.service.UserService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图片接口</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/search&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class SearchController &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private PostService postService;</span><br><span class="line"></span><br><span class="line">    //注入</span><br><span class="line">    @Resource</span><br><span class="line">    private PictureService pictureService;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private SearchFacade searchFacade;</span><br><span class="line">    </span><br><span class="line">    @PostMapping(&quot;/all&quot;)</span><br><span class="line">    public BaseResponse&lt;SearchVO&gt; searchALL(@RequestBody SearchRequest searchRequest, HttpServletRequest request)&#123;</span><br><span class="line"></span><br><span class="line">        return  ResultUtils.success(searchFacade.searchALL(searchRequest,request));</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    // endregion</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="F:\迅雷下载\work\notebook\source_posts\聚合搜索\Snipaste_2024-04-29_20-38-39.png" alt="Snipaste_2024-04-29_20-38-39"></p>
<p>应用场景：当调用你系统（接口）的客户端觉得麻烦的时候，就应该思考，是不是可以抽象成一个门面了。</p>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>1.定制统一的数据源接入规范：什么数据源允许接入？你的数据源接入时要满足什么要求？要做什么事情？</p>
<p>用户接入我们的系统时，给的数据可能是不规范的</p>
<p><strong>任何接入系统的数据，它必须能够根据关键词搜索，并且支持分页搜索</strong>。为了防止出现破坏系统的行为</p>
<p>思考要其它用户接入我们系统时的行为</p>
<p>1.添加枚举类型</p>
<p>2.新建service</p>
<p>3.再来到门面模式设置if-else</p>
<p>通过声明接口来定义规范。</p>
<p>步骤</p>
<p>1.在dataSource声明接口</p>
<p>2.把三个的服务实现类（给前端返回的数据列表）复制改造成三个数据源（为了方便其它人调用，最好是从服务实现类抽离出来）</p>
<p>3.假如说我们的数据源已经支持了搜索，但是原有的方法参数和我们的规范不一致，怎么办？</p>
<p>适配器作用：通过转换，让两个系统能够完成对接</p>
<p>举例：玩ps5游戏机你要用ps5手柄，但是你只有NS手柄，那么你就需要用转接器去插入PS5，然后再把手柄线插入转接器。而这个转接器就是适配器。</p>
<p>写代码：在继承接口的方法中，先创建一个可以适配转接器的对象，然后把需要的值放入对象中，然后返回给转接器（继承接口的方法）即可。简单来说就是更改了返回值类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用户服务实现</span><br><span class="line"> *</span><br><span class="line"> * @author &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="line"> * @from &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class UserDataSource implements DataSource&lt;UserVO&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private UserService userService;</span><br><span class="line">    </span><br><span class="line">    //适配器模式：修改返回值类型</span><br><span class="line">    @Override</span><br><span class="line">    public Page&lt;UserVO&gt; doSearch(String searchText, long pageNum, long pageSize) &#123;</span><br><span class="line">        UserQueryRequest userQueryRequest = new UserQueryRequest();</span><br><span class="line">        userQueryRequest.setUserName(searchText);</span><br><span class="line">        userQueryRequest.setCurrent(pageNum);</span><br><span class="line">        userQueryRequest.setPageSize(pageSize);</span><br><span class="line">        Page&lt;UserVO&gt; userVOPage = userService.listUserVoByPage(userQueryRequest);</span><br><span class="line">        return userVOPage; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>4.改造门面模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搜索门面</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class SearchFacade &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private PostDataSource postDataSource;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private UserDataSource userDataSource;</span><br><span class="line"></span><br><span class="line">    //注入</span><br><span class="line">    @Resource</span><br><span class="line">    private PictureDataSource pictureDataSource;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/all&quot;)</span><br><span class="line">    public SearchVO searchALL(@RequestBody SearchRequest searchRequest, HttpServletRequest request)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String type = searchRequest.getType();</span><br><span class="line">        //判断取出的type值中是否有对应的参数类型</span><br><span class="line">        SearchTypeEnum searchTypeEnum = SearchTypeEnum.getEnumByValue(type);</span><br><span class="line">        ThrowUtils.throwIf(StringUtils.isBlank(type), ErrorCode.PARAMS_ERROR);</span><br><span class="line">        String searchText = searchRequest.getSearchText();</span><br><span class="line">        int current = searchRequest.getCurrent();</span><br><span class="line">        int pageSize = searchRequest.getPageSize();</span><br><span class="line"></span><br><span class="line">        //如果为空则输出所有数据</span><br><span class="line">        if (searchTypeEnum == null)&#123;</span><br><span class="line"></span><br><span class="line">            //异步将所有前端的请求进行封装</span><br><span class="line">            CompletableFuture&lt;Page&lt;UserVO&gt;&gt; userTask = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">                UserQueryRequest userQueryRequest = new UserQueryRequest();</span><br><span class="line">                userQueryRequest.setUserName(searchText);</span><br><span class="line">                Page&lt;UserVO&gt; userVOPage = userDataSource.doSearch(searchText,current,pageSize);</span><br><span class="line">                return userVOPage;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            CompletableFuture&lt;Page&lt;PostVO&gt;&gt; postTask = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">                PostQueryRequest postQueryRequest = new PostQueryRequest();</span><br><span class="line">                postQueryRequest.setSearchText(searchText);</span><br><span class="line">                Page&lt;PostVO&gt; postVOPage = postDataSource.doSearch(searchText,current,pageSize);</span><br><span class="line">                return postVOPage;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            CompletableFuture&lt;Page&lt;Picture&gt;&gt; pictureTask = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">                UserQueryRequest userQueryRequest = new UserQueryRequest();</span><br><span class="line">                userQueryRequest.setUserName(searchText);</span><br><span class="line">                Page&lt;Picture&gt; picturePage = pictureDataSource.doSearch(searchText,current,pageSize);</span><br><span class="line">                return picturePage;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            try&#123;</span><br><span class="line">                //将所有的任务装在一起后才能继续往下执行</span><br><span class="line">                CompletableFuture.allOf(userTask,postTask,pictureTask).join();</span><br><span class="line"></span><br><span class="line">                Page&lt;UserVO&gt; userVOPage = userTask.get();</span><br><span class="line">                Page&lt;PostVO&gt; postVOPage = postTask.get();</span><br><span class="line">                Page&lt;Picture&gt; picturePage = pictureTask.get();</span><br><span class="line">                SearchVO searchVO = new SearchVO();</span><br><span class="line">                searchVO.setUserList(userVOPage.getRecords());</span><br><span class="line">                searchVO.setPostList(postVOPage.getRecords());</span><br><span class="line">                searchVO.setPictureList(picturePage.getRecords());</span><br><span class="line">                return searchVO;</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                log.error(&quot;查询异常&quot;,e);</span><br><span class="line">                throw new BusinessException(ErrorCode.SYSTEM_ERROR,&quot;查询异常&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //如果不为空</span><br><span class="line">            SearchVO searchVO = new SearchVO();</span><br><span class="line">            switch (searchTypeEnum) &#123;</span><br><span class="line">                case POST:</span><br><span class="line">                    PostQueryRequest postQueryRequest = new PostQueryRequest();</span><br><span class="line">                    postQueryRequest.setSearchText(searchText);</span><br><span class="line">                    Page&lt;PostVO&gt; postVOPage = postService.listPostVOByPage(postQueryRequest, request);</span><br><span class="line">                    searchVO.setPostList(postVOPage.getRecords());</span><br><span class="line">                    break;</span><br><span class="line">                case USER:</span><br><span class="line">                    UserQueryRequest userQueryRequest = new UserQueryRequest();</span><br><span class="line">                    userQueryRequest.setUserName(searchText);</span><br><span class="line">                    Page&lt;UserVO&gt; userVOPage = userService.listUserVoByPage(userQueryRequest);</span><br><span class="line">                    searchVO.setUserList(userVOPage.getRecords());</span><br><span class="line">                    break;</span><br><span class="line">                case PICTURE:</span><br><span class="line">                    Page&lt;Picture&gt; picturePage = pictureService.searchPicture(searchText, 1, 10);</span><br><span class="line">                    searchVO.setPictureList(picturePage.getRecords());</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            return searchVO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>5.还有一个好处，可以简化switch的判断</p>
<p>修改返回特定数据的逻辑</p>
<p>修改前</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//如果不为空</span><br><span class="line">            SearchVO searchVO = new SearchVO();</span><br><span class="line">            switch (searchTypeEnum) &#123;</span><br><span class="line">                case POST:</span><br><span class="line">                    PostQueryRequest postQueryRequest = new PostQueryRequest();</span><br><span class="line">                    postQueryRequest.setSearchText(searchText);</span><br><span class="line">                    Page&lt;PostVO&gt; postVOPage = postService.listPostVOByPage(postQueryRequest, request);</span><br><span class="line">                    searchVO.setPostList(postVOPage.getRecords());</span><br><span class="line">                    break;</span><br><span class="line">                case USER:</span><br><span class="line">                    UserQueryRequest userQueryRequest = new UserQueryRequest();</span><br><span class="line">                    userQueryRequest.setUserName(searchText);</span><br><span class="line">                    Page&lt;UserVO&gt; userVOPage = userService.listUserVoByPage(userQueryRequest);</span><br><span class="line">                    searchVO.setUserList(userVOPage.getRecords());</span><br><span class="line">                    break;</span><br><span class="line">                case PICTURE:</span><br><span class="line">                    Page&lt;Picture&gt; picturePage = pictureService.searchPicture(searchText, 1, 10);</span><br><span class="line">                    searchVO.setPictureList(picturePage.getRecords());</span><br><span class="line">                    break;</span><br></pre></td></tr></table></figure>

<p>修改后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DataSource dataSource = null;</span><br><span class="line"></span><br><span class="line">switch (searchTypeEnum)&#123;</span><br><span class="line"></span><br><span class="line">    case POST:</span><br><span class="line">        dataSource = postDataSource;</span><br><span class="line">        break;</span><br><span class="line">    case USER:</span><br><span class="line">        dataSource = userDataSource;</span><br><span class="line">        break;</span><br><span class="line">    case PICTURE:</span><br><span class="line">        dataSource = pictureDataSource;</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br><span class="line">dataSource.doSearch(searchText,current,pageSize);</span><br></pre></td></tr></table></figure>

<p>再次修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//本质上是做了一个注册</span><br><span class="line">Map&lt;String, DataSource&lt;T&gt;&gt; typeDataSourceMap = new HashMap()&#123;&#123;</span><br><span class="line">   put(SearchTypeEnum.POST.getValue(), postDataSource);</span><br><span class="line">   put(SearchTypeEnum.USER.getValue(), userDataSource);</span><br><span class="line">   put(SearchTypeEnum.PICTURE.getValue(), pictureDataSource);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">SearchVO searchVO = new SearchVO();</span><br><span class="line">DataSource&lt;?&gt; dataSource = typeDataSourceMap.get(type);</span><br><span class="line">Page page = dataSource.doSearch(searchText, current, pageSize);</span><br><span class="line">searchVO.setDataList(page.getRecords());</span><br><span class="line">return searchVO;</span><br></pre></td></tr></table></figure>

<p>再次修改（把注册这部分提取出来）</p>
<p>构建注册中心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 数据源注册中心</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class DataSourceRegistry &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private PostDataSource postDataSource;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private UserDataSource userDataSource;</span><br><span class="line"></span><br><span class="line">    //注入</span><br><span class="line">    @Resource</span><br><span class="line">    private PictureDataSource pictureDataSource;</span><br><span class="line">    Map&lt;String, DataSource&lt;T&gt;&gt; typeDataSourceMap = new HashMap()&#123;&#123;</span><br><span class="line">        put(SearchTypeEnum.POST.getValue(), postDataSource);</span><br><span class="line">        put(SearchTypeEnum.USER.getValue(), userDataSource);</span><br><span class="line">        put(SearchTypeEnum.PICTURE.getValue(), pictureDataSource);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从map中获取对应的数据源</span><br><span class="line">     * @param type</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public  DataSource getDataSourceByType(String type)&#123;</span><br><span class="line">        return  typeDataSourceMap.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用注册中心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SearchVO searchVO = new SearchVO();</span><br><span class="line">            DataSource&lt;?&gt; dataSource = dataSourceRegistry.getDataSourceByType(type);</span><br><span class="line">            Page page = dataSource.doSearch(searchText, current, pageSize);</span><br><span class="line">            searchVO.setDataList(page.getRecords());</span><br><span class="line">            return searchVO;</span><br></pre></td></tr></table></figure>



<p>6.修改后的搜索门面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 搜索门面</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class SearchFacade &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private PostDataSource postDataSource;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private UserDataSource userDataSource;</span><br><span class="line"></span><br><span class="line">    //注入</span><br><span class="line">    @Resource</span><br><span class="line">    private PictureDataSource pictureDataSource;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private DataSourceRegistry dataSourceRegistry;</span><br><span class="line">    </span><br><span class="line">    @PostMapping(&quot;/all&quot;)</span><br><span class="line">    public SearchVO searchALL(@RequestBody SearchRequest searchRequest, HttpServletRequest request)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String type = searchRequest.getType();</span><br><span class="line">        //判断取出的type值中是否有对应的参数类型</span><br><span class="line">        SearchTypeEnum searchTypeEnum = SearchTypeEnum.getEnumByValue(type);</span><br><span class="line">        ThrowUtils.throwIf(StringUtils.isBlank(type), ErrorCode.PARAMS_ERROR);</span><br><span class="line">        String searchText = searchRequest.getSearchText();</span><br><span class="line">        int current = searchRequest.getCurrent();</span><br><span class="line">        int pageSize = searchRequest.getPageSize();</span><br><span class="line"></span><br><span class="line">        //如果为空则输出所有数据</span><br><span class="line">        if (searchTypeEnum == null)&#123;</span><br><span class="line">            //异步将所有前端的请求进行封装</span><br><span class="line">            CompletableFuture&lt;Page&lt;UserVO&gt;&gt; userTask = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">                UserQueryRequest userQueryRequest = new UserQueryRequest();</span><br><span class="line">                userQueryRequest.setUserName(searchText);</span><br><span class="line">                Page&lt;UserVO&gt; userVOPage = userDataSource.doSearch(searchText,current,pageSize);</span><br><span class="line">                return userVOPage;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            CompletableFuture&lt;Page&lt;PostVO&gt;&gt; postTask = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">                PostQueryRequest postQueryRequest = new PostQueryRequest();</span><br><span class="line">                postQueryRequest.setSearchText(searchText);</span><br><span class="line">                Page&lt;PostVO&gt; postVOPage = postDataSource.doSearch(searchText,current,pageSize);</span><br><span class="line">                return postVOPage;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            CompletableFuture&lt;Page&lt;Picture&gt;&gt; pictureTask = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">                UserQueryRequest userQueryRequest = new UserQueryRequest();</span><br><span class="line">                userQueryRequest.setUserName(searchText);</span><br><span class="line">                Page&lt;Picture&gt; picturePage = pictureDataSource.doSearch(searchText,current,pageSize);</span><br><span class="line">                return picturePage;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            try&#123;</span><br><span class="line">                //将所有的任务装在一起后才能继续往下执行</span><br><span class="line">                CompletableFuture.allOf(userTask,postTask,pictureTask).join();</span><br><span class="line"></span><br><span class="line">                Page&lt;UserVO&gt; userVOPage = userTask.get();</span><br><span class="line">                Page&lt;PostVO&gt; postVOPage = postTask.get();</span><br><span class="line">                Page&lt;Picture&gt; picturePage = pictureTask.get();</span><br><span class="line">                SearchVO searchVO = new SearchVO();</span><br><span class="line">                searchVO.setUserList(userVOPage.getRecords());</span><br><span class="line">                searchVO.setPostList(postVOPage.getRecords());</span><br><span class="line">                searchVO.setPictureList(picturePage.getRecords());</span><br><span class="line">                return searchVO;</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                log.error(&quot;查询异常&quot;,e);</span><br><span class="line">                throw new BusinessException(ErrorCode.SYSTEM_ERROR,&quot;查询异常&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //如果不为空</span><br><span class="line"></span><br><span class="line">            //本质上是做了一个注册</span><br><span class="line"></span><br><span class="line">            SearchVO searchVO = new SearchVO();</span><br><span class="line">            DataSource&lt;?&gt; dataSource = dataSourceRegistry.getDataSourceByType(type);</span><br><span class="line">            Page page = dataSource.doSearch(searchText, current, pageSize);</span><br><span class="line">            searchVO.setDataList(page.getRecords());</span><br><span class="line">            return searchVO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>7.注册器模式（本质也是单例）</p>
<p>提前通过一个map或者其它类型存储好后面需要调用的对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 数据源注册中心</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class DataSourceRegistry &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private PostDataSource postDataSource;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private UserDataSource userDataSource;</span><br><span class="line"></span><br><span class="line">    //注入</span><br><span class="line">    @Resource</span><br><span class="line">    private PictureDataSource pictureDataSource;</span><br><span class="line"></span><br><span class="line">    private  Map&lt;String, DataSource&lt;T&gt;&gt; typeDataSourceMap;</span><br><span class="line"></span><br><span class="line">    //依赖注入后才调用（也可以用静态代码块，只要保证项目初始化时调用即可）</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void doInit()&#123;</span><br><span class="line">        typeDataSourceMap =new HashMap()&#123;&#123;</span><br><span class="line">            put(SearchTypeEnum.POST.getValue(), postDataSource);</span><br><span class="line">            put(SearchTypeEnum.USER.getValue(), userDataSource);</span><br><span class="line">            put(SearchTypeEnum.PICTURE.getValue(), pictureDataSource);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 从map中获取对应的数据源</span><br><span class="line">     * @param type</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public  DataSource getDataSourceByType(String type)&#123;</span><br><span class="line">        //防止系统刚启动时就被别人调用</span><br><span class="line">        if (typeDataSourceMap == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return  typeDataSourceMap.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>效果：代码大幅度减少，可维护可扩展</p>
<h4 id="Elastic-Stack-一套技术栈"><a href="#Elastic-Stack-一套技术栈" class="headerlink" title="Elastic Stack(一套技术栈)"></a>Elastic Stack(一套技术栈)</h4><p>ES完全理解为MySQL</p>
<p>ES分为三个部分</p>
<p> 整合&#x3D;&gt;存储&#x3D;&gt;存储&#x3D;&gt;使用</p>
<p>架构：</p>
<p>beats: 从各种不同类型的文件&#x2F;应用来<strong>采集数据</strong>  <strong>a,b,c,d,e,aa,bb,cc</strong></p>
<p>logstash:从多个采集器或数据源来抽取&#x2F;转换数据，向es输送 aa,bb,cc</p>
<p>elasticsearch: 存储，查询数据</p>
<p>kibana:可视化es的数据</p>
<h4 id="安装ES"><a href="#安装ES" class="headerlink" title="安装ES"></a>安装ES</h4><p>elasticsearch</p>
<p>kibana</p>
<p><strong>只要是一套技术，所有版本必须一致</strong></p>
<h4 id="Elasticsearch概念"><a href="#Elasticsearch概念" class="headerlink" title="Elasticsearch概念"></a>Elasticsearch概念</h4><p>你就把这个当成MySQL一样的数据库</p>
<p>Index索引 &#x3D;&gt; MySQL里的表(table)</p>
<p>建表、增删改查(查询需要花费的学习时间最多)</p>
<p>用客户端去调用ElasticSearch(3种)</p>
<p>语法: SQL、代码的方法（4种语法）</p>
<p><strong>搜索需要分词</strong></p>
<p>ES相比MySQL，能够自动帮我们做分词，能够非常高效、灵活地查询内容。</p>
<h4 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h4><p>在ES中索引相当于是MySQL中的表</p>
<p>正向索引：理解为书籍的目录，可以快速帮你找到对应的内容（根据页码找到文章）</p>
<p>倒排索引：</p>
<p>文章A：你好，我是XXX</p>
<p>文章B：zlz你好，我是zzz</p>
<p>怎么根据内容找到文章，可以构建倒排索引</p>
<p>例子：</p>
<p>你好，我是，XXX</p>
<p>zlz，你好，我是，zzz</p>
<p>倒排索引表</p>
<table>
<thead>
<tr>
<th>词</th>
<th>内容id</th>
</tr>
</thead>
<tbody><tr>
<td>你好</td>
<td>文章A，B</td>
</tr>
<tr>
<td>我是</td>
<td>文章A，B</td>
</tr>
<tr>
<td>XXX</td>
<td>文章A</td>
</tr>
<tr>
<td>zlz</td>
<td>文章B</td>
</tr>
<tr>
<td>zzz</td>
<td>文章B</td>
</tr>
</tbody></table>
<p>用户搜：”zlz zzz”</p>
<p>ES先切词：zlz，zzz</p>
<p>再去倒排索引表中对应的文章</p>
<h4 id="ES的调用方式"><a href="#ES的调用方式" class="headerlink" title="ES的调用方式"></a>ES的调用方式</h4><p>1.restful api 调用（http请求）</p>
<p>localhost:9200</p>
<p>curl方式也行</p>
<p>ES启动端口</p>
<p>1.9200：给外部用户（客户端调用）的</p>
<p>2.9300：给ES集群内部通信的（外部调用不了）</p>
<p>2.kibana：可视化es</p>
<p>kibana devtools</p>
<p>自由地对ES进行操作（本质也是 restful api）</p>
<p>devtools不建议生产环境使用</p>
<p>3.客户端调用</p>
<p>java客户端</p>
<h4 id="ES的语法"><a href="#ES的语法" class="headerlink" title="ES的语法"></a>ES的语法</h4><p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/getting-started.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/getting-started.html</a></p>
<p>DSL</p>
<p>和http请求最兼容的，应用最广，json格式好理解</p>
<p>建表、插入语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST logs-my_app-default/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;@timestamp&quot;: &quot;2099-05-06T16:21:15.000Z&quot;,</span><br><span class="line">  &quot;event&quot;: &#123;</span><br><span class="line">    &quot;original&quot;: &quot;192.0.2.42 - - [06/May/2099:16:21:15 +0000] \&quot;GET /images/bg.jpg HTTP/1.0\&quot; 200 24736&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>查询</p>
<p>DSL语法：domain special language 领域特定语言 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET logs-my_app-default/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;@timestamp&quot;: &quot;desc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>删除语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE _data_stream/logs-my_app-default</span><br></pre></td></tr></table></figure>



<p>根据id查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET post/_doc/f2pmLY8BAEbEyUOaiGDN</span><br></pre></td></tr></table></figure>



<p>修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST post/_doc/f2pmLY8BAEbEyUOaiGDN</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;zlz2&quot;,</span><br><span class="line">  &quot;desc&quot;: &quot;zlz的描述2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h4 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h4><p>理解为数据库的表结构，有哪些字段，有哪些类型</p>
<p>它比MySQL的字段还要灵活</p>
<p>类型：</p>
<p>动态Mapping：自动创建，动态发生变化</p>
<p>显式Mapping：自己建表，自己指定</p>
<p>动态Mapping</p>
<p>输入				类型</p>
<p>true&#x2F;false  &#x3D;&gt; boolean</p>
<p>double      &#x3D;&gt;  float</p>
<p>array       &#x3D;&gt;   数组中第一个非空元素的类型</p>
<p>查询某个表的表结构的语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET post/_mapping</span><br></pre></td></tr></table></figure>



<p>ES支持动态mapping,表结构可以动态改变，而不像MySQL一样必须手动创建表,没有的字段就不能插入。</p>
<p>注意：如果字段类型是keyword，那么ES就不会对keyword进行切词</p>
<p>显式Mapping</p>
<p>建表语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT /my-index-000001</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;age&quot;:    &#123; &quot;type&quot;: &quot;integer&quot; &#125;,  </span><br><span class="line">      &quot;email&quot;:  &#123; &quot;type&quot;: &quot;keyword&quot;  &#125;, </span><br><span class="line">      &quot;name&quot;:   &#123; &quot;type&quot;: &quot;text&quot;  &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="ECS：与上述的建文档差别大"><a href="#ECS：与上述的建文档差别大" class="headerlink" title="ECS：与上述的建文档差别大"></a>ECS：与上述的建文档差别大</h4><p>专门存储事件数据（指标，每秒钟CPU，内存占用多少）和整合类数据</p>
<p>在建表的时候有@timestamp和event（这种就不能使用上述的查表语句）</p>
<p>建表语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST my_event/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;zlz&quot;,</span><br><span class="line">  &quot;@timestamp&quot;: &quot;2099-05-06T16:21:15.000Z&quot;,</span><br><span class="line">  &quot;event&quot;: &#123;</span><br><span class="line">    &quot;original&quot;: &quot;192.0.2.42 - - [06/May/2099:16:21:15 +0000] \&quot;GET /images/bg.jpg HTTP/1.0\&quot; 200 24736&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>EQL：专门查询ECS文档（标准指标文档）的数据语法，更加规范，只适用于特定场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET my_event/_eql/search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &quot;&quot;&quot;</span><br><span class="line">    any where 1==1</span><br><span class="line">  &quot;&quot;&quot;,</span><br><span class="line">  &quot;size&quot;: 50</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>SQL：学习成本低，但是需要插件支持，但是性能差</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /_sql?format=txt</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &quot;SELECT * FROM post where title like &#x27;%zlz%&#x27;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> Painless Scripting language</p>
<p>编程的方式取值，学习成本高</p>
<h3 id="用ES实现搜索接口"><a href="#用ES实现搜索接口" class="headerlink" title="用ES实现搜索接口"></a>用ES实现搜索接口</h3><p>1.建表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create table if not exists post(</span><br><span class="line">   id           bigint auto_increment comment &#x27;id&#x27; primary key,</span><br><span class="line">   title        varchar(512)                           null comment &#x27;标题&#x27;,</span><br><span class="line">   content      text                          null comment &#x27;公告内容&#x27;,</span><br><span class="line">   tags         varchar(1024)                          null comment &#x27;标签列表（Json数组）&#x27;,</span><br><span class="line">   thumbNum     int          default 0                 not null comment &#x27;点赞数&#x27;,</span><br><span class="line">   favourNum    int          default 0                 not null comment &#x27;收藏数&#x27;,</span><br><span class="line">   userId       bigint                                 not null comment &#x27;创建用户id&#x27;,</span><br><span class="line">   createTime   datetime     default CURRENT_TIMESTAMP not null comment &#x27;创建时间&#x27;,</span><br><span class="line">   updateTime   datetime     default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment &#x27;更新时间&#x27;,</span><br><span class="line">   isDelete     tinyint      default 0                 not null comment &#x27;是否删除&#x27;,</span><br><span class="line">   index idx_userId(userId)</span><br><span class="line">) comment &#x27;帖子&#x27; collate  = utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>

<p> 2.ES Mapping</p>
<p>在es中声明字段类型，既可以存放多个值，也可以存放单个值</p>
<p>ES中，尽量存放需要用户筛选（搜索）的数据,不要存放频繁变化的数据</p>
<p>字段类型是text,这个字段是可被分词的，可模糊查询的；而如果是keyword,只能完全匹配、精确查询。</p>
<p>analyzer(存储时生效的分词器)，ik_max_word，拆的更碎、索引更多，更有可能被搜出来</p>
<p>search_analyzer(查询时生效的分词器)，ik_smart，更偏向于用户想搜的分词</p>
<p>但如果用户又想精确查找一大段话，又要精确分词，就要加子字段fileds，并且类型为keyword</p>
<p>ES表结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">put post_v1</span><br><span class="line">&#123;</span><br><span class="line">//别名，为了方便后续数据迁移</span><br><span class="line">  &quot;aliases&quot;: &#123;</span><br><span class="line">    &quot;post&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        //使用分词器</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">        &quot;search_analyzer&quot;: &quot;ik_smart&quot;,</span><br><span class="line">        //但如果用户又想精确查找一大段话，又要精确分词，就要加子字段fileds</span><br><span class="line">        &quot;fields&quot;: &#123;</span><br><span class="line">          &quot;keyword&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">            &quot;ignore_above&quot;: 256 //如果用户的搜索词大于256个单词则拒绝查询</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;content&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">        &quot;search_analyzer&quot;: &quot;ik_smart&quot;,</span><br><span class="line">        &quot;fields&quot;: &#123;</span><br><span class="line">          &quot;keyword&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">            &quot;ignore_above&quot;: 256</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;tags&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;userId&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;createTime&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;date&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;updateTime&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;date&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;isDelete&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p>@Id的作用：如果你插入数据时指明了id，则系统提供的id与你提供的id是一样的</p>
<p>如果不输入id，系统会自动生成，但是不会在_source字段中补充id的值，所以建议手动指定id。</p>
<p>查询DSL：</p>
<p>组合条件</p>
<p>里面有个打分机制，根据关键字来区分是否有影响（must：有影响。filter：没影响）两个关键字效果一样</p>
<h4 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h4><p>logstash+kafka+beats</p>
<p>1.下载logstash，并修改config文件中的输入输出配置</p>
<p>2.logstash性能差，但是支持很多种输入输出</p>
<p>3.编写logstash配置：</p>
<p>输入配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  jdbc &#123;</span><br><span class="line">    jdbc_driver_library =&gt; &quot;D:\software\logstash-7.17.9\config\mysql-connector-java-8.0.29.jar&quot;</span><br><span class="line">    jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">    jdbc_connection_string =&gt; &quot;jdbc:mysql://localhost:3306/zbi&quot;</span><br><span class="line">    jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">    jdbc_password=&gt; &quot;123456&quot;</span><br><span class="line">    //sql_last_value：动态替换上次更新的最大时间</span><br><span class="line">    statement =&gt; &quot;SELECT * from post where updateTime &gt; :sql_last_value and updateTime &lt; now() order by updateTime desc&quot;    </span><br><span class="line">    //指定跟踪字段名，把最后一条的updateTime写进去</span><br><span class="line">    tracking_column =&gt; &quot;_sequence_key&quot;</span><br><span class="line">    tracking_column_type =&gt; &quot;numeric&quot;  </span><br><span class="line">    use_column_value =&gt; true</span><br><span class="line">    parameters =&gt; &#123; &quot;favorite_artist&quot; =&gt; &quot;Beethoven&quot; &#125;</span><br><span class="line">    schedule =&gt; &quot;*/5 * * * * *&quot;</span><br><span class="line">    jdbc_default_timezone =&gt; &quot;Asia/Shanghai&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码种使用SELECT * from post where updateTime &gt; :sql_last_value 预编译的SQL有什么优点？</p>
<p>1.灵活，模板好懂</p>
<p>2.快（有缓存）</p>
<p>3.部分防止SQL注入。</p>
<p>输出配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">  stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">        hosts =&gt; &quot;hostname&quot;</span><br><span class="line">        index =&gt; &quot;post_v1&quot;</span><br><span class="line">        document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>document_id &#x3D;&gt; “%{id}”将上述logstash从数据库中输入的id赋值给es的id</p>
<p>两个问题：</p>
<p>1.字段全变成小写了</p>
<p>2.多了一些不想同步的字段</p>
<p>方法：增加过滤</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">    mutate &#123;</span><br><span class="line">        rename =&gt; &#123;</span><br><span class="line">               &quot;updatetime&quot; =&gt; &quot;updateTime&quot;</span><br><span class="line">               &quot;userid&quot; =&gt; &quot;userId&quot;</span><br><span class="line">               &quot;createtime&quot; =&gt; &quot;createTime&quot;</span><br><span class="line">               &quot;isdelete&quot; =&gt; &quot;isDelete&quot;      </span><br><span class="line">              &#125;</span><br><span class="line">        remove_field =&gt; [&quot;thumbnum&quot;, &quot;favournum&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/15/%E8%81%9A%E5%90%88%E6%90%9C%E7%B4%A2/" data-id="clymgsig70002bgw014k040ur" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-OJ判题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/15/OJ%E5%88%A4%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2024-07-15T03:20:28.496Z" itemprop="datePublished">2024-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="库表设计"><a href="#库表设计" class="headerlink" title="库表设计"></a>库表设计</h4><p>题目表</p>
<p>题目内容：存放题目介绍，输入输出提示、描述、具体的详情</p>
<p>题目标签（Json数组字符串）：栈、队列、链表、简单、中等、困难</p>
<p>题目答案</p>
<p>提交数：通过题目的人数等，便于分析（可以考虑根据通过率自动给题目打难易度标签）</p>
<p>输入用例：</p>
<p>输出用例：</p>
<p>注意：如果输出用例和输入用例大于512M时，单独放在文件中，数据库存放url。</p>
<p>judgeConfig判题配置(Json对象)</p>
<p>时间限制：timeLimt</p>
<p>内存限制：memoryLimit</p>
<p>judgeConfig判题用例</p>
<p>输入用例：inputCase</p>
<p>输出用例：outputCase</p>
<p>结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		&quot;input&quot;: &quot;1,2&quot;,</span><br><span class="line">		&quot;output&quot;:&quot;3,4&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		&quot;input&quot;: &quot;1,3&quot;,</span><br><span class="line">		&quot;output&quot;:&quot;2,4&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>把判题相关的字段存放在Json对象中的好处？</p>
<p>便于维护，便于扩展。后面想要加功能时只需要在 Json中加字段即可，而不用修改数据库表（可能会影响数据库）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;timeLimit&quot;: 1000,</span><br><span class="line">	&quot;memoryLimit&quot;: 1000,</span><br><span class="line">	&quot;stackLimit&quot;: 1000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>什么情况下考虑存Json?</p>
<ol>
<li>不需要根据Json的字段反查，这个配置属于那条数据</li>
</ol>
<p>例：</p>
<p>​	  1. 不会根据输入输出用例去查题目，只会根据题目查</p>
<p>​	   2. 不会根据内存的限制和时间限制查题目</p>
<ol start="2">
<li>相似的字段可以存到Json中</li>
</ol>
<p>​	3. Json占用空间不能太大</p>
<p>题目表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 题目表</span><br><span class="line">create table if not exists question</span><br><span class="line">(</span><br><span class="line">    id         bigint auto_increment comment &#x27;id&#x27; primary key,</span><br><span class="line">    title      varchar(512)                       null comment &#x27;标题&#x27;,</span><br><span class="line">    content    text                               null comment &#x27;内容&#x27;,</span><br><span class="line">    tags       varchar(1024)                      null comment &#x27;标签列表（json 数组）&#x27;,</span><br><span class="line">    answer     text                               null comment &#x27;题目答案&#x27;,</span><br><span class="line">    submitNum  int      default 0                 not null comment &#x27;提交数&#x27;,</span><br><span class="line">    acceptNum  int      default 0                 not null comment &#x27;通过数&#x27;,</span><br><span class="line">    judgeCase text                                null comment &#x27;判题用例&#x27;,</span><br><span class="line">    judgeConfig text                                null comment &#x27;判题配置&#x27;,</span><br><span class="line">    thumbNum   int      default 0                 not null comment &#x27;点赞数&#x27;,</span><br><span class="line">    favourNum  int      default 0                 not null comment &#x27;收藏数&#x27;,</span><br><span class="line">    userId     bigint                             not null comment &#x27;创建用户 id&#x27;,</span><br><span class="line">    createTime datetime default CURRENT_TIMESTAMP not null comment &#x27;创建时间&#x27;,</span><br><span class="line">    updateTime datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment &#x27;更新时间&#x27;,</span><br><span class="line">    isDelete   tinyint  default 0                 not null comment &#x27;是否删除&#x27;,</span><br><span class="line">    index idx_userId (userId)</span><br><span class="line">) comment &#x27;帖子&#x27; collate = utf8mb4_unicode_ci;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>题目提交表</p>
<p>哪个用户提交了哪道题目，存放判题结果</p>
<p>提交用户id: userId</p>
<p>题目id: questionId</p>
<p>语言: language</p>
<p>用户的代码：code</p>
<p>判题状态: status(0-待判题，1-判题中，2判题成功，3-判题失败)</p>
<p>判题结果: result</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;message&quot;: &quot;程序执行信息&quot;,</span><br><span class="line">	&quot;time&quot;: 1000,//单位为毫秒</span><br><span class="line">	&quot;memory&quot;: 1000,//单位为kb</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>判题信息枚举值：</p>
<p>1.Accepted成功</p>
<p>2.Wrong Answer 答案错误</p>
<p>3.Compole Error 编译错误</p>
<p>4.Memory Limit Exceeded 内存溢出</p>
<p>5.Time Limit Exceed 时间超时</p>
<p>6.Presentation Error 展示错误</p>
<p>7.Output Limit Exceed:输出移除</p>
<p>8.Waiting 等待中</p>
<p>9.Dangerous Operation危险操作</p>
<p>10Runtime Error 运行错误（用户程序的问题）</p>
<p>11.System Error 系统错误（做系统的人的问题）</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>什么情况下适合加索引？如何选择给哪个字段加索引？</p>
<p>答：从业务触发，无论是单个索引，还是联合索引，都要从你实际的查询语句，字段枚举的区分度，字段的类型考虑（where条件指定的字段）</p>
<p>比如：where userId &#x3D; 1 and questionId &#x3D; 2</p>
<p>可以选择根据userId和questionId分别简历索引（需要分别根据这两个字段独立查询），也可以选择两个字段建立联合索引（锁查询的字段绑定在一起）</p>
<p>原则上：能不用索引就不用索引；能用单个索引就不用联合&#x2F;多个索引；因为索引也是占用空间的。不要给没区分度的字段加索引。</p>
<h4 id="后端接口开发"><a href="#后端接口开发" class="headerlink" title="后端接口开发"></a>后端接口开发</h4><p>后端接口开发流程</p>
<p>1.根据功能设计库表</p>
<p>2.自动生成基本的增删改查（mapper和service层的基本功能）</p>
<p>​	为了方便处理json字段中的某个字段，需要给对应的json字段编写独立的类，比如judgeConfig，judgeInfo，judgeCase。</p>
<p>​		什么情况下要加业务前缀？什么情况下不加？</p>
<p>​		加业务前缀的好处，防止多个表都有相似的字段，产生冲突</p>
<p>​		不加的前提，因为可能这个类是业务之间共享的，能够复用的。</p>
<p>​		updateRequest和editRequest的区别：前者是给管理员更新的，可以指定更多字段；后者是给普通用户试用的，只能指定部分字段。</p>
<p>​		定义VO类：作用是专门给前端返回对象，可以节约网络传输大小，或者过滤字段（脱敏）,保证安全性。比如judgeCase字段。</p>
<p>​		校验Controller层的代码，看看除了方法缺失外，还有无报错。</p>
<p>​		实现Sevice层代码</p>
<p>​		编写QuestionVO的json&#x2F;对象转换工具类</p>
<p>​		编写枚举类</p>
<p>3.编写Controller层，实现基本的增删改查和权限校验（复制粘贴）</p>
<p>4.去根据业务定制开发新的功能&#x2F;编写新的代码</p>
<p>更好的方法，编写自己的代码生成器</p>
<h4 id="查询提交信息"><a href="#查询提交信息" class="headerlink" title="查询提交信息"></a>查询提交信息</h4><p>功能：能够根据用户id或者题目id，编程语言，提交状态去查询提交记录</p>
<p>注意事项：仅本人和管理员能看见自己（提交userId和登录用户id不同）提交代码的答案、提交的代码</p>
<p>实现方案：先查询，再根据权限脱敏。</p>
<p>核心代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取题目表封装</span><br><span class="line"> *</span><br><span class="line"> * @param questionSubmit</span><br><span class="line"> * @param loginUser</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public QuestionSubmitVO getQuestionSubmitVO(QuestionSubmit questionSubmit, User loginUser) &#123;</span><br><span class="line">    // 对象转封装类</span><br><span class="line">    QuestionSubmitVO questionSubmitVO = QuestionSubmitVO.objToVo(questionSubmit);</span><br><span class="line">    //脱敏：仅本人和管理员能看见自己（提交userId和登录用户id不同）提交的代码</span><br><span class="line">    long userId = loginUser.getId();</span><br><span class="line">    if (userId != questionSubmit.getUserId() &amp;&amp; !userService.isAdmin(loginUser))&#123;</span><br><span class="line">        questionSubmitVO.setCode(null);</span><br><span class="line">    &#125;</span><br><span class="line">    return questionSubmitVO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="判题机模块预开发"><a href="#判题机模块预开发" class="headerlink" title="判题机模块预开发"></a>判题机模块预开发</h3><h4 id="梳理判题模块和代码沙箱的关系"><a href="#梳理判题模块和代码沙箱的关系" class="headerlink" title="梳理判题模块和代码沙箱的关系"></a>梳理判题模块和代码沙箱的关系</h4><p>判题模块：调用代码沙箱，把代码和输入交给沙箱去执行。</p>
<p>代码沙箱：只负责接收代码和输入，返回编译运行的结果，不负责判题。（可以作为独立的项目&#x2F;服务，提供给其它需要执行的代码）</p>
<p>这两个模块完全解耦。</p>
<p><img src="F:\迅雷下载\work\notebook\source_posts\OJ判题\Snipaste_2024-06-11_15-56-53.png" alt="Snipaste_2024-06-11_15-56-53"></p>
<h5 id="思考：为什么代码沙箱要接受和输出一组运行用例"><a href="#思考：为什么代码沙箱要接受和输出一组运行用例" class="headerlink" title="思考：为什么代码沙箱要接受和输出一组运行用例"></a>思考：为什么代码沙箱要接受和输出一组运行用例</h5><p>前提：每道题目有多组测试用例</p>
<p>如果是每个用例单独调用一次代码沙箱，会调用多次接口，需要多次网络传输、程序要多次编译，记录程序的执行状态（重复的代码不重复编译）</p>
<p>代码沙箱无状态。（调用远程接口时，想办法只调用一次）</p>
<p>这是一种常见的性能优化的方法！（批处理）</p>
<h4 id="代码沙箱模块开发"><a href="#代码沙箱模块开发" class="headerlink" title="代码沙箱模块开发"></a>代码沙箱模块开发</h4><p>1.定义代码沙箱接口，提高通用性</p>
<p>之后我们的项目代码只调用接口，不调用具体的实现类，这样在你使用其它的代码沙箱实现类时，就不用修改名称了，便于扩展。</p>
<blockquote>
<p>代码沙箱的请求接口，timeLimit可加可不加，可自行扩展，即时中断程序</p>
</blockquote>
<blockquote>
<p>扩展思路：增加一个查看代码沙箱状态的接口</p>
</blockquote>
<p>2.定义多种不同代码沙箱的实现。</p>
<p>​	示例代码沙箱</p>
<p>​	远程代码沙箱</p>
<p>​	第三方代码沙箱</p>
<p>lombok Builder注解</p>
<p>实体类加上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">//构造器创建对象</span><br><span class="line">@Builder</span><br><span class="line">//生成无参的构造函数</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">//生成有所有参数的构造函数</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class ExecuteCodeRequest &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; inputList;</span><br><span class="line"></span><br><span class="line">    private String code;</span><br><span class="line"></span><br><span class="line">    private String language;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3.编写单元测试，验证单个代码沙箱的执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void executeCode() &#123;</span><br><span class="line">    //建造者模式</span><br><span class="line">    CodeSandbox codeSandbox = new ExampleCodeSandboxImpl();</span><br><span class="line">    String code = &quot;int main()&#123; &#125;&quot;;</span><br><span class="line">    String language = QuestionSubmitLanguageEnum.JAVA.getValue();</span><br><span class="line">    List&lt;String&gt; inputList = Arrays.asList(&quot;1 2&quot;,&quot;3 4&quot;);</span><br><span class="line">    ExecuteCodeRequest executeCodeRequest = ExecuteCodeRequest.builder()</span><br><span class="line">            .code(code)</span><br><span class="line">            .language(language)</span><br><span class="line">            .inputList(inputList)</span><br><span class="line">            .build();</span><br><span class="line">    ExecuteCodeResponse executeCodeResponse = codeSandbox.executeCode(executeCodeRequest);</span><br><span class="line">    Assertions.assertNotNull(executeCodeResponse);</span><br></pre></td></tr></table></figure>



<p>现在的问题：我们把new某个沙箱的代码写死了，如果后面项目要改用其他沙箱，可能要改很多地方的代码。</p>
<p>4.使用工厂模式，根据用户传入的字符串（沙箱类别），来生成对应的代码沙箱实现类</p>
<p>这里没必要用抽象工厂：因为一个工厂只生产一个商品，而抽象工厂是生产多个商品。</p>
<p>此处使用静态工厂模式，实现比较简单，符合需求。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建代码沙箱示例</span><br><span class="line"> * @param type 沙箱类型</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static CodeSandbox newInstance(String type)&#123;</span><br><span class="line">    switch (type)&#123;</span><br><span class="line">        case &quot;example&quot;:</span><br><span class="line">            return new ExampleCodeSandboxImpl();</span><br><span class="line">        case &quot;remote&quot;:</span><br><span class="line">            return new RemoteCodeSandboxImpl();</span><br><span class="line">        case &quot;thirdParty&quot;:</span><br><span class="line">            return new ThirdPartyCodeSandboxImpl();</span><br><span class="line">        default:</span><br><span class="line">            return new ExampleCodeSandboxImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>扩展思路：如果确定代码沙箱示例不会出现线程安全问题，可复用，那么可以使用单例工厂模式（注册器模式）</p>
</blockquote>
<p>由此：我们可以根据字符串动态生成实例，提高了通用性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    void executeCode() &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext())&#123;</span><br><span class="line">            String type = scanner.next();</span><br><span class="line">            CodeSandbox codeSandbox = CodeSandboxFactory.newInstance(type);</span><br><span class="line">            String code = &quot;int main()&#123; &#125;&quot;;</span><br><span class="line">            String language = QuestionSubmitLanguageEnum.JAVA.getValue();</span><br><span class="line">            List&lt;String&gt; inputList = Arrays.asList(&quot;1 2&quot;,&quot;3 4&quot;);</span><br><span class="line">            //建造者模式</span><br><span class="line">            ExecuteCodeRequest executeCodeRequest = ExecuteCodeRequest.builder()</span><br><span class="line">                    .code(code)</span><br><span class="line">                    .language(language)</span><br><span class="line">                    .inputList(inputList)</span><br><span class="line">                    .build();</span><br><span class="line">            ExecuteCodeResponse executeCodeResponse = codeSandbox.executeCode(executeCodeRequest);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>可以暴露给用户，让用户调试使用哪个沙箱</p>
</blockquote>
<p>5.参数配置化，把项目中的一些可以交给用户去自定义的选项或字符串，写道配置文件中，这样开发者只需要改配置文件，而不需要看你的项目代码，就能自定义使用你项目的更多功能。</p>
<p>application.yml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 代码沙箱配置</span><br><span class="line">codesandbox:</span><br><span class="line">  type: example</span><br></pre></td></tr></table></figure>

<p>在Spring的Bean中通过@Value注解读取:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;&#123;codesandbox.type:example&#125;&quot;)</span><br><span class="line">private String value;</span><br></pre></td></tr></table></figure>



<p>问题：我们想知道传给代码沙箱的输入代码以及代码沙箱给的返回值，想要在日志中查看。每一个代码沙箱实例要打日志</p>
<p>6.代码沙箱能力增强</p>
<p>比如: 我们需要在调用代码沙箱前，输出请求参数日志；在代码沙箱调用后，输出想要结果日志，便于管理员去分析。</p>
<p>传统方式：每个代码沙箱类都写一遍log.info?难道每次调用代码沙箱前后都执行log?</p>
<p>使用代理模式：</p>
<p>原本：需要用户调用多次</p>
<p><img src="F:\迅雷下载\work\notebook\source_posts\OJ判题\Snipaste_2024-06-11_22-26-28.png" alt="Snipaste_2024-06-11_22-26-28"></p>
<p>使用代理后：不仅不用改变原本的代码沙箱实现类，而且对调用者来说，调用方式几乎没用任何改变任何改变，也不需要在调用沙箱的地方去写统计代码。</p>
<p><img src="F:\迅雷下载\work\notebook\source_posts\OJ判题\Snipaste_2024-06-11_22-28-06.png" alt="Snipaste_2024-06-11_22-28-06"></p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 代码沙箱代理类：增强代码沙箱的能力（增加打印输出）</span><br><span class="line"> * 本质上就相当于是中介</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">public class CodeSandboxProxy implements CodeSandbox&#123;</span><br><span class="line"></span><br><span class="line">    private final CodeSandbox codeSandbox;</span><br><span class="line"></span><br><span class="line">    public CodeSandboxProxy(CodeSandbox codeSandbox) &#123;</span><br><span class="line">        this.codeSandbox = codeSandbox;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public ExecuteCodeResponse executeCode(ExecuteCodeRequest executeCodeRequest) &#123;</span><br><span class="line">        log.info(&quot;代码沙箱请求信息&quot;+executeCodeRequest.toString());</span><br><span class="line">        ExecuteCodeResponse executeCodeResponse = codeSandbox.executeCode(executeCodeRequest);</span><br><span class="line">        log.info(&quot;代码沙箱响应信息&quot;+executeCodeResponse.toString());</span><br><span class="line">        return executeCodeResponse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CodeSanbox codeSanbox = COdeSanboxFactory.newInstance(type);</span><br><span class="line">codeSanbox = new CodeSanboxProxy(codeSanbox)</span><br></pre></td></tr></table></figure>



<p>刚刚做的：配置化，代理，方法的增强，根据参数动态的生成沙箱，包括哪些代码设置成接口</p>
<p>7.实现实例代码沙箱</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实例代码沙箱（仅为了跑通流程）</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">public class ExampleCodeSandboxImpl implements CodeSandbox &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ExecuteCodeResponse executeCode(ExecuteCodeRequest executeCodeRequest) &#123;</span><br><span class="line">        List&lt;String&gt; inputList = executeCodeRequest.getInputList();</span><br><span class="line"></span><br><span class="line">        ExecuteCodeResponse executeCodeResponse = new ExecuteCodeResponse();</span><br><span class="line">        executeCodeResponse.setOutputList(inputList);</span><br><span class="line">        executeCodeResponse.setMessage(&quot;测试执行成功&quot;);</span><br><span class="line">        executeCodeResponse.setStatus(QuestionSubmitStatusEnum.SUCCEED.getValue());</span><br><span class="line">        JudgeInfo judgeInfo = new JudgeInfo();</span><br><span class="line">        judgeInfo.setMessage(JudgeInfoMessageEnum.ACCEPTED.getText());</span><br><span class="line">        judgeInfo.setMemory(100L);</span><br><span class="line">        judgeInfo.setTime(100L);</span><br><span class="line">        executeCodeResponse.setJudgeInfo(judgeInfo);</span><br><span class="line">        return executeCodeResponse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以使用链式的方式更方便的给对象赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//建造者模式</span><br><span class="line">            ExecuteCodeRequest executeCodeRequest = ExecuteCodeRequest.builder()</span><br><span class="line">                    .code(code)</span><br><span class="line">                    .language(language)</span><br><span class="line">                    .inputList(inputList)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure>





<h4 id="判题服务完整业务流程实现"><a href="#判题服务完整业务流程实现" class="headerlink" title="判题服务完整业务流程实现"></a>判题服务完整业务流程实现</h4><p>判题服务业务流程</p>
<p>1.传入题目的提交id,获取到对应的题目，提交信息（包含代码、编程语言等）</p>
<p>2.如果题目的提交状态不为等待中，就不用重复执行了</p>
<p>3.更改判题（题目提交）的状态为“判题中”，防止重复执行，也能让用户看到状态。</p>
<p>4.调用沙箱，获取到执行结果</p>
<p>5.根据沙箱的执行结果，设置题目的判题状态和信息</p>
<p>​	</p>
<p>判断逻辑：</p>
<p>1.先判断执行的结果输出梳理是否和预期输出数量相等</p>
<p>2.依次判断每一项输出和预期输出是否相等</p>
<p>3.判断题目的限制是否符合要求</p>
<p>4.可能还有其它的异常情况</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class JudgeServiceImpl implements JudgeService &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private QuestionService questionService;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private QuestionSubmitService questionSubmitService;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;&#123;codesandbox.type:example&#125;&quot;)</span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public QuestionSubmitVO doJudge(long questionSubmitId) &#123;</span><br><span class="line">        //1.传入题目的提交id,获取到对应的题目，提交信息（包含代码、编程语言等）</span><br><span class="line">        QuestionSubmit questionSubmit = questionSubmitService.getById(questionSubmitId);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (questionSubmit == null)&#123;</span><br><span class="line">            throw new BusinessException(ErrorCode.NOT_FOUND_ERROR,&quot;提交信息不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Long questionId = questionSubmit.getQuestionId();</span><br><span class="line">        Question question = questionService.getById(questionId);</span><br><span class="line">        if (question == null)&#123;</span><br><span class="line">            throw new BusinessException(ErrorCode.NOT_FOUND_ERROR,&quot;题目不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //2.如果题目的提交状态不为等待中，就不用重复执行了</span><br><span class="line">        if (questionSubmit.getStatus() != QuestionSubmitStatusEnum.WAITING.getValue())&#123;</span><br><span class="line">            throw new BusinessException(ErrorCode.OPERATION_ERROR,&quot;题目正在判题中&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //3.更改判题（题目提交）的状态为“判题中”，防止重复执行，也能让用户看到状态。</span><br><span class="line">        QuestionSubmit questionSubmitUpdate = new QuestionSubmit();</span><br><span class="line">        questionSubmitUpdate.setQuestionId(questionId);</span><br><span class="line">        questionSubmitUpdate.setStatus(QuestionSubmitStatusEnum.RUNNING.getValue());</span><br><span class="line">        boolean update = questionSubmitService.updateById(questionSubmitUpdate);</span><br><span class="line">        if (!update)&#123;</span><br><span class="line">            throw new BusinessException(ErrorCode.SYSTEM_ERROR,&quot;更新题目提交状态错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //4.调用沙箱，获取到执行结果</span><br><span class="line">        CodeSandbox codeSandbox = CodeSandboxFactory.newInstance(type);</span><br><span class="line">        codeSandbox = new CodeSandboxProxy(codeSandbox);</span><br><span class="line">        String language = questionSubmit.getLanguage();</span><br><span class="line">        String code = questionSubmit.getCode();</span><br><span class="line">        //获取输入用例</span><br><span class="line">        String judgeCaseStr = question.getJudgeCase();</span><br><span class="line">        List&lt;JudgeCase&gt; judgeCaseList = JSONUtil.toList(judgeCaseStr, JudgeCase.class);</span><br><span class="line">        List&lt;String&gt; inputList = judgeCaseList.stream().map(JudgeCase::getInput).collect(Collectors.toList());</span><br><span class="line">        //建造者模式</span><br><span class="line">        ExecuteCodeRequest executeCodeRequest = ExecuteCodeRequest.builder()</span><br><span class="line">                .code(code)</span><br><span class="line">                .language(language)</span><br><span class="line">                .inputList(inputList)</span><br><span class="line">                .build();</span><br><span class="line">        ExecuteCodeResponse executeCodeResponse = codeSandbox.executeCode(executeCodeRequest);</span><br><span class="line">        List&lt;String&gt; outputList = executeCodeResponse.getOutputList();</span><br><span class="line">        //5.根据沙箱的执行结果，设置题目的判题状态和信息</span><br><span class="line">        JudgeInfoMessageEnum judgeInfoMessageEnum = JudgeInfoMessageEnum.WAITING;</span><br><span class="line">        //先判断执行的结果输出梳理是否和预期输出数量相等</span><br><span class="line">        if (outputList.size() != inputList.size())&#123;</span><br><span class="line">            //如果输出结果和输入用例数量不一致，判题失败</span><br><span class="line">            judgeInfoMessageEnum = JudgeInfoMessageEnum.WRONG_ANSWER;</span><br><span class="line">        &#125;</span><br><span class="line">        //依次判断每一项输出和预期输出是否相等</span><br><span class="line">        for (int i = 0; i &lt; judgeCaseList.size(); i++) &#123;</span><br><span class="line">            JudgeCase judgeCase = judgeCaseList.get(i);</span><br><span class="line">            if (!judgeCase.getOutput().equals(outputList.get(i)))&#123;</span><br><span class="line">                //如果输出结果和输入用例不一致，判题失败</span><br><span class="line">                judgeInfoMessageEnum = JudgeInfoMessageEnum.WRONG_ANSWER;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断题目的限制是否符合要求</span><br><span class="line">        JudgeInfo judgeInfo = executeCodeResponse.getJudgeInfo();</span><br><span class="line">        Long memory = judgeInfo.getMemory();</span><br><span class="line">        Long time = judgeInfo.getTime();</span><br><span class="line">        String judgeConfigStr = question.getJudgeConfig();</span><br><span class="line">        JudgeConfig judgeConfig = JSONUtil.toBean(judgeConfigStr, JudgeConfig.class);</span><br><span class="line">        Long needMemoryLimit = judgeConfig.getMemoryLimit();</span><br><span class="line">        Long needTimeLimit = judgeConfig.getTimeLimit();</span><br><span class="line">        if (memory &gt; needMemoryLimit)&#123;</span><br><span class="line">            judgeInfoMessageEnum = JudgeInfoMessageEnum.MEMORY_LIMIT_EXCEED;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (time &gt; needTimeLimit)&#123;</span><br><span class="line">            judgeInfoMessageEnum = JudgeInfoMessageEnum.TIME_LIMIT_EXCEED;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="策略模式优化判题代码"><a href="#策略模式优化判题代码" class="headerlink" title="策略模式优化判题代码"></a>策略模式优化判题代码</h4><p>我们的判题策略可能会有很多种，比如我们的代码沙箱本身执行程序需要消耗时间，这个时间可能不同的编程语言是不同的，比如沙箱执行Java要额外花10s。</p>
<p>我们可以采用策略模式，针对不同情况，定义独立的策略，而不是把所有的判题逻辑if…else代码放在一起写。</p>
<p>1.定义策略接口</p>
<p>2.定义实现类为默认策略</p>
<p>3.复制策略，发现爆红</p>
<p>4.创建上下文类，把爆红的变量在改类中定义</p>
<p>默认判题逻辑模块代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 默认判题策略</span><br><span class="line"> */</span><br><span class="line">public class DefaultJudgeStrategy implements JudgeStrategy &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 执行判题</span><br><span class="line">     * </span><br><span class="line">     * @param judgeContext</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public JudgeInfo doJudge(JudgeContext judgeContext) &#123;</span><br><span class="line"></span><br><span class="line">        JudgeInfo judgeInfo = judgeContext.getJudgeInfo();</span><br><span class="line">        Long memory = judgeInfo.getMemory();</span><br><span class="line">        Long time = judgeInfo.getTime();</span><br><span class="line">        List&lt;String&gt; inputList = judgeContext.getInputList();</span><br><span class="line">        List&lt;String&gt; outputList = judgeContext.getOutputList();</span><br><span class="line">        Question question = judgeContext.getQuestion();</span><br><span class="line">        List&lt;JudgeCase&gt; judgeCaseList = judgeContext.getJudgeCaseList();</span><br><span class="line">        //默认值为accept</span><br><span class="line">        JudgeInfoMessageEnum judgeInfoMessageEnum = JudgeInfoMessageEnum.ACCEPTED;</span><br><span class="line">        JudgeInfo judgeInfoResponse = new JudgeInfo();</span><br><span class="line">        judgeInfoResponse.setMemory(memory);</span><br><span class="line">        judgeInfoResponse.setTime(time);</span><br><span class="line">        //先判断执行的结果输出梳理是否和预期输出数量相等</span><br><span class="line">        if (outputList.size() != inputList.size())&#123;</span><br><span class="line">            //如果输出结果和输入用例数量不一致，判题失败</span><br><span class="line">            judgeInfoMessageEnum = JudgeInfoMessageEnum.WRONG_ANSWER;</span><br><span class="line">        &#125;</span><br><span class="line">        //依次判断每一项输出和预期输出是否相等</span><br><span class="line">        for (int i = 0; i &lt; judgeCaseList.size(); i++) &#123;</span><br><span class="line">            JudgeCase judgeCase = judgeCaseList.get(i);</span><br><span class="line">            if (!judgeCase.getOutput().equals(outputList.get(i)))&#123;</span><br><span class="line">                //如果输出结果和输入用例不一致，判题失败</span><br><span class="line">                judgeInfoMessageEnum = JudgeInfoMessageEnum.WRONG_ANSWER;</span><br><span class="line">                judgeInfoResponse.setMessage(judgeInfoMessageEnum.getValue());</span><br><span class="line">                return judgeInfoResponse;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断题目的限制是否符合要求</span><br><span class="line">        String judgeConfigStr = question.getJudgeConfig();</span><br><span class="line">        JudgeConfig judgeConfig = JSONUtil.toBean(judgeConfigStr, JudgeConfig.class);</span><br><span class="line">        Long needMemoryLimit = judgeConfig.getMemoryLimit();</span><br><span class="line">        Long needTimeLimit = judgeConfig.getTimeLimit();</span><br><span class="line">        if (memory &gt; needMemoryLimit)&#123;</span><br><span class="line">            judgeInfoMessageEnum = JudgeInfoMessageEnum.MEMORY_LIMIT_EXCEED;</span><br><span class="line">            judgeInfoResponse.setMessage(judgeInfoMessageEnum.getValue());</span><br><span class="line">            return judgeInfoResponse;</span><br><span class="line">        &#125;</span><br><span class="line">        if (time &gt; needTimeLimit)&#123;</span><br><span class="line">            judgeInfoMessageEnum = JudgeInfoMessageEnum.TIME_LIMIT_EXCEED;</span><br><span class="line">            judgeInfoResponse.setMessage(judgeInfoMessageEnum.getValue());</span><br><span class="line">            return judgeInfoResponse;</span><br><span class="line">        &#125;</span><br><span class="line">        //返回judgeInfoResponse</span><br><span class="line">        judgeInfoResponse.setMessage(judgeInfoMessageEnum.getValue());</span><br><span class="line">        return judgeInfoResponse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>如果选择某种判题策略的过程比较复杂，都写在调用判题服务的代码中，代码会越来越复杂，会有很多if…else…,建议单独编写一共判断策略的类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JudgeStrategy judgeStrategy = new DefaultJudgeStrategy();</span><br><span class="line">        //如果是java程序</span><br><span class="line">        if (language.equals(&quot;java&quot;))&#123;</span><br><span class="line">            judgeStrategy = new JavaLanguageJudgeStrategy();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>JudgeManager的目的：尽量简化对判题功能的调用，让调用方最简单。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判题管理（简化调用）:做了一层封装</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class JudgeManager &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行判题</span><br><span class="line">     *</span><br><span class="line">     * @param judgeContext</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    JudgeInfo doJudge(JudgeContext judgeContext)&#123;</span><br><span class="line">        QuestionSubmit questionSubmit = judgeContext.getQuestionSubmit();</span><br><span class="line">        String language = questionSubmit.getLanguage();</span><br><span class="line">        JudgeStrategy judgeStrategy = new DefaultJudgeStrategy();</span><br><span class="line">        //如果是java程序</span><br><span class="line">        if (&quot;java&quot;.equals(language))&#123;</span><br><span class="line">            judgeStrategy = new JavaLanguageJudgeStrategy();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return judgeStrategy.doJudge(judgeContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="代码沙箱实现"><a href="#代码沙箱实现" class="headerlink" title="代码沙箱实现"></a>代码沙箱实现</h3><p>代码沙箱：只负责接收代码和输入，返回编译运行结果，不负责判题（可以作为独立的项目&#x2F;服务，提供给其它的需要执行代码的项目去使用）</p>
<p>以Java编程语言为主，重要的是学思想，学关键流程</p>
<blockquote>
<p>扩展：可以自行实现C++语言的代码沙箱</p>
</blockquote>
<p>新建一个Spring Boot Web 项目，最终这个项目要提供一共能执行代码，操作代码沙箱的接口。</p>
<h4 id="Java原生实现代码沙箱"><a href="#Java原生实现代码沙箱" class="headerlink" title="Java原生实现代码沙箱"></a>Java原生实现代码沙箱</h4><p>原生：尽可能不借助第三方库和依赖，用最干净、最原始的方式实现代码沙箱</p>
<p>代码沙箱需要：接收代码-&#x3D;&gt;编译代码(javac)&#x3D;&gt;执行代码(java)</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java -cp . SimpleCompute 1 2</span><br><span class="line"></span><br><span class="line">//编写示例代码，注意去掉包名，放到resource的目录下</span><br><span class="line">public class SimpleCompute &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = Integer.parseInt(args[0]);</span><br><span class="line">        int b = Integer.parseInt(args[1]);</span><br><span class="line">        System.out.println(&quot;结果:&quot; + (a+b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为什么编译后的程序中文乱码？</p>
<p>命令行终端的编码是GBK和java代码文件本身的编码UTF-8不一致，导致乱码。</p>
<p>改变控制台的编码：chcp 65001（UTF-8） 936（GBK）</p>
<p>不建议改变终端编码，因为其它运行你代码的人也要改变环境，兼容性查。</p>
<p>可以指定编码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding utf-8 .\SimpleCompute.java</span><br></pre></td></tr></table></figure>



<p>实际OJ系统中，对用户输入的代码会有一定的要求，便于系统统一的处理，所以此处，我们把用户输入代码的类名限制为Main(参考Poj)，减少类名不一致的风险，而且不用从用户代码中提取类名。</p>
<p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = Integer.parseInt(args[0]);</span><br><span class="line">        int b = Integer.parseInt(args[1]);</span><br><span class="line">        System.out.println(&quot;结果:&quot; + (a+b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实际执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding utf-8 Main.java</span><br><span class="line">java -cp .Main 1 2 </span><br></pre></td></tr></table></figure>





<h4 id="核心流程实现"><a href="#核心流程实现" class="headerlink" title="核心流程实现"></a>核心流程实现</h4><p>核心实现思路：用程序去代替人工，用程序来操作命令行，去编译执行代码</p>
<p>Java进程执行管理类Process。</p>
<p>1.把用户的代码保存为文件</p>
<p>2.编译代码。得到class文件</p>
<p>3.执行代码，得到输出结果</p>
<p>4.收集整理输出结果</p>
<p>5.文件清理</p>
<p>6.错误处理，提升程序健壮性</p>
<h5 id="1-把用户的代码保存为文件"><a href="#1-把用户的代码保存为文件" class="headerlink" title="1.把用户的代码保存为文件"></a>1.把用户的代码保存为文件</h5><p>引入hutool工具类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://hutool.cn/docs/index.html#/--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.8.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>新建目录，每个用户的代码都存放在独立目录下，便于维护</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; inputList = executeCodeRequest.getInputList();</span><br><span class="line">        String code = executeCodeRequest.getCode();</span><br><span class="line">        String language = executeCodeRequest.getLanguage();</span><br><span class="line"></span><br><span class="line">        String userDir = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line">        String globalCodePathName = userDir + File.separator +GLOBAL_CODE_DIR_NAME;</span><br><span class="line"></span><br><span class="line">        //判断全局diamagnetic目录是否存在，没有则新建,有线程安全，不应该反复执行，放在全局共享类</span><br><span class="line">        if (!FileUtil.exist(globalCodePathName)) &#123;</span><br><span class="line">            FileUtil.mkdir(globalCodePathName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //把用户的代码隔离存放</span><br><span class="line">        String userCodeParentPath = globalCodePathName + File.separator + UUID.randomUUID();</span><br><span class="line">        String userCodePath = userCodeParentPath + File.separator + DEFAULT_JAVA_CLASS_NAME;</span><br><span class="line">        File userCodeFile = FileUtil.writeString(code, userCodePath, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>



<h5 id="2-编译代码。得到class文件"><a href="#2-编译代码。得到class文件" class="headerlink" title="2.编译代码。得到class文件"></a>2.编译代码。得到class文件</h5><p>Java执行程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process process = Runtime.getRuntime().exec(compileCmd);</span><br></pre></td></tr></table></figure>



<p>Java获取控制台的输出</p>
<p>通过exitValue判断程序是否正常返回，从inputStream和errorStream获取控制台输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String compileCmd = String.format(&quot;javac -encoding utf-8 %s&quot;,userCodeFile.getAbsoluteFile());</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; inputList = executeCodeRequest.getInputList();</span><br><span class="line">        String code = executeCodeRequest.getCode();</span><br><span class="line">        String language = executeCodeRequest.getLanguage();</span><br><span class="line"></span><br><span class="line">        //1.把用户的代码保存为文件</span><br><span class="line">        String userDir = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line">        String globalCodePathName = userDir + File.separator +GLOBAL_CODE_DIR_NAME;</span><br><span class="line"></span><br><span class="line">        //判断全局diamagnetic目录是否存在，没有则新建,有线程安全，不应该反复执行，放在全局共享类</span><br><span class="line">        if (!FileUtil.exist(globalCodePathName)) &#123;</span><br><span class="line">            FileUtil.mkdir(globalCodePathName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //把用户的代码隔离存放</span><br><span class="line">        String userCodeParentPath = globalCodePathName + File.separator + UUID.randomUUID();</span><br><span class="line">        String userCodePath = userCodeParentPath + File.separator + DEFAULT_JAVA_CLASS_NAME;</span><br><span class="line">        File userCodeFile = FileUtil.writeString(code, userCodePath, StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        //2.编译代码。得到class文件</span><br><span class="line">        String compileCmd = String.format(&quot;javac -encoding utf-8 %s&quot;,userCodeFile.getAbsoluteFile());</span><br><span class="line">        try &#123;</span><br><span class="line">            Process compileProcess = Runtime.getRuntime().exec(compileCmd);</span><br><span class="line">            //等待程序执行，获取错误码</span><br><span class="line">            int exitValue = compileProcess.waitFor();</span><br><span class="line">            //正常退出</span><br><span class="line">            if (exitValue == 0)&#123;</span><br><span class="line">                System.out.println(&quot;编译成功&quot;);</span><br><span class="line">                //分批获取进程的正常输出</span><br><span class="line">                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(compileProcess.getInputStream()));</span><br><span class="line">                StringBuilder compileOutPutStringBuilder = new StringBuilder();</span><br><span class="line">                //逐行读取</span><br><span class="line">                String compileOutputLine;</span><br><span class="line">                while ((compileOutputLine = bufferedReader.readLine())!= null)&#123;</span><br><span class="line">                    compileOutPutStringBuilder.append(compileOutputLine);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(compileOutPutStringBuilder);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                //异常退出</span><br><span class="line">                System.out.println(&quot;编译失败，错误码&quot;+exitValue);</span><br><span class="line">                //分批获取进程的正常输出</span><br><span class="line">                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(compileProcess.getInputStream()));</span><br><span class="line">                StringBuilder compileOutPutStringBuilder = new StringBuilder();</span><br><span class="line">                //逐行读取</span><br><span class="line">                String compileOutputLine;</span><br><span class="line">                while ((compileOutputLine = bufferedReader.readLine())!= null)&#123;</span><br><span class="line">                    compileOutPutStringBuilder.append(compileOutputLine);</span><br><span class="line">                &#125;</span><br><span class="line">                //分批获取进程的错误输出</span><br><span class="line">                BufferedReader errorBufferedReader = new BufferedReader(new InputStreamReader(compileProcess.getErrorStream()));</span><br><span class="line">                StringBuilder errorCompileOutPutStringBuilder = new StringBuilder();</span><br><span class="line">                //逐行读取</span><br><span class="line">                String errorCompileOutputLine;</span><br><span class="line">                while ((errorCompileOutputLine = errorBufferedReader.readLine())!= null)&#123;</span><br><span class="line">                    errorCompileOutPutStringBuilder.append(errorCompileOutputLine);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(compileOutPutStringBuilder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException | InterruptedException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>编写一共工具类，执行进程，并且获取输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 进程工具类</span><br><span class="line"> */</span><br><span class="line">public class ProcessUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行进程并获取信息</span><br><span class="line">     * </span><br><span class="line">     * @param runProcess</span><br><span class="line">     * @param opName</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static ExecuteMessage runProcessAndGetMessage(Process runProcess,String opName)&#123;</span><br><span class="line"></span><br><span class="line">        ExecuteMessage executeMessage = new ExecuteMessage;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //等待程序执行，获取错误码</span><br><span class="line">            int exitValue = runProcess.waitFor();</span><br><span class="line">            executeMessage.setExitCode(exitValue);</span><br><span class="line"></span><br><span class="line">            //正常退出</span><br><span class="line">            if (exitValue == 0)&#123;</span><br><span class="line">                System.out.println(opName+&quot;成功&quot;);</span><br><span class="line">                //分批获取进程的正常输出</span><br><span class="line">                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(runProcess.getInputStream()));</span><br><span class="line">                StringBuilder compileOutPutStringBuilder = new StringBuilder();</span><br><span class="line">                //逐行读取</span><br><span class="line">                String compileOutputLine;</span><br><span class="line">                while ((compileOutputLine = bufferedReader.readLine())!= null)&#123;</span><br><span class="line">                    compileOutPutStringBuilder.append(compileOutputLine);</span><br><span class="line">                &#125;</span><br><span class="line">                executeMessage.setMessage(compileOutPutStringBuilder.toString());</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                //异常退出</span><br><span class="line">                System.out.println(opName+&quot;失败，错误码&quot;+exitValue);</span><br><span class="line">                //分批获取进程的正常输出</span><br><span class="line">                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(runProcess.getInputStream()));</span><br><span class="line">                StringBuilder compileOutPutStringBuilder = new StringBuilder();</span><br><span class="line">                //逐行读取</span><br><span class="line">                String compileOutputLine;</span><br><span class="line">                while ((compileOutputLine = bufferedReader.readLine())!= null)&#123;</span><br><span class="line">                    compileOutPutStringBuilder.append(compileOutputLine);</span><br><span class="line">                &#125;</span><br><span class="line">                //分批获取进程的错误输出</span><br><span class="line">                BufferedReader errorBufferedReader = new BufferedReader(new InputStreamReader(runProcess.getErrorStream()));</span><br><span class="line">                StringBuilder errorCompileOutPutStringBuilder = new StringBuilder();</span><br><span class="line">                //逐行读取</span><br><span class="line">                String errorCompileOutputLine;</span><br><span class="line">                while ((errorCompileOutputLine = errorBufferedReader.readLine())!= null)&#123;</span><br><span class="line">                    errorCompileOutPutStringBuilder.append(errorCompileOutputLine);</span><br><span class="line">                &#125;</span><br><span class="line">                executeMessage.setErrorMessage(errorCompileOutPutStringBuilder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return executeMessage;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-执行程序"><a href="#3-执行程序" class="headerlink" title="3.执行程序"></a>3.执行程序</h5><p>同样是使用process运行，命令中记得增加-Dfile.encoding&#x3D;UTF-8参数，解决中文乱码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String rumCmd = String.format(&quot;java -Dfile.encoding=UTF-8 -cp %s Main %s&quot;,userCodeParentPath,inputArgs);</span><br></pre></td></tr></table></figure>



<p>很多OJ都是ACM模式，需要和用户交互的方式，让用户不断输入内容并获取输出。</p>
<p>对于此类程序，我们需要使用OutpuStream向程序终端发送参数，并及时获取结果，注意最后要关闭流释放资源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 执行交互式进程并获取信息</span><br><span class="line"> *</span><br><span class="line"> * @param runProcess</span><br><span class="line"> * @param opName</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static ExecuteMessage runInteractProcessAndGetMessage(Process runProcess,String args)&#123;</span><br><span class="line"></span><br><span class="line">    ExecuteMessage executeMessage = new ExecuteMessage();</span><br><span class="line">    try &#123;</span><br><span class="line">        //向控制台输入程序</span><br><span class="line">        OutputStream outputStream = runProcess.getOutputStream();</span><br><span class="line">        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);</span><br><span class="line">        String[] s = args.split(&quot; &quot;);</span><br><span class="line">        String join = StrUtil.join(&quot;\n&quot;, s)+&quot;\n&quot;;</span><br><span class="line">        outputStreamWriter.write(join);</span><br><span class="line">        //相当于回车，执行输入的发送</span><br><span class="line">        outputStreamWriter.flush();</span><br><span class="line"></span><br><span class="line">        //分批获取进程的正常输出</span><br><span class="line">        InputStream inputStream = runProcess.getInputStream();</span><br><span class="line">        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">        StringBuilder compileOutPutStringBuilder = new StringBuilder();</span><br><span class="line">        //逐行读取</span><br><span class="line">        String compileOutputLine;</span><br><span class="line">        while ((compileOutputLine = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">            compileOutPutStringBuilder.append(compileOutputLine);</span><br><span class="line">        &#125;</span><br><span class="line">        executeMessage.setMessage(compileOutPutStringBuilder.toString());</span><br><span class="line">        //记得资源释放，否则会卡顿</span><br><span class="line">        outputStreamWriter.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        runProcess.destroy();</span><br><span class="line">    &#125; catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return executeMessage;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-整理输出"><a href="#4-整理输出" class="headerlink" title="4.整理输出"></a>4.整理输出</h5><p>获取程序的执行时间，使用spring的StopWatch获取一段的执行时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StopWatch stopWatch = new StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">stopWatch.stop();    executeMessage.setTime(stopWatch.getLastTaskTimeMillis());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展：可以每个测试用例都有一共独立的内存，时间占用的统计</p>
</blockquote>
<p>此处我们使用最大值统计时间，便于后续判题服务计算程序是否超时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//取用时最大值，便于判断是否超时</span><br><span class="line">long maxTime = 0;</span><br><span class="line">for (ExecuteMessage executeMessage : executeMessagesList) &#123;</span><br><span class="line">    String errorMessage = executeMessage.getErrorMessage();</span><br><span class="line">    if (StrUtil.isNotBlank(errorMessage))&#123;</span><br><span class="line">        executeCodeResponse.setMessage(errorMessage);</span><br><span class="line">        //执行中存在错误</span><br><span class="line">        executeCodeResponse.setStatus(3);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    outputList.add(executeMessage.getMessage());</span><br><span class="line">    Long time = executeMessage.getTime();</span><br><span class="line">    if (time != null)&#123;</span><br><span class="line">        maxTime = Math.max(maxTime,time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-文件清理"><a href="#5-文件清理" class="headerlink" title="5.文件清理"></a>5.文件清理</h5><p>防止服务器空间不足</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//5.文件清理</span><br><span class="line">if (userCodeFile.getParentFile()!=null)&#123;</span><br><span class="line">    boolean del = FileUtil.del(userCodeParentPath);</span><br><span class="line">    System.out.println(&quot;删除&quot;+(del ? &quot;成功&quot; : &quot;失败&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="6-编写错误处理"><a href="#6-编写错误处理" class="headerlink" title="6.编写错误处理"></a>6.编写错误处理</h5><p>封装一共错误处理方法，当程序抛出异常时，直接返回错误响应</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 获取错误响应</span><br><span class="line">    * </span><br><span class="line">    * @param e</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   private ExecuteCodeResponse getErrorResponse(Throwable e)&#123;</span><br><span class="line">       ExecuteCodeResponse executeCodeResponse = new ExecuteCodeResponse();</span><br><span class="line">       executeCodeResponse.setOutputList(new ArrayList&lt;&gt;());</span><br><span class="line">       executeCodeResponse.setMessage(e.getMessage());</span><br><span class="line">       //2表示代码沙箱错误，表示本系统执行过程中的错误</span><br><span class="line">       executeCodeResponse.setStatus(2);</span><br><span class="line">       executeCodeResponse.setJudgeInfo(new JudgeInfo());</span><br><span class="line">       return executeCodeResponse;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="异常情况演示"><a href="#异常情况演示" class="headerlink" title="异常情况演示"></a>异常情况演示</h4><p>到目前为止，核心流程已经实现，但是想要上线的话，安全么？</p>
<p>用户提交恶意代码，如何解决？</p>
<h5 id="1-执行阻塞，占用资源不释放"><a href="#1-执行阻塞，占用资源不释放" class="headerlink" title="1.执行阻塞，占用资源不释放"></a>1.执行阻塞，占用资源不释放</h5><p>时间上的攻击</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 无线睡眠（阻塞程序执行）</span><br><span class="line"> */</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        long ONE_HOUR =60*60*1000L;</span><br><span class="line">        Thread.sleep(ONE_HOUR);</span><br><span class="line">        System.out.println(&quot;睡完了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要把写好的代码复制到resources中，并且一定要把类名改为Main! 包名一定要去掉！</p>
<h5 id="2-占用内存，不释放"><a href="#2-占用内存，不释放" class="headerlink" title="2.占用内存，不释放"></a>2.占用内存，不释放</h5><p>空间上的攻击</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 无限占用空间(浪费系统内存）</span><br><span class="line"> */</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //不能定义对象,JVM会回收</span><br><span class="line">        List&lt;byte[]&gt; bytes = new ArrayList&lt;&gt;();</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            bytes.add(new byte[10000]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实际运行中，会发现，内存占用到达一定的空间后，程序就会自动报错</p>
<p>这是JVM的保护机制。	</p>
<p>JVisualVM或 JConsole工具，可以连接到JVM虚拟机上来可视化查看JVM的状态。</p>
<p>方式：限制JVM内存</p>
<h5 id="3-读文件，文件信息泄露"><a href="#3-读文件，文件信息泄露" class="headerlink" title="3.读文件，文件信息泄露"></a>3.读文件，文件信息泄露</h5><p>直接通过相对路径获取文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 读取服务器文件（文件信息泄露）</span><br><span class="line"> */</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        String userDir = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line">        String filePath = userDir + File.separator + &quot;src/main/resources/application.yml&quot;;</span><br><span class="line">        List&lt;String&gt; allLines = Files.readAllLines(Paths.get(filePath));</span><br><span class="line">        System.out.println(String.join(&quot;\n&quot;,allLines));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-写文件，越权植入木马"><a href="#4-写文件，越权植入木马" class="headerlink" title="4.写文件，越权植入木马"></a>4.写文件，越权植入木马</h5><p>假设有一个木马程序：java -version 2&gt;&amp;1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 向服务器中写文件(植入危险程序)</span><br><span class="line"> */</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        String userDir = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line">        String filePath = userDir + File.separator + &quot;src/main/resources/木马程序.bat&quot;;</span><br><span class="line">        String errorProgram = &quot;java -version 2&gt;&amp;1&quot;;</span><br><span class="line">        Files.write(Paths.get(filePath), Arrays.asList(errorProgram));</span><br><span class="line">        System.out.println(&quot;木马写入成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="5-运行其它程序"><a href="#5-运行其它程序" class="headerlink" title="5.运行其它程序"></a>5.运行其它程序</h5><p>直接通过Process执行危险程序，或者电脑上的其它程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 运行其它程序（比如危险木马）</span><br><span class="line"> */</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class="line">        String userDir = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line">        String filePath = userDir + File.separator + &quot;src/main/resources/木马程序.bat&quot;;</span><br><span class="line">        Process process = Runtime.getRuntime().exec(filePath);</span><br><span class="line">        process.waitFor();</span><br><span class="line">        //分批获取进程的正常输出</span><br><span class="line">        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));</span><br><span class="line">        //逐行读取</span><br><span class="line">        String compileOutputLine;</span><br><span class="line">        while ((compileOutputLine = bufferedReader.readLine())!= null)&#123;</span><br><span class="line">            System.out.println(compileOutputLine);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;执行程序成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="6-执行高危命令"><a href="#6-执行高危命令" class="headerlink" title="6.执行高危命令"></a>6.执行高危命令</h5><p>甚至都不用写木马文件，直接执行系统自带的危险命令</p>
<p>比如删除服务器的所有文件</p>
<p>比如执行dir(windows)、ls(linux)获取你系统上的所有文件信息</p>
<h4 id="怎么解决？"><a href="#怎么解决？" class="headerlink" title="怎么解决？"></a>怎么解决？</h4><p>1.超时控制</p>
<p>2.限制给用户分配资源</p>
<p>3.限制代码-黑白名单</p>
<p>4.限制用户的操作权限（文件、网络、执行）</p>
<p>5.运行环境隔离</p>
<h5 id="1-超时控制"><a href="#1-超时控制" class="headerlink" title="1.超时控制"></a>1.超时控制</h5><p>通过创建一共守护线程，超时后自动中断process实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">                   //超时控制</span><br><span class="line">                   try &#123;</span><br><span class="line">                       Thread.sleep(TIME_OUT);</span><br><span class="line">                       System.out.println(&quot;超时了，中断&quot;);</span><br><span class="line">                       runProcess.destroy();</span><br><span class="line">                   &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                       throw new RuntimeException(e);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;).start();</span><br></pre></td></tr></table></figure>



<h5 id="2-限制资源分配"><a href="#2-限制资源分配" class="headerlink" title="2.限制资源分配"></a>2.限制资源分配</h5><p>我们不能让每个java进程的执行占用的JVM最大堆内存空间和系统的一致，实际上应该小一点。</p>
<p>在启动Java时，可以指定JVM参数：-Xmx256m(最大堆空间大小) -Xms(初始堆空间大小)</p>
<p>-Xms应用场景：一开始进程就可以分配到资源，不用浪费时间进行动态分配。</p>
<p>案例：游戏启动前要加载一堆东西或者hashmap性能高的话，一开始就定义好初始容量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx256m</span><br></pre></td></tr></table></figure>



<p>注意！-Xmx参数，JVM的堆内存限制，不等同于系统实际占用的最大资源，可能会超出。</p>
<p><img src="F:\迅雷下载\work\notebook\source_posts\OJ判题\Snipaste_2024-06-12_23-08-48.png" alt="Snipaste_2024-06-12_23-08-48"></p>
<p>如果需要更严格的内存限制，要在系统层面取限制，而不是JVM层面的限制。</p>
<p>如果是linux系统，可以使用cgroup来实现堆某个进程的CPU、内存等资源的分配。</p>
<h5 id="3-限制代码-黑白名单"><a href="#3-限制代码-黑白名单" class="headerlink" title="3.限制代码-黑白名单"></a>3.限制代码-黑白名单</h5><p>先定义一个黑名单，比如哪些操作是禁止的，可以是一个列表。</p>
<p>HuTool 字典树工具类：WordTree，可以用更少的存储空间存储更多的敏感词汇。实现更高效敏感词查找。</p>
<p>示例代码</p>
<p>1.初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static final WordTree WORD_TREE = new WordTree();</span><br><span class="line"></span><br><span class="line">//操作黑名单</span><br><span class="line">private static final List&lt;String&gt; blackList = Arrays.asList(&quot;File&quot;,&quot;exec&quot;);</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    //初始化字典树</span><br><span class="line">    //校验代码,查看代码文件里是否有进行黑名单里的操作</span><br><span class="line">    WORD_TREE.addWords(blackList);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.校验</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//校验代码中是否包含黑名单中的命令</span><br><span class="line">        FoundWord foundWord = WORD_TREE.matchWord(code);</span><br><span class="line">        if (foundWord != null)&#123;</span><br><span class="line">            System.out.println(&quot;包含禁止操作&quot;+foundWord.getFoundWord());</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>字典树原理：使用字典树能够<strong>节约空间</strong>，并且<strong>查找的时候会快一些</strong>（线性查找）</p>
<p><img src="F:\迅雷下载\work\notebook\source_posts\OJ判题\Snipaste_2024-06-13_00-29-18.png" alt="Snipaste_2024-06-13_00-29-18"></p>
<p>缺点：</p>
<p>1.你无法遍历所有的黑名单</p>
<p>2.不同的编程语言，对应的领域、关键词都不一样，限制人工成本很大</p>
<h5 id="4-限制用户的操作权限"><a href="#4-限制用户的操作权限" class="headerlink" title="4.限制用户的操作权限"></a>4.限制用户的操作权限</h5><p>限制用户对文件、内存、CPU、网络等资源的操作和访问。</p>
<p>Java安全管理器（Security Manager）是Java提供的保护JVM、Java安全的机制，可以实现更严格的资源和操作限制。</p>
<p>编写安全管理器，只需要继承</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 默认安全管理器</span><br><span class="line"> */</span><br><span class="line">public class DefaultSecurityManager extends SecurityManager &#123;</span><br><span class="line"></span><br><span class="line">    //检查所有的权限</span><br><span class="line">    @Override</span><br><span class="line">    public void checkPermission(Permission perm) &#123;</span><br><span class="line">        System.out.println(&quot;默认不做任何权限设置&quot;);</span><br><span class="line">        // super.checkPermission(perm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所有权限拒绝：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 禁用所有的安全管理器</span><br><span class="line"> */</span><br><span class="line">public class DenySecurityManager extends SecurityManager &#123;</span><br><span class="line"></span><br><span class="line">    //检查所有的权限</span><br><span class="line">    @Override</span><br><span class="line">    public void checkPermission(Permission perm) &#123;</span><br><span class="line">        throw new SecurityException(&quot;权限异常&quot;+perm.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>限制读权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//检测程序是否可读文件</span><br><span class="line">    @Override</span><br><span class="line">    public void checkRead(String file) &#123;</span><br><span class="line">        //放行对象</span><br><span class="line">        if (file.contains(&quot;hutool&quot;))&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new SecurityException(&quot;checkRead 权限异常&quot; + file);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>限制删除文件异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//检测程序是否允许删除文件</span><br><span class="line">    @Override</span><br><span class="line">    public void checkDelete(String file) &#123;</span><br><span class="line">        throw new SecurityException(&quot;checkDelete 权限异常&quot; + file);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>实际情况下，我们只需要限制子程序即可，没必要限制开发者自己写的程序。</p>
<p>在运行java程序时指定安全管理器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String rumCmd = String.format(&quot;java -Xmx256m -Dfile.encoding=UTF-8 -cp %s;%s -Djava.security.manager=MySecurityManger Main %s&quot;,userCodeParentPath,inputArgs);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>直接使用命令与上述安全管理器的区别</p>
<p>把安全器的类编译好后放到公共的目录中，不需要单独存放，减少占用空间，提高时间效率</p>
<p>过程：</p>
<p>1.编写安全管理器</p>
<p>2.编写安全管理器，去掉包名</p>
<p>3.在运行java程序时，指定安全管理器的路径，安全管理器的名称。</p>
<p>优点</p>
<p>权限控制很灵活，实现简单。</p>
<p>安全管理器缺点：</p>
<p>1.如果要做比较严格的权限控制，需要自己去判断哪些文件、包名需要允许读写，粒度太细了，难以精细化控制。</p>
<p>2.安全管理器本身也是Java代码，也有可能存在漏洞（还是程序上的限制，没到系统的层面）。</p>
<h5 id="5-运行环境隔离"><a href="#5-运行环境隔离" class="headerlink" title="5.运行环境隔离"></a>5.运行环境隔离</h5><blockquote>
<p>可以实现上述所有的问题</p>
</blockquote>
<p>系统层面上，把用户程序封装到沙箱里，和宿主机（电脑&#x2F;服务器）隔离开。</p>
<p>Docker容器技术能够实现（底层是用cgroup,namespace等方式实现的）。</p>
<h3 id="Docker容器技术"><a href="#Docker容器技术" class="headerlink" title="Docker容器技术"></a>Docker容器技术</h3><p>为什么要用Dicker容器技术？</p>
<p>为了提升系统的安全性，把某个程序（应用）和宿主机进行隔离，使得执行不会影响到系统本身。</p>
<p>Docker技术可以实现程序和宿主机的隔离。</p>
<h4 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h4><p>理解为对一系列应用程序，服务和环境的封装，从而把程序运行在一个隔离的，密闭的，隐私的空间内，对外提供服务。</p>
<blockquote>
<p>可以把容器理解为一共新的电脑（定制化的操作系统）</p>
</blockquote>
<h4 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h4><p>镜像：用来创建容器的安装包，可以理解为给电脑安装操作系统的系统镜像</p>
<p>容器：通过镜像来创建一套运行环境，一共容器可以运行多个程序，可以理解为一个电脑实例。</p>
<p>Dockerfile：制作镜像的文件，可以理解为制作镜像的一共清单</p>
<blockquote>
<p>类似Maven的pom.xml文件</p>
</blockquote>
<p>镜像仓库：存放镜像的仓库，用户可用从仓库下载现成的镜像，也可用把做好的镜像放到仓库中。</p>
<p>推荐使用docker官方的镜像仓库：<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h4 id="Docker实现原理"><a href="#Docker实现原理" class="headerlink" title="Docker实现原理"></a>Docker实现原理</h4><blockquote>
<p>Docker能实现哪些资源的隔离？</p>
</blockquote>
<ol>
<li>Docker运行在linux内核上</li>
<li>CGroups: 实现容器的网络资源管理,docker容器内部的网络互不影响</li>
<li>Network网络：实现容器的网络隔离，docker容器内部的网络互不影响</li>
<li>Namespace命名空间: 可以把进程隔离在不同的命名空间下，每个容器他都可以有命名空间，不同的命名空间下的进程互不影响。</li>
<li>Storage存储空间：容器内的文件相互隔离，也可以使用宿主机的文件</li>
</ol>
<p><img src="F:\迅雷下载\work\notebook\source_posts\OJ判题\Snipaste_2024-06-13_08-13-57.png" alt="Snipaste_2024-06-13_08-13-57"></p>
<blockquote>
<p>docker compose:是一种同时启动多个容器的集群操作工具（容器管理工具），一般情况下开发者仅做了解即可，实际使用docker compose时去百度配置文件</p>
</blockquote>
<h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><p>一般情况下，不建议在Windows系统上安装</p>
<p>Windows本身就自带了一个虚拟机叫WSL。但是不推荐。肯定不如一共专业的、隔离的虚拟机软件方便。</p>
<p>推荐使用虚拟机</p>
<h4 id="docker的常用操作"><a href="#docker的常用操作" class="headerlink" title="docker的常用操作"></a>docker的常用操作</h4><p>1.查看命令用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -help</span><br></pre></td></tr></table></figure>

<p>查看具体子命令的用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -help</span><br></pre></td></tr></table></figure>



<p>2.从远程仓库拉取镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hello-world</span><br></pre></td></tr></table></figure>



<p>3.根据镜像创建容器实例</p>
<p>启动实例，得到容器containerId:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create hello-wirld</span><br></pre></td></tr></table></figure>



<p>4.查看容器状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure>



<p>5.启动容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker start mystifying_shaimr</span><br></pre></td></tr></table></figure>



<p>6.查看日志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker mystifying_shaimr</span><br></pre></td></tr></table></figure>



<p>7.删除容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器名</span><br></pre></td></tr></table></figure>



<p>8.删除容器的镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像名</span><br></pre></td></tr></table></figure>



<p>9.推送镜像（类似git）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push image</span><br></pre></td></tr></table></figure>



<h4 id="java操作Docker"><a href="#java操作Docker" class="headerlink" title="java操作Docker"></a>java操作Docker</h4><p>使用Docker-Java: <a target="_blank" rel="noopener" href="https://github.com/docker-java/docker-java">https://github.com/docker-java/docker-java</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/docker-java/docker-java/blob/main/docs/getting_started.md">https://github.com/docker-java/docker-java/blob/main/docs/getting_started.md</a></p>
<p>1.安装依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.docker-java&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;docker-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.github.docker-java/docker-java-transport-httpclient5 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.docker-java&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;docker-java-transport-httpclient5&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>DockerClientConfig: 用于定义初始化DockerClient的配置(类比MySQL的连接、线程数配置)</p>
<p>DockerHttpClient：用于向Docker守护进程（操作Docker的接口）发送请求的客户端。低层封装（不推荐使用），你要自己构建请求参数。(简单理解成JDBC)</p>
<p>DockerClient（推荐）：才是真正和Docker守护进程交互的，最方便的SDK，高层封装。对DockerHttpClient再进行一层封装（理解成MyBatis），提供了现成的增删改查</p>
<h4 id="Linux-Docker远程开发"><a href="#Linux-Docker远程开发" class="headerlink" title="Linux Docker远程开发"></a>Linux Docker远程开发</h4><h5 id="方法一：将代码上传到ubuntu系统"><a href="#方法一：将代码上传到ubuntu系统" class="headerlink" title="方法一：将代码上传到ubuntu系统"></a>方法一：将代码上传到ubuntu系统</h5><p>1.输入ifconfig查看ip地址</p>
<p>2.安装ssh协议</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<p>3.查看是否安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep ssh</span><br></pre></td></tr></table></figure>

<p>4.安装jdk</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure>

<p>5.安装maven</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install maven</span><br></pre></td></tr></table></figure>

<p>6.在idea指定配置，配置ip，用户名，密码</p>
<p>7.配置映射文件</p>
<p>缺点：麻烦</p>
<h5 id="方法二：Linux-Docker远程开发"><a href="#方法二：Linux-Docker远程开发" class="headerlink" title="方法二：Linux Docker远程开发"></a>方法二：Linux Docker远程开发</h5><p>Files-&gt;RemoteDevelopment</p>
<p>使用IDEA Development先上传代码到Linux，然后使用JetBrains远程开发完全连接Linux实时开发。</p>
<p>报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java: Cannot run program &quot;/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java&quot; (in directory &quot;/home/zlz/.cache/JetBrains/RemoteDev-IU/_home_zlz_zoj-code-sandbox/compile-server&quot;): error=0, Failed to exec spawn helper: pid: 31705, exit value: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果无法启动程序，在File-Setting-Compiler的最下面添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djdk.lang.Process.launchMechanism=vfork</span><br></pre></td></tr></table></figure>



<p>拉取镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> //获取默认的DockerClient</span><br><span class="line">        DockerClient dockerClient = DockerClientBuilder.getInstance().build();</span><br><span class="line">//        PingCmd pingCmd = dockerClient.pingCmd();</span><br><span class="line">//        pingCmd.exec();</span><br><span class="line">        String image = &quot;nginx:latest&quot;;</span><br><span class="line">        PullImageCmd pullImageCmd = dockerClient.pullImageCmd(image);</span><br><span class="line">        PullImageResultCallback pullImageResultCallback = new PullImageResultCallback() &#123;</span><br><span class="line">            //每执行一步调用</span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(PullResponseItem item) &#123;</span><br><span class="line">                System.out.println(&quot;下载镜像：&quot;+item.getStatus());</span><br><span class="line">                super.onNext(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //异步执行</span><br><span class="line">        pullImageCmd.exec(pullImageResultCallback)</span><br><span class="line">                .awaitCompletion();</span><br><span class="line">        System.out.println(&quot;下载完成&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>给docker加权限</p>
<p>1.查找用户组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group | grep &#x27;docker&#x27;</span><br></pre></td></tr></table></figure>

<p>如果此时没有输出则需要添加：sudo group add docker</p>
<p>2.将当前用户添加到用户组中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gpasswd -a $&#123;USER&#125; docker</span><br></pre></td></tr></table></figure>

<p>注意：之后运行可能还会报错，把虚拟机重启即可。</p>
<p>创建容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建容器</span><br><span class="line">CreateContainerCmd containerCmd = dockerClient.createContainerCmd(image);</span><br><span class="line">CreateContainerResponse createContainerResponse = containerCmd</span><br><span class="line">        .withCmd(&quot;echo&quot;,&quot;Hello Docker&quot;)</span><br><span class="line">        .exec();</span><br><span class="line">System.out.println(createContainerResponse);</span><br></pre></td></tr></table></figure>



<p>查看容器状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查看容器状态</span><br><span class="line">ListContainersCmd listContainersCmd = dockerClient.listContainersCmd();</span><br><span class="line">List&lt;Container&gt; containerList = listContainersCmd.withShowAll(true).exec();</span><br><span class="line">for (Container container : containerList) &#123;</span><br><span class="line">    System.out.println(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>启动容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//启动容器</span><br><span class="line">dockerClient.startContainerCmd(containerId).exec();</span><br></pre></td></tr></table></figure>



<p>在linux查看启动的容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a 查看当前正在运行的容器</span><br><span class="line">docker logs edae101e6954 查看容器的日志</span><br></pre></td></tr></table></figure>



<p>查看容器日志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//查看日志(异步读取，因为日志文件非常大)</span><br><span class="line">        LogContainerResultCallback logContainerResultCallback = new LogContainerResultCallback()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Frame item) &#123;</span><br><span class="line">                System.out.println(&quot;日志:&quot;+new String(item.getPayload()));</span><br><span class="line">                super.onNext(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //阻塞等待日志输出</span><br><span class="line">        dockerClient.logContainerCmd(containerId)</span><br><span class="line">                .withStdErr(true)</span><br><span class="line">                .withStdOut(true)</span><br><span class="line">                .exec(logContainerResultCallback)</span><br><span class="line">                .awaitCompletion();</span><br></pre></td></tr></table></figure>



<p>删除容器和镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//删除容器(强制删除)，链式调用</span><br><span class="line">dockerClient.removeContainerCmd(containerId).withForce(true).exec();</span><br><span class="line"></span><br><span class="line">//删除镜像</span><br><span class="line">dockerClient.removeImageCmd(image).exec();</span><br></pre></td></tr></table></figure>



<h4 id="Docker实现代码沙箱"><a href="#Docker实现代码沙箱" class="headerlink" title="Docker实现代码沙箱"></a>Docker实现代码沙箱</h4><p>实现流程：docker负责运行java程序，并且得到结果</p>
<ol>
<li><p>把用户的代码保存为文件</p>
</li>
<li><p>编译代码。得到class文件</p>
</li>
<li><p>把编译好的文件上传到容器环境内</p>
</li>
<li><p>在容器中执行代码，得到输出结果</p>
</li>
<li><p>收集整理输出结果</p>
</li>
<li><p>文件清理</p>
</li>
<li><p>错误处理，提升程序健壮性</p>
</li>
</ol>
<blockquote>
<p>模板方法设计模式</p>
</blockquote>
<h5 id="3-创建容器，上传编译文件"><a href="#3-创建容器，上传编译文件" class="headerlink" title="3.创建容器，上传编译文件"></a>3.创建容器，上传编译文件</h5><p>自定义容器的两者方式：</p>
<p>1.在 已有镜像的基础上再扩充：比如拉取现成的Java环境（包含jdk），再把编译后的文件复制到容器里。适合新项目，跑通流程。</p>
<p>2.完全自定义容器：适合比较成熟的项目，比如封装多个语言的环境和实现。</p>
<p>思考：我们每个测试用例都单独创建一个容器，每个容器都只执行一次java命令？</p>
<p>浪费性能，所以要创建一共<strong>可交互</strong>的容器，能接收多次输入并且输出。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CreateContainerResponse createContainerResponse = containerCmd</span><br><span class="line">        .withHostConfig()</span><br><span class="line">        .withAttachStderr(true)</span><br><span class="line">        .withAttachStdin(true)</span><br><span class="line">        .withAttachStdout(true)</span><br><span class="line">        .withTty(true)</span><br><span class="line">        .exec();</span><br></pre></td></tr></table></figure>



<p>容器会有并发问题吗？</p>
<p>每个容器都是隔离的，只要捕获输出时，线程内部不错乱就行。</p>
<p>创建容器时，可用指定文件路径Volumn映射，作用是把本地的文件同步到容器中，可以让容器访问。</p>
<blockquote>
<p>也可以叫容器挂载目录</p>
</blockquote>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HostConfig hostConfig = new HostConfig();</span><br><span class="line">hostConfig.setBinds(new Bind(userCodePath,new Volume(&quot;/app&quot;)));</span><br></pre></td></tr></table></figure>



<p>容器设置内存和CPU数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hostConfig.withMemory(100*1000*1000L);</span><br><span class="line">hostConfig.withCpuCount(1L);</span><br></pre></td></tr></table></figure>



<h5 id="4-启动容器，执行代码"><a href="#4-启动容器，执行代码" class="headerlink" title="4.启动容器，执行代码"></a>4.启动容器，执行代码</h5><p>Docker执行容器（操作已启动容器）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec</span><br></pre></td></tr></table></figure>



<p>示例执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//docker exec tender_cray java -cp /app Main 1 3</span><br></pre></td></tr></table></figure>



<p>问题:无法拉取docker镜像</p>
<p>解决方法：科学上网</p>
<p>网址：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2296763">https://cloud.tencent.com/developer/article/2296763</a></p>
<p>注意，要把命令按照空格拆开，作为一共数组传递，否则可能会被识别为一个字符串，而不是多个参数。</p>
<p>创建命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] inputArgsArray = inputArgs.split(&quot; &quot;);</span><br><span class="line">        String[] cmdArray = ArrayUtil.append(new String[]&#123;&quot;java&quot;,&quot;-cp&quot;,&quot;Main&quot;,&quot;1&quot;,&quot;3&quot;&#125;,inputArgsArray) ;</span><br><span class="line">        ExecCreateCmdResponse execCreateCmdResponse = dockerClient.execCreateCmd(containerId)</span><br><span class="line">                .withCmd(cmdArray)</span><br><span class="line">                .withAttachStderr(true)</span><br><span class="line">                .withAttachStdin(true)</span><br><span class="line">                .withAttachStdout(true)</span><br><span class="line">                .exec();</span><br></pre></td></tr></table></figure>



<p>执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;创建执行命令&quot;+execCreateCmdResponse);</span><br><span class="line">            String execId = execCreateCmdResponse.getId();</span><br><span class="line">            ExecStartResultCallback execStartResultCallback = new ExecStartResultCallback() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onNext(Frame frame) &#123;</span><br><span class="line">                    StreamType streamType = frame.getStreamType();</span><br><span class="line">                    if (StreamType.STDERR.equals(streamType))&#123;</span><br><span class="line">                        System.out.println(&quot;输出错误结果&quot;+new String(frame.getPayload()));</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        System.out.println(&quot;输出结果&quot;+new String(frame.getPayload()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    super.onNext(frame);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            try &#123;</span><br><span class="line">                dockerClient.execStartCmd(execId)</span><br><span class="line">                        .exec(execStartResultCallback)</span><br><span class="line">                        .awaitCompletion();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(&quot;程序执行异常&quot;);</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>



<p>尽量复用之前的ExecuteMessage模式，在异步接口中填充正常和异常的信息</p>
<p>获取程序执行时间：和Java原生一样，使用StopWatch在执行前后统计时间</p>
<p>获取程序占用内存：</p>
<p>程序占用的内存每个时刻都在变化，所以你不可能获取到所有时间点的内存</p>
<p>我们要做的是，定义一共周期，定期地获取程序的内存。</p>
<p>监控内存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//获取占用的内存</span><br><span class="line">            StatsCmd statsCmd = dockerClient.statsCmd(containerId);</span><br><span class="line">            ResultCallback&lt;Statistics&gt; statisticsResultCallback = statsCmd.exec(new ResultCallback&lt;Statistics&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onNext(Statistics statistics) &#123;</span><br><span class="line">                    System.out.println(&quot;内存占用&quot; + statistics.getMemoryStats().getUsage());</span><br><span class="line">                    maxMemory[0] = Math.max(statistics.getMemoryStats().getUsage(), maxMemory[0]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onStart(Closeable closeable) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onError(Throwable throwable) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onComplete() &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void close() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>





<h4 id="Docker容器安全性"><a href="#Docker容器安全性" class="headerlink" title="Docker容器安全性"></a>Docker容器安全性</h4><p>1.超时控制</p>
<p>执行容器时，可以增加超时参数控制值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dockerClient.execStartCmd(execId)</span><br><span class="line">        .exec(execStartResultCallback)</span><br><span class="line">        .awaitCompletion(TIME_OUT, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<p>程序依旧会往下执行，如何区分超时和不超时？</p>
<p>解决方法：默认是超时，如果在规定时间内完成，再设置为不超时</p>
<p>可以定义一个标志，如果程序执行完成，把超时标志设置为false。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//默认设置为超时</span><br><span class="line">            final boolean[] timeout = &#123;true&#125;;</span><br><span class="line">            ExecStartResultCallback execStartResultCallback = new ExecStartResultCallback() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onComplete() &#123;</span><br><span class="line">                //如果执行完成则表示没超时</span><br><span class="line">                    timeout[0] = false;</span><br><span class="line">                    super.onComplete();</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>



<p>2.限制给用户程序分配资源</p>
<p>内存资源</p>
<p>通过HostConfig的withMemory等方法，设置容器的最大内存和资源限制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//创建容器</span><br><span class="line">CreateContainerCmd containerCmd = dockerClient.createContainerCmd(image);</span><br><span class="line">HostConfig hostConfig = new HostConfig();</span><br><span class="line">hostConfig.setBinds(new Bind(userCodePath,new Volume(&quot;/app&quot;)));</span><br><span class="line">hostConfig.withMemory(100*1000*</span><br><span class="line">1000L);</span><br><span class="line">//减少IO的频率，一定程度上增加稳定性</span><br><span class="line">hostConfig.withMemorySwap(1L);</span><br><span class="line">hostConfig.withCpuCount(1L);</span><br><span class="line">CreateContainerResponse createContainerResponse = containerCmd</span><br><span class="line">        .withHostConfig(hostConfig)</span><br><span class="line">        .withAttachStderr(true)</span><br><span class="line">        .withAttachStdin(true)</span><br><span class="line">        .withAttachStdout(true)</span><br><span class="line">        .withTty(true)</span><br><span class="line">        .exec();</span><br></pre></td></tr></table></figure>



<p>网络资源</p>
<p>创建容器时，设置网络配置为关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//网络拒绝</span><br><span class="line">.withNetworkDisabled(true)</span><br></pre></td></tr></table></figure>



<p>3.限制代码-黑名单</p>
<p>Docker容器已经做了系统层面的隔离，比较安全，但不能保证绝对安全。</p>
<p>​	a.结合Java安全管理器和其它策略去使用</p>
<p>​	b.限制用户不能向根目录写文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CreateContainerResponse createContainerResponse = containerCmd</span><br><span class="line">        .withHostConfig(hostConfig)</span><br><span class="line">        //限制用户不能向root根目录写文件</span><br><span class="line">        .withReadonlyRootfs(true)</span><br></pre></td></tr></table></figure>

<p>​	c.Linux自带的一些安全管理措施 seccdmp(Security Compute Mode)，Linux内核安全机制。</p>
<p>学习方法：</p>
<p>1.点进源码看</p>
<p>2.问AI相关实现</p>
<h4 id="模板方法模式优化代码沙箱"><a href="#模板方法模式优化代码沙箱" class="headerlink" title="模板方法模式优化代码沙箱"></a>模板方法模式优化代码沙箱</h4><p>1.定义一共模板方法抽象类</p>
<p>先复制具体实现类，把代码从完整的方法抽离成一个一个子流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 代码沙箱执行模板方法</span><br><span class="line">     * </span><br><span class="line">     * @param executeCodeRequest</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public ExecuteCodeResponse executeCode(ExecuteCodeRequest executeCodeRequest) &#123;</span><br><span class="line">//        System.setSecurityManager(new DenySecurityManager());</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; inputList = executeCodeRequest.getInputList();</span><br><span class="line">        String code = executeCodeRequest.getCode();</span><br><span class="line">        String language = executeCodeRequest.getLanguage();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //1.把用户的代码保存为文件</span><br><span class="line">        File userCodeFIle = saveCodeFile(code);</span><br><span class="line"></span><br><span class="line">        //2.编译代码。得到class文件</span><br><span class="line">        ExecuteMessage compileFileExecuteMessage = compileFile(userCodeFIle);</span><br><span class="line">        System.out.println(compileFileExecuteMessage);</span><br><span class="line"></span><br><span class="line">        //3.创建容器，把容器放到文件内</span><br><span class="line">        List&lt;ExecuteMessage&gt; executeMessages = runFile(userCodeFIle, inputList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //4.收集整理输出结果</span><br><span class="line">        ExecuteCodeResponse outputResponse = getOutputResponse(executeMessages);</span><br><span class="line"></span><br><span class="line">        //5.文件清理</span><br><span class="line">        boolean b = deleteFile(userCodeFIle);</span><br><span class="line">        if(!b)&#123;</span><br><span class="line">            log.error(&quot;deleteFile Error,userCodeFilePath = &#123;&#125;&quot;,userCodeFIle.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return outputResponse;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>2.定义子类的实现</p>
<p>Java原生代码实现，直接复用模板方法定义好的模板实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Java 原始代码沙箱实现（直接复用模板方法）</span><br><span class="line"> */</span><br><span class="line">public class JavaNativeCodeSandbox extends JavaCodeSandboxTemplate &#123;</span><br><span class="line"></span><br><span class="line">    //可以自定义流程</span><br><span class="line">//    @Override</span><br><span class="line">//    public File saveCodeFile(String code) &#123;</span><br><span class="line">//        File file = super.saveCodeFile(code);</span><br><span class="line">//        System.out.println(&quot;监控&quot;);</span><br><span class="line">//        return file;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ExecuteCodeResponse executeCode(ExecuteCodeRequest executeCodeRequest) &#123;</span><br><span class="line">        return super.executeCode(executeCodeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Docker代码沙箱实现，需要自行重写RunFile:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 3.创建容器，把容器放到文件内（自定义）</span><br><span class="line"> * @param userCodeFile</span><br><span class="line"> * @param inputList</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public List&lt;ExecuteMessage&gt; runFile(File userCodeFile, List&lt;String&gt; inputList) &#123;</span><br><span class="line">    String userCodeParentFile = userCodeFile.getParentFile().getAbsolutePath();</span><br><span class="line">    //获取默认的DockerClient</span><br><span class="line">    DockerClient dockerClient = DockerClientBuilder.getInstance().build();</span><br><span class="line">    //拉取镜像</span><br><span class="line">    String image = &quot;openjdk:8-alpine&quot;;</span><br><span class="line">    PullImageCmd pullImageCmd = dockerClient.pullImageCmd(image);</span><br><span class="line">    //如果是第一次执行则拉取镜像</span><br><span class="line">    if (FIRST_INIT)&#123;</span><br><span class="line">        PullImageResultCallback pullImageResultCallback = new PullImageResultCallback() &#123;</span><br><span class="line">            //每执行一步调用</span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(PullResponseItem item) &#123;</span><br><span class="line">                System.out.println(&quot;下载镜像：&quot;+item.getStatus());</span><br><span class="line">                super.onNext(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //异步执行</span><br><span class="line">        try &#123;</span><br><span class="line">            pullImageCmd.exec(pullImageResultCallback)</span><br><span class="line">                    .awaitCompletion();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(&quot;拉取镜像异常&quot;);</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;下载完成&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建容器</span><br><span class="line">    CreateContainerCmd containerCmd = dockerClient.createContainerCmd(image);</span><br><span class="line">    HostConfig hostConfig = new HostConfig();</span><br><span class="line">    hostConfig.withMemory(100*1000*1000L);</span><br><span class="line">    //减少IO的频率，一定程度上增加稳定性</span><br><span class="line">    hostConfig.withMemorySwap(1L);</span><br><span class="line">    hostConfig.withCpuCount(1L);</span><br><span class="line">    //todo 安全管理配置字符串</span><br><span class="line">    hostConfig.withSecurityOpts(Arrays.asList(&quot;seccomp=安全管理配置字符串&quot;));</span><br><span class="line">    hostConfig.setBinds(new Bind(userCodeParentFile,new Volume(&quot;/app&quot;)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CreateContainerResponse createContainerResponse = containerCmd</span><br><span class="line">            .withHostConfig(hostConfig)</span><br><span class="line">            //限制用户不能向root根目录写文件</span><br><span class="line">            .withReadonlyRootfs(true)</span><br><span class="line">            //网络拒绝</span><br><span class="line">            .withNetworkDisabled(true)</span><br><span class="line">            .withAttachStderr(true)</span><br><span class="line">            .withAttachStdin(true)</span><br><span class="line">            .withAttachStdout(true)</span><br><span class="line">            .withTty(true)</span><br><span class="line">            .exec();</span><br><span class="line">    System.out.println(createContainerResponse);</span><br><span class="line">    String containerId = createContainerResponse.getId();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //启动容器</span><br><span class="line">    dockerClient.startContainerCmd(containerId).exec();</span><br><span class="line"></span><br><span class="line">    //docker exec tender_cray java -cp /app Main 1 3</span><br><span class="line">    //执行命令并返回结果</span><br><span class="line">    List&lt;ExecuteMessage&gt; executeMessagesList = new ArrayList&lt;&gt;();</span><br><span class="line">    for (String inputArgs : inputList) &#123;</span><br><span class="line">        StopWatch stopWatch = new StopWatch();</span><br><span class="line">        String[] inputArgsArray = inputArgs.split(&quot; &quot;);</span><br><span class="line">        String[] cmdArray = ArrayUtil.append(new String[]&#123;&quot;java&quot;,&quot;-cp&quot;,&quot;Main&quot;,&quot;1&quot;,&quot;3&quot;&#125;,inputArgsArray) ;</span><br><span class="line">        ExecCreateCmdResponse execCreateCmdResponse = dockerClient.execCreateCmd(containerId)</span><br><span class="line">                .withCmd(cmdArray)</span><br><span class="line">                .withAttachStderr(true)</span><br><span class="line">                .withAttachStdin(true)</span><br><span class="line">                .withAttachStdout(true)</span><br><span class="line">                .exec();</span><br><span class="line">        System.out.println(&quot;创建执行命令&quot;+execCreateCmdResponse);</span><br><span class="line">        ExecuteMessage executeMessage = new ExecuteMessage();</span><br><span class="line">        final String[] message = &#123;null&#125;;</span><br><span class="line">        final String[] errorMessage = &#123;null&#125;;</span><br><span class="line">        long time = 0L;</span><br><span class="line">        //默认设置为超时</span><br><span class="line">        final boolean[] timeout = &#123;true&#125;;</span><br><span class="line">        String execId = execCreateCmdResponse.getId();</span><br><span class="line">        ExecStartResultCallback execStartResultCallback = new ExecStartResultCallback() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                //如果执行完成则表示没超时</span><br><span class="line">                timeout[0] = false;</span><br><span class="line">                super.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Frame frame) &#123;</span><br><span class="line">                StreamType streamType = frame.getStreamType();</span><br><span class="line">                if (StreamType.STDERR.equals(streamType))&#123;</span><br><span class="line">                    errorMessage[0] = new String(frame.getPayload());</span><br><span class="line">                    System.out.println(&quot;输出错误结果&quot;+ errorMessage[0]);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    message[0] = new String(frame.getPayload());</span><br><span class="line">                    System.out.println(&quot;输出结果&quot;+ message[0]);</span><br><span class="line">                &#125;</span><br><span class="line">                super.onNext(frame);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        final long[] maxMemory = &#123;0L&#125;;</span><br><span class="line"></span><br><span class="line">        //获取占用的内存</span><br><span class="line">        StatsCmd statsCmd = dockerClient.statsCmd(containerId);</span><br><span class="line">        ResultCallback&lt;Statistics&gt; statisticsResultCallback = statsCmd.exec(new ResultCallback&lt;Statistics&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Statistics statistics) &#123;</span><br><span class="line">                System.out.println(&quot;内存占用&quot; + statistics.getMemoryStats().getUsage());</span><br><span class="line">                maxMemory[0] = Math.max(statistics.getMemoryStats().getUsage(), maxMemory[0]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onStart(Closeable closeable) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable throwable) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void close() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        statsCmd.exec(statisticsResultCallback);</span><br><span class="line">        try &#123;</span><br><span class="line">            stopWatch.start();</span><br><span class="line">            dockerClient.execStartCmd(execId)</span><br><span class="line">                    .exec(execStartResultCallback)</span><br><span class="line">                    .awaitCompletion(TIME_OUT, TimeUnit.MILLISECONDS);</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            time = stopWatch.getTotalTimeMillis();</span><br><span class="line">            statsCmd.close();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(&quot;程序执行异常&quot;);</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        executeMessage.setMessage(message[0]);</span><br><span class="line">        executeMessage.setErrorMessage(errorMessage[0]);</span><br><span class="line">        executeMessage.setTime(time);</span><br><span class="line">        executeMessage.setMemory(maxMemory[0]);</span><br><span class="line">        executeMessagesList.add(executeMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    return executeMessagesList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="代码沙箱开放API"><a href="#代码沙箱开放API" class="headerlink" title="代码沙箱开放API"></a>代码沙箱开放API</h4><p>直接在controller暴露CodeSandbox定义的接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/execute&quot;)</span><br><span class="line">ExecuteCodeResponse execute(@RequestBody ExecuteCodeRequest executeCodeRequest)&#123;</span><br><span class="line">    if (executeCodeRequest == null)&#123;</span><br><span class="line">        throw new RuntimeException(&quot;请求参数为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return javaNativeCodeSandbox.executeCode(executeCodeRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>问题：调用别人的开放API调用失败，应该返回什么错误码?</p>
<p>本质上是内部系统出问题，使用500开头</p>
<h5 id="调用安全性"><a href="#调用安全性" class="headerlink" title="调用安全性"></a>调用安全性</h5><p>如果将服务不做任何权限校验，直接放到公网，是不安全的。</p>
<p>1.调用方与服务提供方之间约定一个字符串<strong>（最好加密）</strong></p>
<p>调用方</p>
<p>改造请求头</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//基本认证</span><br><span class="line">String authHeader = request.getHeader(AUTH_REQUEST_HEADER);</span><br><span class="line">if (!AUTH_REQUEST_SECRET.equals(authHeader))&#123;</span><br><span class="line">    response.setStatus(403);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>服务方</p>
<p>​	1.先定义约定的字符串</p>
<p>​	2.改造请求，从请求头中获取认证信息，并校验。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String responseStr = HttpUtil.createPost(url).header(AUTH_REQUEST_HEADER,AUTH_REQUEST_SECRET).body(json).execute().body();</span><br><span class="line">       if (StringUtils.isBlank(responseStr))&#123;</span><br><span class="line">           throw new BusinessException(ErrorCode.API_REQUEST_ERROR,&quot;executeCode remoteSanbox error, message = &quot;+responseStr);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>优点：实现最简单，比较适合内部系统之间的相互调用（相对可信的环境内部调用）</p>
<p>缺点：不够灵活，如果key泄露或变更，需要重启代码。</p>
<p>2.API签名认证的方式，给允许调用的人员分配accessKey、secretKey,然后校验两组key 是否匹配。</p>
<h4 id="跑通项目流程"><a href="#跑通项目流程" class="headerlink" title="跑通项目流程"></a>跑通项目流程</h4><p>准备微服务：将题目提交controller合并到题目controller</p>
<h3 id="单体项目改造成微服务"><a href="#单体项目改造成微服务" class="headerlink" title="单体项目改造成微服务"></a>单体项目改造成微服务</h3><h4 id="什么是微服务（思想）？"><a href="#什么是微服务（思想）？" class="headerlink" title="什么是微服务（思想）？"></a>什么是微服务（思想）？</h4><p>服务：提供某类功能的代码</p>
<p>微服务：专注于提供某类特定功能的代码，而不是把所有的代码全部放到同一个项目里。会把整个大的项目按照一定的功能，逻辑进行拆分，拆分为多个子模块，每个子模块独立允许，独立负责一类功能，子模块之间相互调用，互不影响。</p>
<p>一个公司：一个人干活，这个人icu了，公司直接倒闭</p>
<p>一个公司有多个不同类别的岗位，多个人干活，一个组挂了还有其它组可以正常工作，不会说公司直接倒闭，各组之间可能需要交互，来完成大的项目。</p>
<p>微服务的几个重要的因素：服务管理、服务调用、服务拆分。</p>
<h4 id="微服务实现技术？"><a href="#微服务实现技术？" class="headerlink" title="微服务实现技术？"></a>微服务实现技术？</h4><p>Spring Cloud</p>
<p><strong>Spring Cloud Alibaba(本项目采用)</strong></p>
<p>Dubbo(DubboX)</p>
<p>RPC(GRPC,TRPC)</p>
<p>本质上是通过HTTP、或者其它的网络协议进行通讯来实现的。</p>
<p>分布式：把一个项目部署到多个机器，把一个场景从单机到多机。</p>
<p>微服务：把一个大的项目进行拆分</p>
<h4 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h4><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba">https://github.com/alibaba/spring-cloud-alibaba</a></p>
<p>官网：<a target="_blank" rel="noopener" href="https://sca.aliyun.com/">https://sca.aliyun.com/</a></p>
<p>本质：在Spring Cloud的基础上，进行了增强。补充了一些额外的能力，根据阿里多年的业务沉淀做了一些定制化的开发。</p>
<p><strong>注意：要使用正确的Spring Cloud版本</strong></p>
<p><a target="_blank" rel="noopener" href="https://sca.aliyun.com/docs/2021/overview/version-explain/?spm=5176.29160081.0.0.74801a1580pUYC">https://sca.aliyun.com/docs/2021/overview/version-explain/?spm=5176.29160081.0.0.74801a1580pUYC</a></p>
<p>相关技术栈</p>
<ol>
<li><p>Spring Cloud Gateway：网关</p>
</li>
<li><p>Nacos：服务注册和配置中心,集中存管项目中所有服务的信息，便于服务之间找到彼此；同时，还支持集中存储整个项目中的配置。</p>
</li>
<li><p>Sentinel：熔断限流</p>
</li>
<li><p>Seata：分布式事务</p>
</li>
<li><p>RocketMQ：消息队列，削峰填谷</p>
</li>
<li><p>Docker：使用Docker进行容器化部署</p>
</li>
<li><p>Kubernetes：使用k8s进行容器化部署</p>
</li>
</ol>
<blockquote>
<p>扩展：discovery: <a target="_blank" rel="noopener" href="https://github.com/Nepxion/Discovery">https://github.com/Nepxion/Discovery</a> </p>
<p>对Spring Cloud进一步增强</p>
</blockquote>
<h4 id="改造前思考"><a href="#改造前思考" class="headerlink" title="改造前思考"></a>改造前思考</h4><p>从业务需求出发，思考单机和分布式的区别。</p>
<p>1.用户登录功能：需要改造为分布式登录</p>
<p>2.其它内容：</p>
<p>​	有没有用到单机锁？改造为分布式锁</p>
<p>​	有没有用到本地缓存？改造为分布式缓存（Redis）</p>
<p>​	需不需要用到分布式事务？比如操作多个库</p>
<h5 id="改造分布式登录"><a href="#改造分布式登录" class="headerlink" title="改造分布式登录"></a>改造分布式登录</h5><p>1.配置文件增加redis配置</p>
<p>2.引入redis依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- redis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>3.主类取消Redis自动配置的移除</p>
<p>4.在配置文件中修改session的存储方式为redis</p>
<p>5.使用redis-cli或者redis管理工具，查看是否有登录后的信息</p>
<h5 id="微服务的划分"><a href="#微服务的划分" class="headerlink" title="微服务的划分"></a>微服务的划分</h5><p>从业务出发，想一下哪些功能&#x2F;职责是一起的？</p>
<blockquote>
<p>公司老板给员工分工</p>
</blockquote>
<p>依赖服务：</p>
<ol>
<li>注册中心: Nacos</li>
<li>微服务网关（如果不开，前端需要调不同的接口）：Gateway汇总所有的接口,统一接收前端处理的请求。</li>
</ol>
<p>​	</p>
<p>公共模块：</p>
<p>​	common公共模块（zoj-backend-common）:全局异常处理器、请求响应封装类，公用的工具类等。</p>
<p>​	model模型模块（zoj-backend-model）：很多服务公用的实体类</p>
<p>​	公用接口模块（zoj-backend-service-client）:只存放接口，不存放实现（多个服务之间共享）。</p>
<p>业务功能和部署结构</p>
<ol>
<li>用户服务（zoj-backend-user-service：8102端口）<ol>
<li>注册</li>
<li>登录</li>
<li>用户管理</li>
</ol>
</li>
<li>题目服务（zoj-backend-question-service: 8103端口）<ol>
<li>创建题目（管理员）</li>
<li>删除题目（管理员）</li>
<li>修改题目（管理员）</li>
<li>搜索题目（用户）</li>
<li>在线做题（题目详情页）</li>
<li><strong>题目提交</strong></li>
</ol>
</li>
<li>判题服务（zoj-backend-judge-service，较重的操作，8104端口）<ol>
<li>执行判题逻辑</li>
<li>错误处理（内存溢出、安全性、超时）</li>
<li><strong>自主实现代码沙箱（安全沙箱）</strong></li>
<li>开放接口（提供一个独立的新服务）</li>
</ol>
</li>
</ol>
<blockquote>
<p>代码沙箱服务本身就是独立的，不用纳入Spring Cloud的管理</p>
</blockquote>
<h5 id="路由划分"><a href="#路由划分" class="headerlink" title="路由划分"></a>路由划分</h5><p>用SpringBoot的context-path统一修改各项目的接口前缀，比如：</p>
<p>用户服务：</p>
<pre><code> 1. /api/user
 2. /api/user/inner(原因：微服务需要相互协作，但是相互协作需要的接口不是全部都要暴露在外的，不是都要给用户请求)
</code></pre>
<p>​	比如：员工之间需要传输私密信息，而这些信息是不能暴露在外面的。</p>
<p>​	内部调用，网关层面要做限制。</p>
<p>题目服务：</p>
<pre><code> 1. /api/question（也包括题目提交信息）
 2. /api/question/inner(原因：微服务需要相互协作，但是相互协作需要的接口不是全部都要暴露在外的，不是都要给用户请求)
</code></pre>
<p>​	比如：员工之间需要传输私密信息，而这些信息是不能暴露在外面的。</p>
<p>​	内部调用，网关层面要做限制。</p>
<p>判题服务：</p>
<pre><code> 1. /api/judge
 2. /api/judge/inner(原因：微服务需要相互协作，但是相互协作需要的接口不是全部都要暴露在外的，不是都要给用户请求)
</code></pre>
<p>​	比如：员工之间需要传输私密信息，而这些信息是不能暴露在外面的。</p>
<p>​	内部调用，网关层面要做限制。</p>
<h5 id="Nacos注册中心启动"><a href="#Nacos注册中心启动" class="headerlink" title="Nacos注册中心启动"></a>Nacos注册中心启动</h5><blockquote>
<p>要在SpringCloud Alibaba文档中找对应的版本</p>
</blockquote>
<p>一定要选择2.2.0版本！！！</p>
<h4 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h4><p>Spring Cloud有相当多的依赖，参差不齐，不建议随意找一套配置，或者自己写。</p>
<p>建议用脚手架创建项目：<a target="_blank" rel="noopener" href="https://start.aliyun.com/">https://start.aliyun.com/</a></p>
<p>注意：不需要一开始就引入所有的需要的包，比较定制化的内容，可以单独引入</p>
<p>给项目引入全局依赖配置。</p>
<p>创建完初始项目后，补充Spring Cloud 依赖:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2021.0.5&lt;/version&gt;</span><br><span class="line">    &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">    &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>OpenFegin:服务之间相互调用的组件。</p>
<p>1.依次使用 new modules和spring boot Initializer创建各模块</p>
<p>2.需要给各模块之间绑定子父依赖关系</p>
<p>​	父模块定义modules,子模块引入parent语法，可以通过继承父模块配置，统一项目的定义和版本号。</p>
<h4 id="同步代码和依赖"><a href="#同步代码和依赖" class="headerlink" title="同步代码和依赖"></a>同步代码和依赖</h4><p>移动backend代码，把公共模块移动到common下，删除AOP</p>
<p>在外层的pom.xml中引入公共类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.8.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-collections4 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>2.model模块</p>
<p>引入model包，注意引入代码沙箱的model包</p>
<p>3.公用接口模块</p>
<p>把所有的service引入。</p>
<p>需要指定openfegin客户端调用工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>4.具体服务的实现</p>
<p>给所有业务服务引入公共依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.zlz&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zoj-backend-common&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.zlz&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zoj-backend-model&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>注意：要使用全局异常处理器（Bean）,但是又不是在同一个模块，默认是扫描不到这个类的，所以异常处理器就不会生效，苏便宜需要在主类上指定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan(&quot;com.zlz&quot;)</span><br></pre></td></tr></table></figure>

<p>删除所有无关的代码</p>
<p>修改application.yml的配置，比如名称，端口号</p>
<p>主类引入注解</p>
<h4 id="服务内部调用"><a href="#服务内部调用" class="headerlink" title="服务内部调用"></a>服务内部调用</h4><p>问题：模块拆分后无法找到对应的模块？找不到对应的Bean</p>
<p>涉及服务通讯。</p>
<p>可以使用Open Fegin组件实现跨服务的远程调用</p>
<p>Open Fegin: Http调用客户端，提供了更方便的方式来让你远程调用其它服务，不用关心服务的调用地址。</p>
<p>Nacos注册中心获取服务调用地址。</p>
<h5 id="1-梳理服务的调用关系，确定哪些服务（接口）需要给内部调用"><a href="#1-梳理服务的调用关系，确定哪些服务（接口）需要给内部调用" class="headerlink" title="1.梳理服务的调用关系，确定哪些服务（接口）需要给内部调用"></a>1.梳理服务的调用关系，确定哪些服务（接口）需要给内部调用</h5><p>​	查看代码</p>
<p>用户服务：没有其它的依赖</p>
<p>题目服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">userService.getLoginUser(request);</span><br><span class="line">userService.isAdmin(request);</span><br><span class="line">userService.getById(userId);</span><br><span class="line">userService.getUserVO(user);</span><br><span class="line">userService.listByIds(userIdSet).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(User::getId));</span><br><span class="line">judgeService.doJudge(questionSubmitId);</span><br></pre></td></tr></table></figure>

<p>判题服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">questionService.getById(questionId);</span><br><span class="line">questionSubmitService.getById(questionSubmitId);</span><br><span class="line">questionSubmitService.updateById(questionSubmitUpdate)</span><br></pre></td></tr></table></figure>



<h5 id="2-要确认提供哪些服务。"><a href="#2-要确认提供哪些服务。" class="headerlink" title="2.要确认提供哪些服务。"></a>2.要确认提供哪些服务。</h5><p>用户服务：没有其它的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">userService.getLoginUser(request);</span><br><span class="line">userService.isAdmin(request);</span><br><span class="line">userService.getById(userId);</span><br><span class="line">userService.getUserVO(user);</span><br><span class="line">userService.listByIds(userIdSet).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(User::getId));</span><br></pre></td></tr></table></figure>

<p>题目服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">questionService.getById(questionId);</span><br><span class="line">questionSubmitService.getById(questionSubmitId);</span><br><span class="line">questionSubmitService.updateById(questionSubmitUpdate);</span><br></pre></td></tr></table></figure>

<p>判题服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">judgeService.doJudge(questionSubmitId);</span><br></pre></td></tr></table></figure>



<h5 id="3-在serviceClient编写工具类代码"><a href="#3-在serviceClient编写工具类代码" class="headerlink" title="3.在serviceClient编写工具类代码"></a>3.在serviceClient编写工具类代码</h5><p>修改接口名称为 服务名+FeignClient</p>
<p>如果是简单的接口，为了节省性能，可以直接实现，不需要使用Fegin调用了，把改类当成工具类使用即可。</p>
<p>不涉及数据库的操作，就是简单的java语法判断。</p>
<p>例如：获取当前登录用户（直接从session中得到，不查数据库，会浪费很多性能）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取当前登录用户</span><br><span class="line"> *</span><br><span class="line"> * @param request</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">default User getLoginUser(HttpServletRequest request)&#123;</span><br><span class="line">    // 先判断是否已登录</span><br><span class="line">    Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);</span><br><span class="line">    User currentUser = (User) userObj;</span><br><span class="line">    if (currentUser == null || currentUser.getId() == null) &#123;</span><br><span class="line">        throw new BusinessException(ErrorCode.NOT_LOGIN_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    return currentUser;</span><br><span class="line">&#125;</span><br><span class="line">    /**</span><br><span class="line"> * 是否为管理员</span><br><span class="line"> *</span><br><span class="line"> * @param user</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">default boolean isAdmin(User user)&#123;</span><br><span class="line">    return user != null &amp;&amp; UserRoleEnum.ADMIN.getValue().equals(user.getUserRole());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取脱敏的用户信息</span><br><span class="line"> *</span><br><span class="line"> * @param user</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">default UserVO getUserVO(User user) &#123;</span><br><span class="line">    if (user == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    UserVO userVO = new UserVO();</span><br><span class="line">    BeanUtils.copyProperties(user, userVO);</span><br><span class="line">    return userVO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这里不能使用ThreadLocal，因为它使用的是本地的服务</p>
<h5 id="4-编写client接口注解"><a href="#4-编写client接口注解" class="headerlink" title="4.编写client接口注解"></a>4.编写client接口注解</h5><p>开启openfegin的支持，把接口暴露出去（服务注册到注册中心上），作为API给其它服务调用（其它服务从注册中心寻找）。</p>
<p>​	1.需要在对外暴露的接口上打上注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name = &quot;zoj-backend-user-service&quot;,path = &quot;/api/user&quot;)</span><br></pre></td></tr></table></figure>

<p>其中name属性和application.yml定义的name属性对应</p>
<p>​	</p>
<p>​	2.修改每个服务提供者的context-path全局请求路径以及修改controller接口上的路径，不然出现路径错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/&quot;)</span><br></pre></td></tr></table></figure>



<p>服务提供者：理解为接口的实现类，实际提供服务的模块（服务注册到注册中心上）。</p>
<p>服务消费者：理解为接口的调用方，需要去找到服务提供者，然后调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  address: 0.0.0.0</span><br><span class="line">  port: 8103</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /api/question</span><br></pre></td></tr></table></figure>

<p>​	3.对每个服务的方法还要编写具体的请求地址（跟单体项目中controller的请求地址一样），参数也要打上注解，不然参数是无法传递的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据id获取用户</span><br><span class="line"> *</span><br><span class="line"> * @param userId</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@GetMapping(&quot;/get/id&quot;)</span><br><span class="line">User getById(@RequestParam(&quot;userId&quot;) long userId);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>(1).<strong>区分Get、Post</strong></p>
<p>(2).<strong>Json使用@RequestBody，参数使用@RequestParam</strong></p>
<p>路径不需要参数吗？写法：&#x2F;get&#x2F;${id}</p>
<p>可以不用，取决于对接口的定义。</p>
<p><strong>不需要远程调用的方法不用打注解，用关键词default修饰的方法</strong></p>
<p>对于用户服务，有一些不利于远程调用的参数传递或者实现起来非常简单（工具类），可以直接使用默认类，无需远程调用，节约性能。</p>
<p>应用场景：公共类</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取当前登录用户</span><br><span class="line"> *</span><br><span class="line"> * @param request</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">default User getLoginUser(HttpServletRequest request)&#123;</span><br><span class="line">    // 先判断是否已登录</span><br><span class="line">    Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);</span><br><span class="line">    User currentUser = (User) userObj;</span><br><span class="line">    if (currentUser == null || currentUser.getId() == null) &#123;</span><br><span class="line">        throw new BusinessException(ErrorCode.NOT_LOGIN_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    return currentUser;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 题目表服务</span><br><span class="line"> *</span><br><span class="line"> * @author &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="line"> * @from &lt;a href=&quot;https://www.code-nav.cn&quot;&gt;编程导航学习圈&lt;/a&gt;</span><br><span class="line"> */</span><br><span class="line">@FeignClient(name = &quot;zoj-backend-question-service&quot;, path = &quot;/api/question&quot;)</span><br><span class="line">public interface QuestionFeignClient &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/get/id&quot;)</span><br><span class="line">    Question getQuestionById(@RequestParam(&quot;questionId&quot;) long questionId);</span><br><span class="line">    </span><br><span class="line">    @GetMapping(&quot;/question_submit/get/id&quot;)</span><br><span class="line">    Question getQuestionSubmitById(@RequestParam(&quot;questionSubmitId&quot;) long questionSubmitId);</span><br><span class="line">    </span><br><span class="line">    @GetMapping(&quot;/question_submit/update&quot;)</span><br><span class="line">    boolean updateQuestionSubmitById(@RequestBody QuestionSubmit questionSubmit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>注意：这里不需要对着controller写，因为这里只是对着服务实现类（调用方）调用的情况（参数和返回值）进行编写，这些服务还没有在controller中实现。</p>
<p>规范：在编写文档的时候就要把这些调用服务的接口路径定义好。</p>
<p>(3)<strong>.FeginClient定义的请求路径一定要和服务器提供方实际的请求路径保持一致</strong>。</p>
<p>内部服务要打上&#x2F;inner</p>
<p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判题相关代码：为微服务做准备</span><br><span class="line"> * 判题服务</span><br><span class="line"> */</span><br><span class="line">@FeignClient(name = &quot;zoj-backend-judge-service&quot;, path = &quot;/api/judge/inner&quot;)</span><br><span class="line">public interface JudgeFeignClient &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判题</span><br><span class="line">     *</span><br><span class="line">     * @param questionSubmitId</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/do&quot;)</span><br><span class="line">    QuestionSubmit doJudge(@RequestParam(&quot;questionSubmitId&quot;) long questionSubmitId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-重构项目代码"><a href="#5-重构项目代码" class="headerlink" title="5.重构项目代码"></a>5.重构项目代码</h5><p>​	a.修改有依赖关系的服务代码</p>
<p>​	注意：内部调用的service不需要改，只改外部调用的服务的服务名，不改服务内部继承的实现接口</p>
<h5 id="6-编写feignClient服务的实现类"><a href="#6-编写feignClient服务的实现类" class="headerlink" title="6.编写feignClient服务的实现类"></a>6.编写feignClient服务的实现类</h5><p>编写内部实现类，供内部访问，注意要和定义的客户端保持一致</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.zlz.zojbackenduserservice.controller.inner;</span><br><span class="line"></span><br><span class="line">import com.zlz.zojbackendmodel.entity.User;</span><br><span class="line">import com.zlz.zojbackendserviceclient.service.UserFeignClient;</span><br><span class="line">import com.zlz.zojbackenduserservice.service.UserService;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 内部服务实现类</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/inner&quot;)</span><br><span class="line">public class InnerUserController implements UserFeignClient &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private UserService userService;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 根据id获取用户</span><br><span class="line">     *</span><br><span class="line">     * @param userId</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    @GetMapping(&quot;/get/id&quot;)</span><br><span class="line">    public User getById(@RequestParam(&quot;userId&quot;) long userId)&#123;</span><br><span class="line">        return userService.getById(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id获取用户列表</span><br><span class="line">     *</span><br><span class="line">     * @param idList mybatisplus默认提供的类</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    @GetMapping(&quot;/get/ids&quot;)</span><br><span class="line">    public List&lt;User&gt; listByIds(@RequestParam(&quot;idList&quot;) Collection&lt;Long&gt; idList)&#123;</span><br><span class="line">        return userService.listByIds(idList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本质上：就是把提供的服务接口进行统一管理，通过重写接口的方式对服务进行拆分。</p>
<p>注意：重写的接口的地址要于接口定义的地址保持一致</p>
<h5 id="7-开启注册中心"><a href="#7-开启注册中心" class="headerlink" title="7.开启注册中心"></a>7.开启注册中心</h5><p>启动nacos</p>
<p>windows</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure>

<p>Linux</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh -m standalone</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	1.引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>​	2.编写配置（必须是服务）</p>
<p>网关、三个服务、ServiceClient</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      serverAddr: 127.0.0.1:8848</span><br><span class="line">  config:</span><br><span class="line">    import:</span><br><span class="line">      - nacos:nacos-config-example.properties?refreshEnabled=true</span><br></pre></td></tr></table></figure>

<p>​	3.给业务服务项目启动类打上注解，开启服务发现，找到对应的客户端Bean的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//开启服务发现</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">//扫描服务接口（指定客户端的包路径）</span><br><span class="line">@EnableFeignClients(&quot;com.zlz.zojbackendserviceclient.service&quot;)</span><br></pre></td></tr></table></figure>

<p>服务启动时，去nacos上注册服务，然后去nacos上找服务。项目启动时去目标包路径上去找，如果找到目标FeginClient就把Bean注册到服务内部,当你使用FeginClient，就能找到已有的实现类，启动服务时就不会出现却Bean</p>
<p>注意：这里网关不需要打上调用服务注解，因为网关不涉及服务的内部的调用所以只需要加服务发现即可。</p>
<p>​	4.编写负载均衡器</p>
<p>原因：OpenFegin调用服务时是多台机器同时提供题目服务，它最终调用多个题目服务的时候选择其中一个服务实例去调用</p>
<p>引入Spring Cloud load balance</p>
<p>全局引入负载均衡器依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.5&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>报错描述：相同的Bean被重复注册？</p>
<p>解决：查看是否有引入服务依赖，有则删除。</p>
<p>如果出现404，可以考虑在网页中输路径调试哪个端口出问题。</p>
<h5 id="8-启动项目，测试依赖能否注入，能否完成相互调用"><a href="#8-启动项目，测试依赖能否注入，能否完成相互调用" class="headerlink" title="8.启动项目，测试依赖能否注入，能否完成相互调用"></a>8.启动项目，测试依赖能否注入，能否完成相互调用</h5><h4 id="微服务网关"><a href="#微服务网关" class="headerlink" title="微服务网关"></a>微服务网关</h4><p>为什么要用？</p>
<p>​	1.所有的服务端口不同，增大了前端调用成本</p>
<p>​	2.所有服务是分散的，你可需要集中进行管理，比如集中解决跨域，鉴权，接口文档，服务的路由、接口安全性，流量染色，限流。</p>
<p>是什么？</p>
<blockquote>
<p>Gateway聚合所有的接口，统一接受处理前端的请求</p>
<p>缺点：想定义一些功能，需要对这个技术有比较深的理解。</p>
</blockquote>
<p>Gateway是应用层网关：会有一些业务逻辑（比如根据用户信息判断权限）</p>
<p>Nginx是接入层网关: 比如每个请求的日志，通常没有业务逻辑。</p>
<p>注意：gateway也需要注册到注册中心。</p>
<h5 id="接口路由"><a href="#接口路由" class="headerlink" title="接口路由"></a>接口路由</h5><p>统一接受前端的请求，转发请求到对应的服务。</p>
<p>如何找到路由？可以编写一套路由配置，通过api地址前缀来找到对应的服务。</p>
<p>网关配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      serverAddr: 127.0.0.1:8848</span><br><span class="line">    gateway:</span><br><span class="line">      routes: </span><br><span class="line">        - id: zoj-backend-user-service</span><br><span class="line">        //lb的作用是负载均衡</span><br><span class="line">          uri: lb://zoj-backend-user-service</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/api/question/**</span><br><span class="line">        - id: zoj-backend-question-service</span><br><span class="line">          uri: lb://zoj-backend-question-service</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/api/user/**</span><br><span class="line">        - id: zoj-backend-judge-service</span><br><span class="line">          uri: lb://zoj-backend-judge-service</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/api/judge/**</span><br><span class="line">  application:</span><br><span class="line">    name: zoj-backend-gateway</span><br><span class="line">  main:</span><br><span class="line">    web-application-type: reactive</span><br></pre></td></tr></table></figure>

<p>网关启动时会自动加载mybatisplus，会报错所以需要在主类加注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span><br></pre></td></tr></table></figure>



<h5 id="聚合文档"><a href="#聚合文档" class="headerlink" title="聚合文档"></a>聚合文档</h5><p>以一个全局的视角集中查看管理。</p>
<p><a target="_blank" rel="noopener" href="https://doc.xiaominfo.com/docs/middleware-sources/spring-cloud-gateway/spring-gateway-introduction">https://doc.xiaominfo.com/docs/middleware-sources/spring-cloud-gateway/spring-gateway-introduction</a></p>
<p>1.先给所有业务服务引入依赖，同时开启接口文档</p>
<p>接口文档生成器，非常方便</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;knife4j-gateway-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">knife4j:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<p>2.给网关配置集中管理文档</p>
<p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;knife4j-gateway-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>引入配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">knife4j:</span><br><span class="line">  gateway:</span><br><span class="line">    # ① 第一个配置，开启gateway聚合组件</span><br><span class="line">    enabled: true</span><br><span class="line">    # ② 第二行配置，设置聚合模式采用discover服务发现的模式</span><br><span class="line">    strategy: discover</span><br><span class="line">    discover:</span><br><span class="line">      # ③ 第三行配置，开启discover模式</span><br><span class="line">      enabled: true</span><br><span class="line">      # ④ 第四行配置，聚合子服务全部为Swagger2规范的文档</span><br><span class="line">      version: swagger2</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="跨域解决"><a href="#跨域解决" class="headerlink" title="跨域解决"></a>跨域解决</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 处理跨域</span><br><span class="line">@Configuration</span><br><span class="line">public class CorsConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CorsWebFilter corsFilter() &#123;</span><br><span class="line">        CorsConfiguration config = new CorsConfiguration();</span><br><span class="line">        config.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">        config.setAllowCredentials(true);</span><br><span class="line">        // todo 实际改为线上真实域名、本地域名</span><br><span class="line">        config.setAllowedOriginPatterns(Arrays.asList(&quot;*&quot;));</span><br><span class="line">        config.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser());</span><br><span class="line">        source.registerCorsConfiguration(&quot;/**&quot;, config);</span><br><span class="line">        return new CorsWebFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="权限校验"><a href="#权限校验" class="headerlink" title="权限校验"></a>权限校验</h5><p>可以使用Spring Cloud Gateway的Filter请求拦截器，接收到请求后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 内部拦截器</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class GlobalAuthFilter implements GlobalFilter, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    private AntPathMatcher antPathMatcher = new AntPathMatcher();</span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        ServerHttpRequest serverHttpRequest = exchange.getRequest();</span><br><span class="line">        String path = serverHttpRequest.getURI().getPath();</span><br><span class="line">        //判断路径中是否包含inner，只允许内部调用</span><br><span class="line">        if (antPathMatcher.match(&quot;/**/inner/**&quot;,path))&#123;</span><br><span class="line">            ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">            response.setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">            DataBufferFactory dataBufferFactory = response.bufferFactory();</span><br><span class="line">            DataBuffer dataBuffer = dataBufferFactory.wrap(&quot;无权限&quot;.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            return response.writeWith(Mono.just(dataBuffer));</span><br><span class="line">        &#125;</span><br><span class="line">        //todo 统一权限校验 使用JWT</span><br><span class="line">        return chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 系统变复杂之后，会定义多个拦截器，在这里设置拦截器顺序</span><br><span class="line">     * 拦截器优先级提到最高</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>扩展：可以在网关实现Sentinel接口限流降级</p>
<p>可以使用JWT Token实现用户登录，在网关层面通过token获取登录信息</p>
</blockquote>
<h5 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h5><p>针对有必要用微服务吗？</p>
<p>针对有必要用Spring Cloud微服务吗？</p>
<p>企业内部一般使用API(RPC,HTTP)实现跨部门，跨服务的调用。数据格式和调用代码全部自动生成，保持统一，同时解耦。</p>
<h4 id="消息队列解耦"><a href="#消息队列解耦" class="headerlink" title="消息队列解耦"></a>消息队列解耦</h4><p>此处选用RabbitMQ消息队列改造项目，解耦判题服务和题目服务，题目服务只需要向消息队列发消息，判题服务从消息队列中取消息执行判题，然后异步更新数据库即可。</p>
<p>要传递的消息是什么？</p>
<p>目的：为了解耦判题操作。找对应操作。</p>
<p>注意：消息队列如果执行失败，重新执行任务时会发生死循环，导致电脑卡死，所以还是不要重新入队。</p>
<blockquote>
<p>扩展：处理消息重试，避免消息堆积</p>
<p>扩展：压力测试，验证</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/15/OJ%E5%88%A4%E9%A2%98/" data-id="clymgsif10000bgw02q6th90j" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-客流量智能分析平台" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/26/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/" class="article-date">
  <time class="dt-published" datetime="2024-03-26T12:24:05.000Z" itemprop="datePublished">2024-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/26/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/">客流量智能分析平台</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>1.前置准备</p>
<p>2.开发登录，注册页面</p>
<p>3.学习AI生成BI图表的完整流程（梳理功能点和工作）</p>
<p>4.开发智能分析功能</p>
<p>​	文件上传(前后端)</p>
<p>​	excel处理</p>
<p>5.图表管理功能</p>
<h3 id="1-初始化项目-开发前准备"><a href="#1-初始化项目-开发前准备" class="headerlink" title="1.初始化项目 -开发前准备"></a>1.初始化项目 -开发前准备</h3><h4 id="后端启动项目端口冲突问题解决"><a href="#后端启动项目端口冲突问题解决" class="headerlink" title="后端启动项目端口冲突问题解决"></a>后端启动项目端口冲突问题解决</h4><p>原因：windows Hyper-V 虚拟化平台占用了端口</p>
<p>解决方法：先使用: netsh interface ipv4 show exludedportrange protocol&#x3D;tcp 查看被占用的端口，然后选择一个没有被占用的项目端口启动</p>
<h4 id="前端项目优化（删除多余文件）"><a href="#前端项目优化（删除多余文件）" class="headerlink" title="前端项目优化（删除多余文件）"></a>前端项目优化（删除多余文件）</h4><p>1.说明文件</p>
<p>​		.husky:提交代码时检查是否规范</p>
<p>2.删除mock数据（因为本地有后端）和删除config&#x2F;oneapi</p>
<p>3..删除测试相关目录</p>
<p>​	1.删除locals</p>
<p>​	2.删除src&#x2F;service&#x2F;swagger文件</p>
<p>​	3.删除manifest.json(开发app的时候使用)</p>
<p>​	4.删除tests文件夹</p>
<p>​	5.删除types文件夹</p>
<p>​	6.删除jest.config.ts（前端单元测试文件）</p>
<p>4.prettier、eslint、editorConfig、stylelint都用来保证前端代码规范</p>
<p>​	在file-&gt;setting-&gt;搜索prettier-&gt;指定路径-&gt;勾上on refomate….即可</p>
<p>前端与后端对应的代码：只需要在openapi指定后端的api文件就会自动生成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">openAPI: [</span><br><span class="line">  &#123;</span><br><span class="line">    requestLibPath: &quot;import &#123; request &#125; from &#x27;@umijs/max&#x27;&quot;,</span><br><span class="line">    // 或者使用在线的版本</span><br><span class="line">    schemaPath: &quot;http://localhost:8101/api/v2/api-docs&quot;,</span><br><span class="line">    projectName: &#x27;zbi&#x27;,</span><br><span class="line">    // schemaPath: join(__dirname, &#x27;oneapi.json&#x27;),</span><br><span class="line">    mock: false,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="前端页面优化（修改登录页面内容）"><a href="#前端页面优化（修改登录页面内容）" class="headerlink" title="前端页面优化（修改登录页面内容）"></a>前端页面优化（修改登录页面内容）</h4><p>1.首先找到登录注册的页面（先从route文件开始找起，找到userlogin对应的路由，再找到对应的component）</p>
<p>2.删除其余不必要的功能（手机登录，其他登录方式（根据中文内容去对应代码找并且删掉），自动登录，忘记密码功能删掉）</p>
<p>2.替换网站文字部分:全局替换Ant Design Pro和Ant Design</p>
<p>3.替换logo（访问<a target="_blank" rel="noopener" href="https://www.iconfont.cn/%EF%BC%89">https://www.iconfont.cn/）</a></p>
<p>​	1.随表找一张并把格式改为.svg</p>
<p>​	2.替换为favicon_icon:把png格式转化成favicon_icon</p>
<h4 id="修改登录页面表单内容"><a href="#修改登录页面表单内容" class="headerlink" title="修改登录页面表单内容"></a>修改登录页面表单内容</h4><p>1.将前端页面对应表单位置的name与后端接口文档的字段名称对应</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;ProFormText</span><br><span class="line">  name=&quot;userAccount&quot;-&gt;userAccount要与后端接口文档的用户账户字段对应</span><br><span class="line">  fieldProps=&#123;&#123;</span><br><span class="line">    size: &#x27;large&#x27;,</span><br><span class="line">    prefix: &lt;UserOutlined /&gt;,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  placeholder=&#123;&#x27;请输入用户名&#x27;&#125;</span><br><span class="line">  rules=&#123;[</span><br><span class="line">    &#123;</span><br><span class="line">      required: true,</span><br><span class="line">      message: &#x27;用户名是必填项！&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p>2.点击登录提交（前端与后端对接）</p>
<ol>
<li>找到登录按钮所在的表单代码</li>
<li>修改对应的ts类型</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LoginForm</span><br><span class="line">  contentStyle=&#123;&#123;</span><br><span class="line">    minWidth: 280,</span><br><span class="line">    maxWidth: &#x27;75vw&#x27;,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  logo=&#123;&lt;img alt=&quot;logo&quot; src=&quot;/logo.svg&quot; /&gt;&#125;</span><br><span class="line">  title=&quot;智能 BI[毕业设计]&quot;</span><br><span class="line">  subTitle=&#123;&#x27;智能 BI[毕业设计] 的目标是为了方便对数据分析的便利而诞生的&#x27;&#125;</span><br><span class="line">  //表单提交：前端与后端对接</span><br><span class="line">  onFinish=&#123;async (values) =&gt; &#123;</span><br><span class="line">  //把TS类型进行修改（改成后端的接口调用名称）</span><br><span class="line">    await handleSubmit(values as API.UserLoginRequest);</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>3.进入handleSubmit函数，修改接收的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//接收的参数为后端的接口名</span><br><span class="line">const handleSubmit = async (values: API.UserLoginRequest) =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    // 登录</span><br><span class="line">    //1.直接请求后端:修改为请求后端代码的函数（这个函数的内容不用自己写，因为我们在oneapi中写了后端的接口地址，前端会自动生成），参数为前端传的参数内容</span><br><span class="line">    const res = await userLoginUsingPOST(values);</span><br><span class="line">    //根据后端接口文档的返回值修改处理逻辑的参数名和逻辑</span><br><span class="line">    if (res.code === 0) &#123;</span><br><span class="line">      const defaultLoginSuccessMessage = &#x27;登录成功！&#x27;;</span><br><span class="line">      message.success(defaultLoginSuccessMessage);</span><br><span class="line">      //用户登录成功后获取用户登录信息</span><br><span class="line">      await fetchUserInfo();</span><br><span class="line">      const urlParams = new URL(window.location.href).searchParams;</span><br><span class="line">      history.push(urlParams.get(&#x27;redirect&#x27;) || &#x27;/&#x27;);</span><br><span class="line">      return;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    //登录失败</span><br><span class="line">      message.error(res.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    const defaultLoginFailureMessage = &#x27;登录失败，请重试！&#x27;;</span><br><span class="line">    console.log(error);</span><br><span class="line">    message.error(defaultLoginFailureMessage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	修改fetchUserInfo函数的内容（用户信息获取）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const fetchUserInfo = async () =&gt; &#123;</span><br><span class="line">  const userInfo = await getLoginUserUsingGET();</span><br><span class="line">  if (userInfo) &#123;</span><br><span class="line">    flushSync(() =&gt; &#123;</span><br><span class="line">    //登录成功后，获取了用户登录信息，并且设置了initialState(整个项目的全局状态:这个项目还在,这些信息就可以在多个组件中共享)</span><br><span class="line">      setInitialState((s) =&gt; (&#123;</span><br><span class="line">        ...s,</span><br><span class="line">        currentUser: userInfo,</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>4.app.tsx中的getInitialState函数：ant.design.pro 框架保存全局状态的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export async function getInitialState(): Promise&lt;&#123;</span><br><span class="line">  currentUser?: API.LoginUserVO;</span><br><span class="line">&#125;&gt; &#123;</span><br><span class="line">  const fetchUserInfo = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      const res = await getLoginUserUsingGET();</span><br><span class="line">      return res.data;</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      history.push(loginPath);</span><br><span class="line">    &#125;</span><br><span class="line">    return undefined;</span><br><span class="line">  &#125;;</span><br><span class="line">  // 如果不是登录页面，说明用户登录过了直接返回当前用户，如果在登录页面则什么都返回</span><br><span class="line">  const &#123; location &#125; = history;</span><br><span class="line">  if (location.pathname !== loginPath) &#123;</span><br><span class="line">    const currentUser = await fetchUserInfo();</span><br><span class="line">    return &#123;</span><br><span class="line">      currentUser,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.头像显示</p>
<p>​	在commponent&#x2F;RightContent&#x2F;AvatarDropdown.tsx文件下</p>
<p>​	全局搜avatar,把爆红的name变成后端传输过来的参数名userName</p>
<p>​	在app.tsx中设置头像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">avatarProps: &#123;</span><br><span class="line">  src: initialState?.currentUser?.userAvatar,</span><br><span class="line">  title: &lt;AvatarName /&gt;,</span><br><span class="line">  render: (_, avatarChildren) =&gt; &#123;</span><br><span class="line">    return &lt;AvatarDropdown&gt;&#123;avatarChildren&#125;&lt;/AvatarDropdown&gt;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<p>6.前端请求头要带上cookie</p>
<p>​	在app.tsx中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export const request = &#123;</span><br><span class="line">  baseURL: &quot;http://localhost:8101&quot;,</span><br><span class="line">  withCredentials:true,</span><br><span class="line">  ...errorConfig,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>7.修改requestErrorConfig文件，可以自定义全局请求响应拦截器</p>
<p>问：为什么每次登录请求后面都有如下，那如何删去token后面的字符</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-07_11-03-53.png" alt="Snipaste_2024-02-07_11-03-53"></p>
<p>解决：</p>
<p>1.点进errorConfig,找到文件</p>
<p>2.在请求拦截器中就有这个字符串，注释掉就行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 请求拦截器</span><br><span class="line">requestInterceptors: [</span><br><span class="line">  (config: RequestOptions) =&gt; &#123;</span><br><span class="line">    // 拦截请求配置，进行个性化处理。</span><br><span class="line">    // const url = config?.url?.concat(&#x27;?token = 123&#x27;);</span><br><span class="line">    // return &#123; ...config, url &#125;;</span><br><span class="line">    return config</span><br><span class="line">  &#125;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>名字不好，按shift+f6替换文件名字</p>
<h3 id="2-智能分析业务开发"><a href="#2-智能分析业务开发" class="headerlink" title="2.智能分析业务开发"></a>2.智能分析业务开发</h3><h4 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h4><p>1.用户输入</p>
<p>​	a.分析目标</p>
<p>​	b.上传原始数据(excel)</p>
<p>​	c.更精细化的控制图表</p>
<p>2.后端校验</p>
<p>​	a.检验用户输入是否合法(比如长度)</p>
<p>​	b.成本控制(次数统计和校验、鉴权等)</p>
<p>3.把处理后的数据输入给AI模型(调用AI接口),让AI模型给我们提供信息图表，结论文本</p>
<p>4.图表信息（是一段json配置，是一段代码）、结论文本在前端进行展示</p>
<h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>1.文件上传模块</p>
<p>​	1.1.去contronller层中的FileController中把文件上传函数复制到ChartController</p>
<p>​	1.2.改名genChartByAi,并把地址改成gen</p>
<p>​	该函数的参数</p>
<p>​		1.2.1.@RequestPart(“file”) MultipartFile multipartFile：接收文件的方式</p>
<p>​		1.2.2.UploadFileRequest uploadFileRequest：实际用户传的参数（比如用户的目标）</p>
<p>​		1.2.3.前端请求的参数（见用户中心）</p>
<hr>
<p>​				1.点击这个参数的类型名，找到对象文件所在的位置复制到chart中，取名为：genChartByAiRequest，里面的变量（传输给AI的三个参数）：名称和目标，传输方式用1即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 文件上传请求</span><br><span class="line"> * 让AI帮我们分析目标</span><br><span class="line"> * @author &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="line"> * @from &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class GenChartByAiRequest implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 图表名称</span><br><span class="line">     */</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 目标</span><br><span class="line">     */</span><br><span class="line">    private String goal;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 图表类型</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    private String chartType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​				2.发现少了用户传的图表名称的字段：先改sql-&gt;后端补充对应字段（1.修改Chart对象，Chart图表处理对象（dto&#x2F;chart））-&gt;ChartMapper补充相应字段-&gt;contrller层再补充相应的根据名称去查询的条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queryWrapper.like(StringUtils.isNotBlank(name), &quot;name&quot;, name);</span><br></pre></td></tr></table></figure>

<p>​				3.最后将引用的类型名UploadFileRequest -&gt;genChartByAiRequest</p>
<hr>
<p>​		1.2.4：写后端逻辑</p>
<h4 id="原始数据压缩"><a href="#原始数据压缩" class="headerlink" title="原始数据压缩"></a>原始数据压缩</h4><p>AI接口普遍都有输入字数的限制，尽可能压缩数据，能够允许多传一些数据</p>
<h6 id="如何向AI提词-prompt）"><a href="#如何向AI提词-prompt）" class="headerlink" title="如何向AI提词(prompt）"></a>如何向AI提词(prompt）</h6><p>AI提词技巧1：持续输入，持续优化</p>
<p>AI提词技巧2：数据压缩（内容压缩，比如把很长的内容提取关键词,也可以让AI来做）</p>
<p>可以使用csv 对excel 文件的数据进行提取和压缩</p>
<p>1.读取excel文件，根据excel的内容生成CSV</p>
<p>​	1.写一个工具类ExcelUtils</p>
<p>​	2.用easyExcel：<a target="_blank" rel="noopener" href="https://easyexcel.opensource.alibaba.com/%EF%BC%88%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%E5%8F%AF%E4%BB%A5%E7%9C%8B%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F%EF%BC%89">https://easyexcel.opensource.alibaba.com/（具体使用可以看伙伴匹配系统）</a></p>
<p>​	3.全局搜test_excel,找到代码后拷贝下来到ExcelUtils</p>
<hr>
<p>​			测试：直接在该类下面用main方法测试</p>
<p>​						1.先读取数据</p>
<p>​						2.压缩后，并对空做过滤</p>
<p>​							日期,用户数</p>
<p>​							1号,10<br>​							2号,20<br>​							3号,30</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * excel 转 csv</span><br><span class="line"> * </span><br><span class="line"> * @param multipartFile</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static String excelToCsv(MultipartFile multipartFile) &#123;</span><br><span class="line">    //调用胡图的方法读取本地的文件</span><br><span class="line">    File file = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        file = ResourceUtils.getFile(&quot;classpath:网站数据.xlsx&quot;);</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    //用read方法把已知的文件用Map的方式读取</span><br><span class="line">    List&lt;Map&lt;Integer, String&gt;&gt; list = EasyExcel.read(file)</span><br><span class="line">            .excelType(ExcelTypeEnum.XLSX)</span><br><span class="line">            .sheet()</span><br><span class="line">            .headRowNumber(0)</span><br><span class="line">            .doReadSync();</span><br><span class="line">    if (CollUtil.isEmpty(list))&#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    //转化为csv</span><br><span class="line">    StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">    //读取表头:(LinkedHashMap读取表头是线性的，是连续的）</span><br><span class="line">    LinkedHashMap&lt;Integer, String&gt; headerMap = (LinkedHashMap)list.get(0);</span><br><span class="line">    List&lt;String&gt; headerList = headerMap.values().stream().filter(ObjectUtils::isNotEmpty).collect(Collectors.toList());</span><br><span class="line">    stringBuilder.append(StringUtils.join(headerList,&quot;,&quot;)).append(&quot;\n&quot;);</span><br><span class="line">    //读取每一行数据</span><br><span class="line">    for (int i = 1; i &lt; list.size() ; i++) &#123;</span><br><span class="line">        LinkedHashMap&lt;Integer, String&gt; dataMap = (LinkedHashMap)list.get(i);</span><br><span class="line">        List&lt;String&gt; dataList = dataMap.values().stream().filter(ObjectUtils::isNotEmpty).collect(Collectors.toList());</span><br><span class="line">        stringBuilder.append(StringUtils.join(dataList,&quot;,&quot;)).append(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return stringBuilder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>2.在智能分析接口中调用该工具类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 智能分析</span><br><span class="line"> *</span><br><span class="line"> * @param multipartFile</span><br><span class="line"> * @param genChartByAiRequest</span><br><span class="line"> * @param request</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@PostMapping(&quot;/gen&quot;)</span><br><span class="line">public BaseResponse&lt;String&gt; genChartByAi(@RequestPart(&quot;file&quot;) MultipartFile multipartFile,</span><br><span class="line">                                         GenChartByAiRequest genChartByAiRequest, HttpServletRequest request) &#123;</span><br><span class="line">    String name = genChartByAiRequest.getName();</span><br><span class="line">    String goal = genChartByAiRequest.getGoal();</span><br><span class="line">    String chartType = genChartByAiRequest.getChartType();</span><br><span class="line">    //校验</span><br><span class="line">    ThrowUtils.throwIf(StringUtils.isBlank(goal),ErrorCode.PARAMS_ERROR,&quot;目标为空&quot;);</span><br><span class="line">    ThrowUtils.throwIf(StringUtils.isNotBlank(name) &amp;&amp; name.length() &gt; 100,ErrorCode.PARAMS_ERROR,&quot;名称过长&quot;);</span><br><span class="line"></span><br><span class="line">    String result= ExcelUtils.excelToCsv(multipartFile);</span><br><span class="line">    return ResultUtils.success(result);</span><br></pre></td></tr></table></figure>

<p>3.把multipartFile运用到该工具类上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * excel 转 csv</span><br><span class="line">     *</span><br><span class="line">     * @param multipartFile</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    public static String excelToCsv(MultipartFile multipartFile) &#123;</span><br><span class="line"></span><br><span class="line">        //用read方法把已知的文件用Map的方式读取</span><br><span class="line">        List&lt;Map&lt;Integer, String&gt;&gt; list = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            list = EasyExcel.read(multipartFile.getInputStream())</span><br><span class="line">                    .excelType(ExcelTypeEnum.XLSX)</span><br><span class="line">                    .sheet()</span><br><span class="line">                    .headRowNumber(0)</span><br><span class="line">                    .doReadSync();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;表格处理错误&quot;,e);</span><br><span class="line">        &#125;</span><br><span class="line">        if (CollUtil.isEmpty(list))&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        //转化为csv</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        //读取表头:(LinkedHashMap读取表头是线性的，是连续的）</span><br><span class="line">        LinkedHashMap&lt;Integer, String&gt; headerMap = (LinkedHashMap)list.get(0);</span><br><span class="line">        List&lt;String&gt; headerList = headerMap.values().stream().filter(ObjectUtils::isNotEmpty).collect(Collectors.toList());</span><br><span class="line">        stringBuilder.append(StringUtils.join(headerList,&quot;,&quot;)).append(&quot;\n&quot;);</span><br><span class="line">        //读取每一行数据</span><br><span class="line">        for (int i = 1; i &lt; list.size() ; i++) &#123;</span><br><span class="line">            LinkedHashMap&lt;Integer, String&gt; dataMap = (LinkedHashMap)list.get(i);</span><br><span class="line">            List&lt;String&gt; dataList = dataMap.values().stream().filter(ObjectUtils::isNotEmpty).collect(Collectors.toList());</span><br><span class="line">            stringBuilder.append(StringUtils.join(dataList,&quot;,&quot;)).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return stringBuilder.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>4.测试：swagger接口文档中genChartByAi</p>
<h4 id="调用AI"><a href="#调用AI" class="headerlink" title="调用AI"></a>调用AI</h4><p>输入:</p>
<ul>
<li>系统预设（提前告诉他职责、功能、回复格式要求等等）+分析目标+压缩后的数据</li>
</ul>
<p>最简单的系统预设：你是一个系统分析师，接下来我会给你我的分析目标和原始数据，请告诉我分析结论.</p>
<p>1.拼接系统预设+分析目标+压缩后的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//用户的excel文件输入</span><br><span class="line">StringBuilder userInput = new StringBuilder();</span><br><span class="line">userInput.append(&quot;你是一个系统分析师，接下来我会给你我的分析目标和原始数据，请告诉我分析结论.&quot;).append(&quot;\n&quot;);</span><br><span class="line">userInput.append(&quot;分析目标:&quot;).append(goal).append(&quot;\n&quot;);</span><br><span class="line">//压缩后的数据</span><br><span class="line">String result= ExcelUtils.excelToCsv(multipartFile);</span><br><span class="line">userInput.append(&quot;数据:&quot;).append(result).append(&quot;\n&quot;);</span><br><span class="line">return ResultUtils.success(userInput.toString());</span><br></pre></td></tr></table></figure>

<p>输出的结果</p>
<hr>
<p>{<br>  “code”: 0,<br>  “data”: “你是一个系统分析师，接下来我会给你我的分析目标和原始数据，请告诉我分析结论.\n分析目标:分析网站用户\n数据:日期,用户数\n1号,10\n2号,20\n3号,30\n\n”,<br>  “message”: “ok”<br>}</p>
<p>你是一个系统分析师，接下来我会给你我的分析目标和原始数据，请告诉我分析结论.</p>
<p>分析目标:分析网站用户</p>
<p>数据:日期,用户数</p>
<p>1号,10</p>
<p>2号,20</p>
<p>3号,30</p>
<hr>
<p>AI提词技巧3：在系统（模型）层面做预设效果一般来说会比直接拼接在用户消息里的效果要更好一些</p>
<p><strong>没有预设，回答的效果天差地别</strong></p>
<p>AI提词技巧4：除了系统预设外，可以额外关联一问一答两条消息，相当于给AI一个提示</p>
<h4 id="智能分析业务流程开发"><a href="#智能分析业务流程开发" class="headerlink" title="智能分析业务流程开发"></a>智能分析业务流程开发</h4><h5 id="利用AI生成结论和图表"><a href="#利用AI生成结论和图表" class="headerlink" title="利用AI生成结论和图表"></a>利用AI生成结论和图表</h5><p>AI可以直接生成结论，但不能直接生成图表</p>
<p>AI不能直接生成图表，但可以利用AI生成代码&#x3D;&gt;可以把代码利用前端的组件库(Echarts)在网页进行展示</p>
<h5 id="可视化图表工具："><a href="#可视化图表工具：" class="headerlink" title="可视化图表工具："></a>可视化图表工具：</h5><p><a target="_blank" rel="noopener" href="https://echarts.apache.org/zh/index.html">https://echarts.apache.org/zh/index.html</a></p>
<p>预期生成的图表代码</p>
<p>option &#x3D; {<br>  xAxis: {<br>    type: ‘category’,<br>    data: [‘Mon’, ‘Tue’, ‘Wed’, ‘Thu’, ‘Fri’, ‘Sat’, ‘Sun’]<br>  },<br>  yAxis: {<br>    type: ‘value’<br>  },<br>  series: [<br>    {<br>      data: [150, 230, 224, 218, 135, 147, 260],<br>      type: ‘line’<br>    }<br>  ]<br>};</p>
<h5 id="AI提问技巧："><a href="#AI提问技巧：" class="headerlink" title="AI提问技巧："></a>AI提问技巧：</h5><p>如果想要让AI更好的理解我们的输入，给我预期的，精确格式的输出，我们就要严格控制提问词</p>
<p>0.使用系统预设</p>
<p>1.控制输入格式（便于AI精确的理解需求）</p>
<hr>
<p><strong>优化前</strong></p>
<p>你是一个数据分析师，请帮我分析网站用户的增长趋势，并帮我生成图表的前端代码</p>
<p>原始数据如下：</p>
<p>日期，用户数</p>
<p>1号，10</p>
<p>2号，20</p>
<p>3号，30</p>
<p><strong>优化后</strong>（预设）</p>
<p>你是一个数据分析师和前端开发专家，接下来我会按照以下固定格式给你提供内容:</p>
<p>分析需求:</p>
<p>{数据分析的需求或者目标}</p>
<p>原始数据:</p>
<p>{csv格式的原始数据，用,作为分隔符}</p>
<p>请根据以上内容，帮我生成数据分析结论和可视化图表代码</p>
<p>样例</p>
<p>分析需求：</p>
<p>分析网站用户增长情况</p>
<p>原始数据：</p>
<p>日期,用户数</p>
<p>1号,10</p>
<p>2号,20</p>
<p>3号,30</p>
<hr>
<p>2.控制输出格式（便于AI返回的内容能够更加方便的为我们所用）</p>
<hr>
<p>优化前</p>
<p>你是一个数据分析师和前端开发专家，接下来我会按照以下固定格式给你提供内容:</p>
<p>分析需求:</p>
<p>{数据分析的需求或者目标}</p>
<p>原始数据:</p>
<p>{csv格式的原始数据，用,作为分隔符}</p>
<p>请根据以上内容，帮我生成数据分析结论和可视化图表代码，结论至少生成500字</p>
<p>优化后</p>
<p>你是一个数据分析师和前端开发专家，接下来我会按照以下固定格式给你提供内容:</p>
<p>分析需求:</p>
<p>{数据分析的需求或者目标}</p>
<p>原始数据:</p>
<p>{csv格式的原始数据，用,作为分隔符}</p>
<p>请根据这两部分内容，帮我按照以下格式生成内容（此外不要输出任何多余开头、结尾、注释）</p>
<p>【【【【【【</p>
<p>{前端Echarts V5 的option 配置对象js代码，合理的将数据进行可视化，不要生成任何的内容，比如注释}</p>
<p>【【【【【【</p>
<p>{明确的数据分析结论，越详细越好，不要生成多余的注释}</p>
<hr>
<p>3.指定一个示例问答，one-shot或者few-shot</p>
<h4 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h4><h5 id="1-写一个系统预设"><a href="#1-写一个系统预设" class="headerlink" title="1.写一个系统预设"></a>1.写一个系统预设</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final String prompt = &quot;你是一个数据分析师和前端开发专家，接下来我会按照以下固定格式给你提供内容:\n&quot; +</span><br><span class="line">        &quot;分析需求:\n&quot; +</span><br><span class="line">        &quot;&#123;数据分析的需求或者目标&#125;\n&quot; +</span><br><span class="line">        &quot;原始数据:\n&quot; +</span><br><span class="line">        &quot;&#123;csv格式的原始数据，用,作为分隔符&#125;\n&quot; +</span><br><span class="line">        &quot;请根据这两部分内容，帮我按照以下格式生成内容（此外不要输出任何多余开头、结尾、注释）\n&quot; +</span><br><span class="line">        &quot;【【【【【【\n&quot; +</span><br><span class="line">        &quot;&#123;前端Echarts V5 的option 配置对象js代码，合理的将数据进行可视化，不要生成任何的内容，比如注释&#125;\n&quot; +</span><br><span class="line">        &quot;【【【【【【\n&quot; +</span><br><span class="line">        &quot;&#123;明确的数据分析结论，越详细越好，不要生成多余的注释&#125;&quot;;</span><br></pre></td></tr></table></figure>

<h5 id="2-调用AI（3种调用AI的方式）"><a href="#2-调用AI（3种调用AI的方式）" class="headerlink" title="2.调用AI（3种调用AI的方式）"></a>2.调用AI（3种调用AI的方式）</h5><ol>
<li><p>直接调用OpenAI或者其他AI原始大模型官网的接口</p>
<p>官方文档：<a target="_blank" rel="noopener" href="https://platform.openai.com/docs/api-reference">https://platform.openai.com/docs/api-reference</a></p>
<p>优点：不经封装，最灵活，最原始</p>
<p>缺点：要钱，要魔法</p>
<p>本质上OpenAI就是提供了HTTP的接口，我们可以用任何语言取调用</p>
<p>步骤：</p>
<ol>
<li>在请求头中指定OPENAI_API_KEY(Authorization:Bearer OPEN_API_KEY)</li>
<li>找到你要使用的接口，比如AI，比如AI对话接口（<a target="_blank" rel="noopener" href="https://platform.openai.com/docs/api-reference/chat%EF%BC%89">https://platform.openai.com/docs/api-reference/chat）</a></li>
<li>按照接口文档示例，构造HTTP请求，比如用Hutool工具类，或者用HTTPClient</li>
</ol>
</li>
<li><p>使用云服务商提供的，封装后的AI接口</p>
<p>比如:Azure 云</p>
<p>优点：本地都能用</p>
<p>缺点：依然要钱，收费更贵</p>
</li>
<li><p>利用鱼聪明AI提供的开放SDK（看API开放平台）</p>
<p>优点：目前不要钱，而且有很多现成的模型（prompt系统预设）可以用</p>
<p>缺点：不完全灵活，但是可以定义自己的模型</p>
</li>
</ol>
<p>​	鱼聪明AI调用：<a target="_blank" rel="noopener" href="https://github.com/liyupi/yucongming-java-sdk">https://github.com/liyupi/yucongming-java-sdk</a></p>
<p>另一种更快捷的方式：</p>
<p>1.安装依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.yucongming&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;yucongming-java-sdk&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.在application.yml中写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 鱼聪明AI配置</span><br><span class="line">yuapi:</span><br><span class="line">  client:</span><br><span class="line">    access-key: dt5jsd6yf92lbhxfqna5mzb03alwlmvn</span><br><span class="line">    secret-key: fita5c4d9dm0snzl3x21ryszjldtxnpt</span><br></pre></td></tr></table></figure>

<p>3.构造Aimanager请求类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AiManager &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private YuCongMingClient yuCongMingClient;</span><br><span class="line"></span><br><span class="line">    public void doChat(String message)&#123;</span><br><span class="line">        DevChatRequest devChatRequest = new DevChatRequest();</span><br><span class="line">        //指定模型id</span><br><span class="line">        devChatRequest.setModelId(1742866527877050370L);</span><br><span class="line">        devChatRequest.setMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>测试：</p>
<p>建立一个AiManager类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;你是一个数据分析师和前端开发专家，接下来我会按照以下固定格式给你提供内容:\n&quot; +</span><br><span class="line">//                &quot;分析需求:\n&quot; +</span><br><span class="line">//                &quot;&#123;数据分析的需求或者目标&#125;\n&quot; +</span><br><span class="line">//                &quot;原始数据:\n&quot; +</span><br><span class="line">//                &quot;&#123;csv格式的原始数据，用,作为分隔符&#125;\n&quot; +</span><br><span class="line">//                &quot;请根据这两部分内容，帮我按照以下格式生成内容（此外不要输出任何多余开头、结尾、注释）\n&quot; +</span><br><span class="line">//                &quot;【【【【【【\n&quot; +</span><br><span class="line">//                &quot;&#123;前端Echarts V5 的option 配置对象js代码，合理的将数据进行可视化，不要生成任何的内容，比如注释&#125;\n&quot; +</span><br><span class="line">//                &quot;【【【【【【\n&quot; +</span><br><span class="line">//                &quot;&#123;明确的数据分析结论，越详细越好，不要生成多余的注释&#125;&quot;;</span><br></pre></td></tr></table></figure>

<hr>
<p>智能接口的实现</p>
<p>1.构造用户请求（用户消息、csv数据、图表类型等）</p>
<p>2.调用鱼聪明sdk,得到AI响应结果</p>
<p>3.从AI响应结果中，取出需要的结果</p>
<p>4.保存图表</p>
<h4 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h4><p>做用户交互的界面：左侧是表单，右侧是图表</p>
<p>1.先复制登录表单，添加路由，删除多余代码，更改classname</p>
<h5 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h5><p>1.输入表单</p>
<p>​	1.找ant design 组件库：<a target="_blank" rel="noopener" href="https://ant-design.antgroup.com/components/form-cn">https://ant-design.antgroup.com/components/form-cn</a></p>
<p>​	2.删除多余代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//rule表示必填项</span><br><span class="line">&lt;Form.Item name=&quot;goal&quot; label=&quot;分析目标&quot; rules=&#123;[&#123; required: true, message: &#x27;请输入分析目标&#x27; &#125;]&#125;&gt;</span><br><span class="line">  &lt;TextArea placeholder = &quot;请输入你的分析需求，比如分析网站的增长情况&quot; /&gt;</span><br><span class="line">&lt;/Form.Item&gt;</span><br></pre></td></tr></table></figure>

<p>文件上传时注意取出原始对象</p>
<p>2.生成的图表：</p>
<p>​	使用库：<a target="_blank" rel="noopener" href="https://git.hust.cc/echarts-for-react/">https://git.hust.cc/echarts-for-react/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//如果正在提交中时把该按钮禁用</span><br><span class="line">&lt;Button type=&quot;primary&quot; htmlType=&quot;submit&quot; loading=&#123;submitting&#125; disabled=&#123;submitting&#125;&gt;</span><br><span class="line">              智能分析</span><br><span class="line">            &lt;/Button&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//生成的图表代码是字符串，要把他生成用json格式的对象</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  生成图表:</span><br><span class="line">  &#123;</span><br><span class="line">    chart?.genChart &amp;&amp; &lt;ReactECharts option=&#123;JSON.parse(chart?.genChart)&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>3.生成的结论</p>
<p>计划</p>
<p>1.开发图表管理功能（不用重新生成，历史记录）</p>
<p>2.优化系统（4种优化）</p>
<h3 id="3-开发图表管理功能（增删改查）"><a href="#3-开发图表管理功能（增删改查）" class="headerlink" title="3.开发图表管理功能（增删改查）"></a>3.开发图表管理功能（增删改查）</h3><p>核心：获取个人创建的图表列表</p>
<p>后端：复用spingboot-init 初始化模板的增删改查代码（listChartByPage）</p>
<p>前端：</p>
<p>​	1.开发一个列表页</p>
<p>​	2.支持按照图表名称搜索</p>
<p>步骤</p>
<hr>
<p>​	1.创建路由和页面</p>
<p>​		a. 复制AddChart文件</p>
<p>​		b. 删除多余代码</p>
<p>​		c. shift+f6重构文件名为MyChart</p>
<p>tips:能用现成的组件就不要写样式，因为现成的组件都做好适配，如果自己写的话可能会出现多端不协调的情况</p>
<hr>
<p>​	2.获取需要的数据 ，定义state变量来存储数据，用于给页面展示</p>
<p>​		 oneapi自动生成与后端接口对应的方法listMyChartByPageUsingPOST，因此直接调用即可</p>
<p>​		注：要使用await （把异步变成同步，等后端返回结果之后才会执行后续代码）就必须使用async</p>
<hr>
<p>3.设置发送给后端的查询条件：</p>
<p>​		3.1.找参数：点进listMyChartByPageUsingPOST，找到API.ChartQueryRequest，这个就是传给后端的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const loadData = async () =&gt;&#123;</span><br><span class="line">  const res= await listMyChartByPageUsingPOST();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		3.2.设置查询条件，把初始条件提出便于后面更改初始条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> const initSearchParams = &#123;</span><br><span class="line">    pageSize: 12,</span><br><span class="line">  &#125;</span><br><span class="line">//&#123;...initSearchParams&#125;这样做的目的是防止对象污染，防止initSearchParams改变</span><br><span class="line">  const [searchParams, setSearchParams] = useState&lt;API.ChartQueryRequest&gt;(&#123;...initSearchParams&#125;);</span><br></pre></td></tr></table></figure>

<p>​	ctrl+ alt + t找模板代码（try-catch）</p>
<hr>
<p>  4.显示的逻辑（如果失败则显示失败原因，成功则把数据显示出来）</p>
<p>​			4.1.设置变量存后端传过来的数据（点进listMyChartByPageUsingPOST前端生成的方法-&gt;BaseResponsePageChart-&gt;PageChart_-&gt;Chart）</p>
<p>tips:逻辑都在后端，前端只需要去调用即可</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [chartList, setChartList] = useState&lt;<span class="variable constant_">API</span>.<span class="property">Chart</span>[]&gt;();</span><br><span class="line"><span class="keyword">const</span> [total, setTotal] = useState&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>​			4.2编写获取后端数据的逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const loadData = async () =&gt;&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const res = await listMyChartByPageUsingPOST(searchParams);</span><br><span class="line">    if (res.data)&#123;</span><br><span class="line">      setChartList(res.data.records ?? []);</span><br><span class="line">      setTotal(res.data.total ?? 0);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      message.error(&#x27;获取图表失败.&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (e: any) &#123;</span><br><span class="line">    message.error(&#x27;获取图表失败.&#x27;+ e.message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​			4.3.数据展示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//在页面首次渲染时以及[]数组里面的值发生变化时会执行loadData方法</span><br><span class="line">useEffect(() =&gt;&#123;</span><br><span class="line">  loadData();</span><br><span class="line">&#125;,[searchParams]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line">  &lt;div className=&quot;my-chart-page&quot;&gt;</span><br><span class="line">    数据列表:</span><br><span class="line">    &#123;JSON.stringify(chartList)&#125;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    总数: &#123;total&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>tips：先把最简单直观的数据展示给前端，再去调样式</p>
<p>​	展示效果：</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-10_16-39-17.png" alt="Snipaste_2024-02-10_16-39-17"></p>
<p>5.设置列表样式：</p>
<p>​	1.引入Ant Design的List组件：<a target="_blank" rel="noopener" href="https://ant-design.antgroup.com/components/list-cn#list-demo-basic">https://ant-design.antgroup.com/components/list-cn#list-demo-basic</a></p>
<p>​	2.删除多余代码</p>
<p>​	3.修改代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;my-chart-page&quot;&gt;</span><br><span class="line">  &lt;List</span><br><span class="line">    itemLayout=&quot;vertical&quot;</span><br><span class="line">    size=&quot;large&quot;</span><br><span class="line">    pagination=&#123;&#123;</span><br><span class="line">      onChange: (page) =&gt; &#123;</span><br><span class="line">        console.log(page);</span><br><span class="line">      &#125;,</span><br><span class="line">      pageSize: 3,</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    dataSource=&#123;chartList&#125;</span><br><span class="line">    footer=&#123;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;b&gt;ant design&lt;/b&gt; footer part</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    renderItem=&#123;(item) =&gt; (</span><br><span class="line">      &lt;List.Item</span><br><span class="line">        key=&#123;item.id&#125;</span><br><span class="line">        extra=&#123;</span><br><span class="line">          &lt;ReactECharts option=&#123;JSON.parse(item.genChart ?? &#x27;&#123;&#125;&#x27;)&#125;/&gt;</span><br><span class="line">        &#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;List.Item.Meta</span><br><span class="line">          avatar=&#123;&lt;Avatar src=&quot;https://api.dicebear.com/7.x/miniavs/svg?seed=0&quot; /&gt;&#125;</span><br><span class="line">          title=&#123;item.name&#125;</span><br><span class="line">          description=&#123;item.chartType ? (&quot;图表类型: &quot;+ item.chartType): undefined&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123;&quot;分析图表目标: &quot;+item.goal&#125;</span><br><span class="line">      &lt;/List.Item&gt;</span><br><span class="line">    )&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">  总数: &#123;total&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<p>问题：图表没渲染</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-10_17-21-20.png" alt="Snipaste_2024-02-10_17-21-20"></p>
<p>原因：可能是没宽度</p>
<p>解决办法：从extra中移到其他位置即可</p>
<p>6.调整List组件中的内容为自己的(注意:获取用户头像可以从初始状态中获取)</p>
<p>如何在组件中引入initalStates</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123;initalState,setInitalState&#125; = useModel(&#x27;@@initialState&#x27;);</span><br><span class="line">const &#123;currentUser&#125; = initialState ?? &#123;&#125;;</span><br></pre></td></tr></table></figure>



<p>7.针对样式，对数据做一些处理，比如统一隐藏图表自身的title</p>
<p>​	1.在后端放入数据库前过滤掉</p>
<p>​	2.前端过滤后端传过来的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//隐藏图表的title</span><br><span class="line">if (res.data.records)&#123;</span><br><span class="line">  res.data.records.forEach(data =&gt;&#123;</span><br><span class="line">    const chartOption = JSON.parse(data.genChart ?? &#x27;&#123;&#125;&#x27;);</span><br><span class="line">    chartOption.title = undefined;</span><br><span class="line">    data.genChart = JSON.stringify(chartOption);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>8.增加分页</p>
<p>​	1.当用户点击分页时，会调用onChange方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  const [searchParams, setSearchParams] = useState&lt;API.ChartQueryRequest&gt;(&#123; ...initSearchParams &#125;);</span><br><span class="line">pagination=&#123;&#123;</span><br><span class="line">  onChange: (page,pageSize) =&gt; &#123;</span><br><span class="line">    setSearchParams(&#123;</span><br><span class="line">      ...searchParams,</span><br><span class="line">      current: page,</span><br><span class="line">      pageSize,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>​	2.而当搜索参数修改时，会重新渲染图表，因此换页会产生新数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  loadData();</span><br><span class="line">&#125;, [searchParams]);</span><br></pre></td></tr></table></figure>

<p>9.增加搜索框</p>
<p>组件库：<a target="_blank" rel="noopener" href="https://ant-design.antgroup.com/components/input-cn">https://ant-design.antgroup.com/components/input-cn</a></p>
<p><strong>如何添加全局样式</strong></p>
<p>原子化CSS</p>
<p>在global.less下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.margin-16 &#123;</span><br><span class="line">  margin-bottom: 16px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目标文件就可以直接使用即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;margin-16&quot;/&gt;</span><br></pre></td></tr></table></figure>



<p><strong>利用F12控制台进行弱网测试</strong></p>
<p>10.其他优化：比如loading效果</p>
<p>扩展点：</p>
<p>1.支持用户查看原始数据</p>
<p>2.支持跳转到图表编辑页，去编辑图表</p>
<h4 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h4><p>现在的网站足够安全么？</p>
<p>​	a.如果用户上传一个超大的文件怎么办</p>
<p>​    b.如果用户用科技疯狂点击提交，怎么办？</p>
<p>​	c.如果AI的生成太慢（比如需要一分钟），又有很多用户要同时生成，给系统造成了压力，怎么办？</p>
<p>​		怎么兼顾用户的体验和系统的可用性？</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>如果用户上传一个超大的文件怎么办？1000G</p>
<p><strong>只要涉及到用户自主上传的操作，一定要校验文件（图像）</strong></p>
<p>校验的维度：</p>
<p>​	a.文件大小</p>
<p>​	b.文件的后缀</p>
<p>​	c.文件的内容(成本要高一些)</p>
<p>​	d.文件的合规性（比如敏感内容，建议使用第三方的审核功能）</p>
<p>扩展点：</p>
<p>1.分片上传</p>
<p>2.接入腾讯云的图片万象数据审核（cos对象存储的审核功能）</p>
<h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><h5 id="现状："><a href="#现状：" class="headerlink" title="现状："></a>现状：</h5><p>我们把每个图表的原始数据全部存放在同一个数据表(chart表)的字段里。</p>
<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>1.如果用户上传的原始数据量很大、图表数日益增多，查询Chart表就会很慢。</p>
<p>2.对于BI平台，用户是由查看原始数据，对原始数据进行简单查询的需求。现在如果把所有数据存放在一个字段（列）中，查询时，只能取出这个列的内容</p>
<h5 id="解决方案：分库分表"><a href="#解决方案：分库分表" class="headerlink" title="解决方案：分库分表"></a>解决方案：分库分表</h5><p>把每个图表对应的原始数据单独的保存为一个新的数据表，而不是都存在一个字段里，查询时按照图表id进行查询</p>
<p>这样的好处：</p>
<p> 1.存储时，能够分开存储，互不影响（安全性：一个恶意用户存了很大数据量的内容，但是分开存储后是通过id查找，这样就不会影响其他用户的搜索效率）</p>
<p> 2.查询时，可以使用各种sql语句灵活取出需要的字段，查询性能更快</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>分开存储</p>
<p>1.存储信息时，不把信息存储为字段，而是新建一个chart_{图表id}的数据表</p>
<p>通过图表id、数据列名、数据类型等字段，生成以下的sql语句，并且执行即可</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> chart_图表id</span><br><span class="line">&#123;</span><br><span class="line">	日期 <span class="type">int</span> <span class="keyword">null</span>;</span><br><span class="line">	用户数 <span class="type">int</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>分开查询</p>
<p>1.之前直接查询图表，取chartData字段，现在改为读取chart_{图表id}的数据表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from chart_&#123;图表id&#125;</span><br></pre></td></tr></table></figure>

<p>分库分表</p>
<p>水平分表：当系统数据量大时，拆表，前一万个图表数据一个表，后一万个图表数据一个表</p>
<p>垂直分库：根据业务分库（用户，订单等）</p>
<p><strong>具体实现：MyBatis的动态SQL(根据代码灵活地动态生成sql)</strong></p>
<p>1.想清楚哪些是需要动态替换的，比如要查询的数据表名（chart_{图表id}）</p>
<p>2.在ChartMapper.xml中输入（返回的是多条数据，所以要用list）</p>
<p>以下方式最灵活，但是要小心SQL注入风险:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryChartData&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        $&#123;querySql&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注：只要在sql语句中有$的就要防范sql注入</p>
<p>例如：select * from chart_12345 where id &#x3D; 1 or 1&#x3D;1;(直接把数据库所有数据都读出)</p>
<p>解决方法:可以在业务代码生成sql语句时，在生成的过程中做校验</p>
<p>3.找到ChartMapper.java调用方法，方法名和上一步select中的id 相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChartMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Chart&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String,Object&gt; <span class="title function_">queryChartData</span><span class="params">(String querySql)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class ChartMapperTest &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private ChartMapper chartMapper;</span><br><span class="line">    @Test</span><br><span class="line">    void queryChartData() &#123;</span><br><span class="line">        String chartId =&quot;1111&quot;;</span><br><span class="line">        String querySql = String.format(&quot;select * from chart_%s&quot;,chartId) ;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; resultData = chartMapper.queryChartData(querySql);</span><br><span class="line">        System.out.println(resultData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p>现在的问题：使用系统是需要消耗成本的，用户有可能疯狂刷流量，让你破产。</p>
<p>解决问题：</p>
<p>1.控制成本&#x3D;》限制用户调用总次数</p>
<p>2.用户在短时间内疯狂使用，导致服务器资源被占满，其他用户无法使用&#x3D;&gt;限流</p>
<p>思考限流阈值多大合适？参考正常用户的使用，比如限制单个用户在每秒只能使用1次</p>
<h5 id="限流的几种算法"><a href="#限流的几种算法" class="headerlink" title="限流的几种算法"></a>限流的几种算法</h5><p>文章参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6967742960540581918">https://juejin.cn/post/6967742960540581918</a></p>
<p>1）固定窗口限流</p>
<p>单位时间内允许部分操作</p>
<p>例：1小时允许10个用户操作</p>
<p>优点：最简单</p>
<p>缺点：可能出现流量突刺</p>
<p>比如：前59分钟没有一个操作，第59分钟来了10个操作；1小时01分钟又来了10个操作</p>
<p>相当于2分钟内执行了20个操作，服务器仍然有高峰危险</p>
<p>2）滑动窗口限流（类似于计算机网络的流量控制（TCP&#x2F;IP层））</p>
<p>单位时间内运行部分操作，但是这个单位时间是滑动的，需要指定一个滑动单位</p>
<p>例：假设滑动单位为1min</p>
<p>开始：0s		1h		2h</p>
<p>1min后：1min		1h1min(窗口发生滑动)</p>
<p>优点:能够解决上述流量突刺问题，因为第59分钟-1小时59分时间段内只能接受10次请求，只要还在这个窗口内，更多的操作就会被拒绝。</p>
<p>缺点：实现相对复杂，限流效果和你的滑动单位有关，滑动单位越小，限流效果越好，但往往很难选取到一个特别合适的滑动单位。</p>
<p><strong>3）漏桶限流（推荐）</strong></p>
<p>以<strong>固定的速率</strong>处理请求（漏水），当请求桶满了后，拒绝请求。</p>
<p>例如：每秒处理10个请求，桶的容量是10，以0.1秒的固定处理一次请求，如果1秒来了10个请求就都可以处理完，但如果1秒内来了11个请求，最后那个请求就会溢出桶，被拒绝。</p>
<p>优点：能够一定程度上应对流量突刺，<strong>能够固定速率处理请求，保证服务器的安全</strong></p>
<p>缺点：没有办法迅速处理一批请求，只能一个一个按顺序来处理(固定速率的缺点)</p>
<p><strong>4）令牌桶限流（推荐）</strong></p>
<p>例如：管理员先生成一批令牌，每秒生成10 个令牌；当用户操作前，先拿到一个令牌，有令牌的人就有资格进行操作，能同时执行操作；拿不到令牌就等着</p>
<p>优点：能够并发处理同时的请求，<strong>并发性能会更高</strong></p>
<p>需要考虑的问题：还是存在时间单位的选取问题</p>
<h5 id="限流的粒度"><a href="#限流的粒度" class="headerlink" title="限流的粒度"></a>限流的粒度</h5><p>1.针对某个方法限流，即单位时间内最多允许同时XX个操作使用这个方法</p>
<p>2.针对某个用户限流，比如单个用户单位时间内最多执行XX次操作</p>
<p>3.针对某个用户X方法限流，比如单个用户单位时间内最多可执行XX次这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限流判断,每个用户一个限流器,</span></span><br><span class="line"><span class="comment">// 参数这样写的好处是每个方法的限流器不会冲突，一个方法的调用了的次数，不会影响其他方法的使用</span></span><br><span class="line"> redisLimiterManager.doRateLimit(<span class="string">&quot;genChartByAi_&quot;</span>+loginUser.getId());</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="限流的实现"><a href="#限流的实现" class="headerlink" title="限流的实现"></a>限流的实现</h5><p>1）本地限流（单机限流）</p>
<p>每个服务器单独限流，一般适用于单体项目<strong>，就是项目只有一个服务器</strong></p>
<p>实现：</p>
<p>要使用第三方库实现单机限流，可以使用Guava库中的RateLimiter类。RateLimiter是一个简单且强大的限流工具，可以控制某个操作在一定时间内的调用频率。</p>
<p>首先，你需要在你的项目中引入Guava库的依赖。在Maven项目中，可以在pom.xml文件中添加以下依赖：</p>
<p>xml</p>
<p>复制</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>30.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，你可以使用RateLimiter类来实现单机限流。下面是一个简单的示例代码：</p>
<p>java</p>
<p>复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个每秒允许2个请求的限流器</span></span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟10个请求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 尝试获取一个许可，如果获取不到则等待</span></span><br><span class="line">            limiter.acquire();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;执行第 &quot;</span> + i + <span class="string">&quot; 个请求&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个每秒允许2个请求的限流器。在循环中，我们使用<code>acquire()</code>方法来获取一个许可，如果获取不到许可，则会阻塞等待。然后我们执行业务逻辑，这里只是简单地打印了一条消息。</p>
<p>通过使用RateLimiter类，你可以方便地实现单机限流，控制某个操作的调用频率，保护系统免受过多的请求压力。</p>
<p>2）分布式限流（多机限流）</p>
<p>如果你的项目又多个服务器，比如微服务，那么建议使用分布式限流。</p>
<p>方式</p>
<p>​	1.把统计用户的使用频率等数据放到一个集中的存储进行统计，比如Redis，这样无论用户的请求落到哪个服务器，都以集中的数据存储内的数据为准(Redission-是一个操作Redis的工具库，伙伴匹配系统讲过)</p>
<p>​	2.在网关集中进行限流和统计（比如Sentinel, Spring Cloud Gateway）</p>
<p>实现：</p>
<p>要实现分布式限流，可以使用Redis作为分布式缓存，并结合第三方库实现限流功能。一个常用的库是Redisson，它提供了分布式限流的功能。</p>
<p>首先，你需要在你的项目中引入Redisson的依赖。在Maven项目中，可以在pom.xml文件中添加以下依赖：</p>
<p>xml</p>
<p>复制</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.16.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，你可以使用Redisson的RLock对象来实现分布式限流。下面是一个简单的示例代码：</p>
<p>java</p>
<p>复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedRateLimiterExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Redisson客户端连接</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://localhost:6379&quot;</span>);</span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取分布式锁对象</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;myLock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试获取锁，最多等待3秒</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">acquired</span> <span class="operator">=</span> lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">                <span class="comment">// 执行业务逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;执行请求&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 限流处理</span></span><br><span class="line">                System.out.println(<span class="string">&quot;请求被限流&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭Redisson客户端连接</span></span><br><span class="line">        redisson.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用Redisson创建了一个RedissonClient对象，并通过该对象获取了一个分布式锁对象RLock。在业务逻辑中，我们尝试获取锁，如果获取成功，则执行请求的业务逻辑；如果获取失败，则进行限流处理。</p>
<p>通过使用Redisson库，你可以方便地实现分布式限流，保护系统免受过多的请求压力。同时，Redis的高性能和可靠性也能够满足分布式限流的需求。</p>
<h5 id="Redission-限流实现"><a href="#Redission-限流实现" class="headerlink" title="Redission 限流实现"></a>Redission 限流实现</h5><p>Redission 内置了一个限流工具类，可以帮助你利用Redis来存储，来统计。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson#quick-start">https://github.com/redisson/redisson#quick-start</a></p>
<p>1.安装依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.26.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;  </span><br></pre></td></tr></table></figure>

<p>2.在config中创建类（注意要先按照Redis，具体安装过程看伙伴匹配系统）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class RedissonConfig &#123;</span><br><span class="line"></span><br><span class="line">    //把application.yml中的redis的值变成动态</span><br><span class="line">    private Integer database;</span><br><span class="line"></span><br><span class="line">    private String host;</span><br><span class="line"></span><br><span class="line">    private Integer port;</span><br><span class="line"></span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedissonClient redissonClient()&#123;</span><br><span class="line">        Config config = new Config();</span><br><span class="line">        config.useSingleServer()</span><br><span class="line">                .setDatabase(database)</span><br><span class="line">                .setAddress(&quot;redis://&quot;+host+&quot;:&quot;+port)</span><br><span class="line">                .setPassword(password);</span><br><span class="line">        RedissonClient redisson = Redisson.create(config);</span><br><span class="line">        return redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>tips：</p>
<p>1.注意.setDatabase(1)设置编号时要与业务数据库分开（存用户信息是1，其他业务数据库用的是2）</p>
<p>2..setPassword(password)：如果Redis没设置密码就不要加这行会报错</p>
<p>3.写一个单独的管理类 RedisLimiterManager</p>
<p>什么是manager？专门提供RedisLimiter限流基础服务的（<strong>提供了通用的能力</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 专门启动RedisLimiter限流基础服务的（提供了通用的能力）</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class RedisLimiterManager &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 限流操作</span><br><span class="line">     *</span><br><span class="line">     * @param key 区分不同的限流器，比如不同的用户id应该分别统计</span><br><span class="line">     */</span><br><span class="line">    public void doRateLimit(String key)&#123;</span><br><span class="line">        // 获取RateLimiter对象，每秒限制5个请求</span><br><span class="line">        RRateLimiter rateLimiter = redissonClient.getRateLimiter(key);</span><br><span class="line">        rateLimiter.trySetRate(RateType.OVERALL, 5, 1, RateIntervalUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        //每当一个请求来了之后，请求一个令牌</span><br><span class="line">        boolean canOp =rateLimiter.tryAcquire(1);</span><br><span class="line">        if (!canOp)&#123;</span><br><span class="line">            throw new BusinessException(ErrorCode.TOO_MANY_REQUEST);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>系统优化-异步化</p>
<p>0.系统问题分析</p>
<p>1.异步化的思路</p>
<p>2.线程池的理论和实战</p>
<p>3.前端后端异步化改造</p>
<h3 id="4-系统问题分析"><a href="#4-系统问题分析" class="headerlink" title="4.系统问题分析"></a>4.系统问题分析</h3><p>问题的场景：调用的服务处理能力有限，或者接口的（处理和返回时间）较长时，就应该考虑异步化</p>
<p>1.用户等待时间有点长（要等AI生成）</p>
<p>2.业务服务器可能会有很多请求在处理，导致系统资源紧张，严重时导致服务器宕机或者无法处理新的请求</p>
<p>3.调用的第三方服务（AI能力）的处理能力是有限的，比如每3秒只能处理1个请求，会导致AI处理不过来，严重时AI可能会对拒绝服务后台系统</p>
<h3 id="异步化"><a href="#异步化" class="headerlink" title="异步化"></a>异步化</h3><p>同步：一件事情做完，再做另外一件事（烧水后处理工作）</p>
<p>异步：不用等一件事情做完，可以做另外一件事，等第一件事情完成时，可以收到一个通知，通知你这件事情做好了，可以再进行后续处理（烧水时，水壶有一个蜂鸣器：烧水时人可以同时工作。水烧好后人能听到声音，就知道水烧好了）</p>
<h4 id="业务流程分析"><a href="#业务流程分析" class="headerlink" title="业务流程分析"></a>业务流程分析</h4><p>1.当用户要进行耗时很长的操作时，点击提交后不需要在界面傻等，而是应该把这个任务保存在数据库中记录起来</p>
<p>2.用户执行新任务时</p>
<p>​	a.任务提交成功：</p>
<p>​		i.如果我们程序还有多余的空闲线程，可以立即去做这个任务</p>
<p>​		ii.如果线程都在繁忙，无法继续处理，那就放到等待队列中</p>
<p>​	b.任务提交失败：比如我们的程序所有线程都在忙，任务队列满了</p>
<p>​		i.拒绝掉这个任务，再也不执行</p>
<p>​		ii.通过保存到数据库中的记录来看到提交失败的任务，并且在程序空闲的时候，可以把任务从数据库中捞到程序中，再去执行</p>
<p>3.我们的程序（线程）从任务队列取出任务依次执行，每完成一件事情就要修改一下任务的状态</p>
<p>4.用户可以查询任务的执行状态，或者在任务执行成功或失败时得到通知（发邮件，系统消息提示，发邮件），从而优化体验</p>
<p>5.如果我们要执行的任务非常复杂，包含非常多的环节，在每一个小任务完成时，要在程序（数据库中）记录一下任务的执行状态（进度）</p>
<h5 id="智能BI实现标准异步化"><a href="#智能BI实现标准异步化" class="headerlink" title="智能BI实现标准异步化"></a>智能BI实现标准异步化</h5><p>系统业务流程</p>
<p>1.用户点击智能分析页提交按钮时，先把图表立刻保存到数据库中（作为一个任务）</p>
<p>2.用户可以在图表管理页查看所有图表（已生成的，生成中的，生成失败）的信息和状态</p>
<p>3.用户可以修改生成失败的图表信息，点击重新生成</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-11_17-45-21.png" alt="Snipaste_2024-02-11_17-45-21"></p>
<p>问题：</p>
<p>1.任务队列的最大容量应设置为多少？</p>
<p>2.程序怎么从任务队列中取出任务去执行？这个任务队列的流程怎么实现?怎么保证程序最多同时执行多少个任务?</p>
<h5 id="线程池的理论和实战"><a href="#线程池的理论和实战" class="headerlink" title="线程池的理论和实战"></a>线程池的理论和实战</h5><p>解决方法：线程池</p>
<p>为什么需要线程池</p>
<p>1.线程的管理比较复杂（什么时候新增线程，什么时候减少空闲线程）</p>
<p>2.任务存取比较复杂（什么时候接受任务，什么时候拒绝任务，怎么保证大家不抢到同一个任务）</p>
<p>线程池的作用：帮助你轻松管理线程，协调任务的执行过程</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-11_17-56-22.png" alt="Snipaste_2024-02-11_17-56-22"></p>
<h6 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h6><p>不用自己写，如果在Spring中，可以用ThreadPoolTaskExecutor配合@Async注解来实现。（不太建议）</p>
<p>如果是在java中，可以使用JUC并发编程包中的ThreadPoolExecutor来实现非常灵活的自定义线程池</p>
<h6 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<p>怎么确定线程池参数呢？结合实际情况（实际业务场景和系统资源）来测试调整，不断优化。</p>
<p>回归到我们的业务，要考虑系统最脆弱的环节（系统的瓶颈）在哪里？</p>
<p>为什么需要线程池：AI处理很慢</p>
<p>现有条件：比如AI生成能力的并发只允许4个任务同时去执行，AI能力允许20个任务排队</p>
<p>参数含义：</p>
<p>1.corePoolSize：（核心线程数&#x3D;&gt;正式员工）：<strong>正常情况</strong>下，我们的系统应该能同时工作的线程数（随时就绪的状态）</p>
<p>2.maximumPoolSize（最大线程数&#x3D;&gt;哪怕任务再多，你最多也要招这些人）：极限情况下，我们的线程池最多有多少个线程？</p>
<p>3.keepAliveTime（空闲线程存活时间）：非核心线程在没有任务的情况下，过多久要删除（理解为开除临时工），从而释放无用的线程资源</p>
<p>4.TimeUnit unit（空闲线程存活时间的单位）：分钟，秒</p>
<p>5.workQueue（阻塞队列）：用于存放给线程执行的任务，存在一个队列的长度（一定要设置，不要说队列长度无限，因为也会占用资源）</p>
<p>6.ThreadFactory（线程工厂）：控制线程的生成，线程的属性（比如线程名）</p>
<p>7.RejectedExecutionHandler（拒绝策略）：任务队列满的时候，采取什么策略，比如抛异常，不抛异常，自定义策略</p>
<p>tips：资源隔离队列：比如VIP任务一个队列，普通任务一个队列，保证这两个任务互不干扰</p>
<p><strong>线程池的工作机制</strong></p>
<p>刚开始：发现线程池的数量还没达到核心线程数，那么就直接执行到达的任务</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-11_19-37-50.png" alt="Snipaste_2024-02-11_19-37-50"></p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-11_19-37-55.png" alt="Snipaste_2024-02-11_19-37-55"></p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-11_19-37-59.png" alt="Snipaste_2024-02-11_19-37-59"></p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-11_19-38-04.png" alt="Snipaste_2024-02-11_19-38-04"></p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-11_19-38-10.png" alt="Snipaste_2024-02-11_19-38-10"></p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-11_19-38-16.png" alt="Snipaste_2024-02-11_19-38-16"></p>
<p><strong>线程池的参数如何设置？</strong></p>
<p>现有条件：比如AI生成能力的并发只允许4个任务同时去执行，AI能力允许20个任务排队</p>
<p>1.corePoolSize：（核心线程数&#x3D;&gt;正式员工）：<strong>正常情况</strong>下，可以设置为2-4</p>
<p>2.maximumPoolSize：设置为 &lt;&#x3D;4</p>
<p>3.keepAliveTime（空闲线程存活时间）：一般设置为秒级或者分钟级</p>
<p>4.TimeUnit unit（空闲线程存活时间的单位）：分钟，秒</p>
<p>5.workQueue（阻塞队列）：结合实际情况去设置，可以设置为20</p>
<p>6.ThreadFactory（线程工厂）：控制线程的生成，线程的属性（比如线程名）</p>
<p>7.RejectedExecutionHandler（拒绝策略）：抛异常，标记数据库的任务状态为“任务满了，已拒绝”</p>
<p>一般情况下：任务分为IO密集型和计算密集型两种</p>
<p>1.计算密集型：<strong>吃CPU</strong>，比如音视频处理，图像处理，数学计算等，一般是设置corePoolSize&#x3D;CPU核数+1</p>
<p>为什么还要加1？主线程或者让线程之间有一个协调的空余，可以让每个线程都能利用号CPU的每个核，而且线程之间不用频繁切换（减少打架，减少开销）</p>
<p>2.IO密集型：<strong>吃带宽&#x2F;硬盘&#x2F;内存的读写资源</strong>，corePoolSize可以设置大一点，一般经验值是2n左右，但是建议以IO的能力为主</p>
<h6 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h6><p>1.自定义线程池</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ThreadPoolExecutorConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ThreadPoolExecutor threadPoolExecutor()&#123;</span><br><span class="line">        ThreadFactory threadFactory = new ThreadFactory() &#123;</span><br><span class="line">            private int count = 1;</span><br><span class="line">            @Override</span><br><span class="line">            public Thread newThread(@NotNull Runnable r) &#123;</span><br><span class="line">                Thread thread = new Thread(r);</span><br><span class="line">                thread.setName(&quot;线程&quot;+count);</span><br><span class="line">                count++;</span><br><span class="line">                return thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2,4,100, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;&gt;(4),threadFactory);</span><br><span class="line">        return threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.指定线程池并且提交任务到线程池</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 队列测试</span><br><span class="line"> *</span><br><span class="line"> * @author &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="line"> * @from &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/queue&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class QueueController &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/add&quot;)</span><br><span class="line">    public void add(String name)&#123;</span><br><span class="line">        CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(&quot;任务执行中&quot;+ name+&quot;, 执行人&quot;+ Thread.currentThread().getName());</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(60000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,threadPoolExecutor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>3.在<a target="_blank" rel="noopener" href="http://localhost:8101/api/doc.html#/default/queue-controller/addUsingGET%E6%B5%8B%E8%AF%95">http://localhost:8101/api/doc.html#/default/queue-controller/addUsingGET测试</a></p>
<p>tips：测试的接口最好加上这个注解@Profile({“dev”,”local”})</p>
<h4 id="前端后端异步化改造"><a href="#前端后端异步化改造" class="headerlink" title="前端后端异步化改造"></a>前端后端异步化改造</h4><h5 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h5><p>系统业务流程</p>
<ol>
<li><p>给chart表增加任务状态字段(比如已完成，执行中，排队中，失败)，任务执行信息字段（用于记录任务执行中，或者失败的一些信息）</p>
</li>
<li><p>用户点击智能分析页提交按钮时，先把图表立刻保存到数据库中，然后提交任务</p>
</li>
<li><p>任务：先修改图表的任务状态为”执行中”。等执行成功后，修改为”已完成“。保存执行结果；执行失败后，修改状态为”失败”，记录任务失败的信息</p>
</li>
<li><p>用户可以在图表管理页查看所有图表（已生成的，生成中的，生成失败）的信息和状态</p>
</li>
<li><p>用户可以修改生成失败的图表信息，点击重新生成（todo）</p>
</li>
</ol>
<p><strong>优化点</strong></p>
<p>1.guava Retrying 重试</p>
<p>2.如果说任务根本没提交到队列中（或者队列满了），是不是可以用定时任务把失败状态的图表放到队列中（补偿）</p>
<p>3.建议给任务的执行增加一个超时时间，超时后自动标记为失败（超时控制）</p>
<p>4.当系统负载低，性能良好时用同步，性能差的时候用异步</p>
<p>5.提前考虑到AI生成错误的情况，在后端生成异常处理（比如A说了多余的话，I提取正确的字符串）</p>
<p>6.反向压力：动态调整线程池的线程数（找AI第三方确认（空闲则调高核心线程数，忙则调低核心线程数））</p>
<p>通过调用的服务状态来选择当前的系统的策略（比如根据AI服务的当前任务队列数来控制系统的核心线程数），<strong>从而最大化利用系统资源</strong></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/404993753">https://zhuanlan.zhihu.com/p/404993753</a></p>
<p>7.我的图表页面增加一个刷新，定时自动刷新的按钮，保证获取到图表的最新状态（前端轮询）</p>
<p>8.任务执行成功或失败，给用户发送实时消息通知（实时:websocket，server side event）</p>
<p>步骤</p>
<p>1.改造图表(新增字段)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 图表信息表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> chart</span><br><span class="line">(</span><br><span class="line">    status     <span class="type">varchar</span>(<span class="number">128</span>)                       <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;wait&#x27;</span> comment <span class="string">&#x27;wait,succeed,failed,running&#x27;</span>,</span><br><span class="line">    execMessage text                              <span class="keyword">null</span> comment <span class="string">&#x27;执行信息&#x27;</span>,</span><br><span class="line">) comment <span class="string">&#x27;图表信息表&#x27;</span> <span class="keyword">collate</span> <span class="operator">=</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>

<p>2.修改图表中的status字段的数据改为succeed</p>
<p>3.补充Chart字段</p>
<p>4.任务执行逻辑，并用线程池来执行任务</p>
<p>​	先修改任务状态为执行中，减少重复执行的风险，同时让用户知道执行状态</p>
<p>注意异常处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            //调用AI前更新一次数据库</span><br><span class="line">            //任务：先修改图表的任务状态为&quot;执行中&quot;。等执行成功后，修改为”已完成“。保存执行结果；执行失败后，修改状态为&quot;失败&quot;，记录任务失败的信息</span><br><span class="line">            Chart updateChart = new Chart();</span><br><span class="line">            updateChart.setId(chart.getId());</span><br><span class="line">            updateChart.setStatus(&quot;running&quot;);</span><br><span class="line">            boolean b = chartService.updateById(updateChart);</span><br><span class="line">            if (!b) &#123;</span><br><span class="line">                //todo 把状态放到数据库</span><br><span class="line">                handleChartUpdateError(chart.getId(),&quot;更新图表执行中状态失败&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //调用AI</span><br><span class="line">            String result = aiManager.doChat(biModeId, userInput.toString());</span><br><span class="line">            String[] splits = result.split(&quot;【【【【【&quot;);</span><br><span class="line">            if (splits.length &lt; 3) &#123;</span><br><span class="line">                handleChartUpdateError(chart.getId(),&quot;AI生成错误&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            String genChart = splits[1].trim();</span><br><span class="line">            String genResult = splits[2].trim();</span><br><span class="line">            //调用AI后再更新一次数据库</span><br><span class="line">            Chart updateChartResult = new Chart();</span><br><span class="line">            updateChartResult.setId(chart.getId());</span><br><span class="line">            updateChartResult.setGenChart(genChart);</span><br><span class="line">            updateChartResult.setGenResult(genResult);</span><br><span class="line">            updateChartResult.setStatus(&quot;succeed&quot;);</span><br><span class="line">            boolean updateResult = chartService.updateById(updateChartResult);</span><br><span class="line">            if (!updateResult) &#123;</span><br><span class="line">                //todo 把状态放到数据库</span><br><span class="line">                handleChartUpdateError(chart.getId(),&quot;更新图表成功状态失败&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,threadPoolExecutor);</span><br><span class="line"></span><br><span class="line">        BiResponse biResponse = new BiResponse();</span><br><span class="line">        biResponse.setChartId(chart.getId());</span><br><span class="line">        return ResultUtils.success(biResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void handleChartUpdateError(long chartId, String execMessage) &#123;</span><br><span class="line">    Chart updateChartResult = new Chart();</span><br><span class="line">    updateChartResult.setId(chartId);</span><br><span class="line">    updateChartResult.setExecMessage(&quot;execMessage&quot;);</span><br><span class="line">    boolean updateResult = chartService.updateById(updateChartResult);</span><br><span class="line">    if (!updateResult) &#123;</span><br><span class="line">        log.error(&quot;更新图表失败状态失败&quot; + chartId + &quot;,&quot; + execMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>1.复制一个异步创建图表页面</p>
<p>2.修改异步页面的调用接口为异步的接口</p>
<p>3.移除无用元素和变量</p>
<p>4.修改成功后的操作，比如提示语和重置表单</p>
<p>5.调整我的图表页面，补充错误处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    item.status === &#x27;wait&#x27; &amp;&amp; &lt;&gt;</span><br><span class="line">      &lt;Result</span><br><span class="line">        status=&quot;warning&quot;</span><br><span class="line">        title=&quot;图表待生成&quot;</span><br><span class="line">        subTitle=&#123;item.execMessage ?? &#x27;当前图表生成繁忙，请耐心等候&#x27;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    item.status === &#x27;running&#x27; &amp;&amp; &lt;&gt;</span><br><span class="line">      &lt;Result</span><br><span class="line">        status=&quot;info&quot;</span><br><span class="line">        title=&quot;图表生成中&quot;</span><br><span class="line">        subTitle=&#123;item.execMessage&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#123;</span><br><span class="line">  item.status === &#x27;succeed&#x27; &amp;&amp; &lt;&gt;</span><br><span class="line">    &lt;div style=&#123;&#123;marginBottom: 16&#125;&#125;/&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#x27;分析图表目标: &#x27; + item.goal&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div style=&#123;&#123;marginBottom: 16&#125;&#125;/&gt;</span><br><span class="line">    &lt;ReactECharts option=&#123;JSON.parse(item.genChart ?? &#x27;&#123;&#125;&#x27;)&#125;/&gt;&lt;/&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  item.status === &#x27;failed&#x27; &amp;&amp; &lt;&gt;</span><br><span class="line">    &lt;Result</span><br><span class="line">      status=&quot;error&quot;</span><br><span class="line">      title=&quot;图表生成错误&quot;</span><br><span class="line">      subTitle=&#123;item.execMessage&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/&gt;</span><br></pre></td></tr></table></figure>

<p>6.调整图表的查询顺序，按照创建时间降序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const initSearchParams = &#123;</span><br><span class="line">  current: 1,</span><br><span class="line">  pageSize: 1,</span><br><span class="line">  sortField: &#x27;createTime&#x27;,</span><br><span class="line">  sortOrder: &#x27;desc&#x27;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="5-消息队列"><a href="#5-消息队列" class="headerlink" title="5.消息队列"></a>5.消息队列</h3><p>1.分析系统现在的不足</p>
<p>2.分布式消息队列</p>
<p>3.分布式消息队列RabbitMQ入门实战</p>
<p>4.项目扩展</p>
<hr>
<h4 id="分析系统现在的不足（单机系统的问题）"><a href="#分析系统现在的不足（单机系统的问题）" class="headerlink" title="分析系统现在的不足（单机系统的问题）"></a>分析系统现在的不足（单机系统的问题）</h4><p>现状：目前的异步是通过本地的线程池实现的</p>
<p>1.无法集中限制，只能单机限制</p>
<p>​	假如AI服务限制只能2个用户同时使用，单个线程池也可以设置最大核心线程数为2来实现。</p>
<p>​	假如系统用量增大，改为分布式，多台服务器，每个服务器都要有两个线程，就可能有2N个线程，超过了AI服务的限制</p>
<p>解决方案：在一个集中的地方（例如：redis公共状态管理）去管理下发任务（比如集中存储当前正在执行的任务数）</p>
<p>2.任务由于是放在内存中执行，可能会丢失</p>
<p>虽然可以人工从数据库中捞出来再重试，但是其实需要额外开发（比如定时任务），这种重试的场景其实非常典型的，其实不需要我们开发者过于关心，或者自己实现的</p>
<p>解决方案：把任务放在一个可以持久化存储的硬盘</p>
<p>3.优化，如果你的系统功能越来越多，长耗时任务越来越多，系统会越来越复杂（比如开多个线程池，资源可能会出现相互抢占）</p>
<p>服务拆分（应用解耦）：可以把长耗时，消耗很多的任务把它单独抽成一个程序，不影响主业务</p>
<p>解决方案：可以有一个中间人，让中间人帮我们连接两个系统（比如核心系统和智能生成业务）</p>
<h4 id="分布式消息队列"><a href="#分布式消息队列" class="headerlink" title="分布式消息队列"></a>分布式消息队列</h4><h5 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h5><p>开发多个系统和应用时，可以帮助我们连接多个系统，让多个系统可以紧密配合的技术（或者组件）</p>
<p>比如：Redis、消息队列、分布式存储Etcd</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_19-44-31.png" alt="Snipaste_2024-02-12_19-44-31"></p>
<h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><p>存储消息的队列</p>
<p>关键词：存储，消息，队列</p>
<p>存储：存数据</p>
<p>消息：某种数据结构，比如字符串，对象二进制数据，json等等</p>
<p>队列：先进先出的数据结构</p>
<p><strong>消息队列是特殊的数据库</strong></p>
<p>应用场景（作用）：<strong>在多个不同的系统中，应用之间实现消息的传输</strong>（也可以存储）。不需要考虑传输应用的编程语言、系统、框架等等</p>
<p>可以让java开发的应用发消息，让php开发的应用接收消息，这样就可以不用吧所有代码写到同一个项目里（应用解耦）</p>
<h5 id="消息队列的模型"><a href="#消息队列的模型" class="headerlink" title="消息队列的模型"></a>消息队列的模型</h5><p>生产者：Producer,类比快递员，发送消息的人（客户端）</p>
<p>消费者：Consumer,类比取快递的人，接收消息的人（客户端）</p>
<p>消息：Message,类比快递，就是生产者给消费者的数据</p>
<p>消息队列:Queue</p>
<p>为什么不接传输，要用消息队列？生产者不关心消费者要不要消费，什么时候消费，只要把东西给消息队列，工作就算完成</p>
<p>生产者和消费者解耦，互不影响</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_20-02-11.png" alt="Snipaste_2024-02-12_20-02-11"></p>
<h5 id="为什么用消息队列"><a href="#为什么用消息队列" class="headerlink" title="为什么用消息队列"></a>为什么用消息队列</h5><p>1.异步处理</p>
<p>生产者发送完消息后，可以继续去忙别的，消费者想什么时候都可以取，不会产生阻塞</p>
<p>2.削峰填谷</p>
<p>先把用户请求放到消息队列中，消费者（实际执行操作的应用）可以按照自己的需求，慢慢去取</p>
<p>原本：12点时来了10万个请求，在原本情况下，10万个请求都在系统内部立即处理，很快系统压力过大就宕机了</p>
<p>现在：把这10万个请求放到消息队列中，处理系统以自己恒定的速率（比如每秒一个）慢慢执行，从而保护系统，稳定处理</p>
<p>3.发布订阅</p>
<h5 id="分布式消息队列的优势"><a href="#分布式消息队列的优势" class="headerlink" title="分布式消息队列的优势"></a>分布式消息队列的优势</h5><p>1.数据持久化：它可以把消息集中存储到硬盘中，服务器重启就不会丢</p>
<p>2.可扩展性：根据需求，随时增加（或减少）结点，继续保持稳定的服务</p>
<p>3.应用解耦：可以连接各个不同语言、框架开发的系统，让这些系统能够灵活的传输读取数据</p>
<p><strong>应用解耦的优点</strong></p>
<p>以前，把所有功能都放到同一项目中，调用多个子功能，一个环节错，系统就整体出错</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_20-15-34.png" alt="Snipaste_2024-02-12_20-15-34"></p>
<p>使用消息队列进行解耦：</p>
<p>1.一个系统挂了，不影响另一个系统。</p>
<p>2.假设发货系统挂了，但是当发货系统复活后，依旧可以从发货系统中取消息，系统不会出问题</p>
<p>3.只要发送消息到队列，就可以立刻返回，不用同步调用所有系统，性能更高</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_20-19-04.png" alt="Snipaste_2024-02-12_20-19-04"></p>
<p>4.订阅发布</p>
<p> 如果一个非常大的系统要给其他子系统发送通知，最简单直接的方式是大系统直接依次调用小系统</p>
<p>问题</p>
<p>1.每次发送通知都要调用很多系统，很麻烦，有可能失败</p>
<p>2.新出现的项目（或者说大项目感知不到的项目）无法得到通知</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_20-37-59.png" alt="Snipaste_2024-02-12_20-37-59"></p>
<p>解决方案：大的核心系统始终往一个地方（消息队列）去发送消息，其他的系统都去订阅这个消息队列（读取消息队列中的消息）</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_20-38-59.png" alt="Snipaste_2024-02-12_20-38-59"></p>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>1.耗时的场景</p>
<p>2.高并发的场景（异步，削峰填谷）</p>
<p>3.分布式系统协作（尤其是跨团队、跨业务协作，应用解耦）</p>
<p>4.强稳定性的场景（比如金融业务，持久化，可靠性，削峰填谷）</p>
<h5 id="消息队列的缺点"><a href="#消息队列的缺点" class="headerlink" title="消息队列的缺点"></a>消息队列的缺点</h5><p>要给系统引入额外的中间件，系统会更复杂，额外维护中间件，额外的费用（部署）成本</p>
<p>消息队列：消息丢失、顺序性、重复消费、数据的一致性（分布式系统就要考虑）</p>
<h4 id="主流消息队列选型"><a href="#主流消息队列选型" class="headerlink" title="主流消息队列选型"></a>主流消息队列选型</h4><h5 id="主流技术"><a href="#主流技术" class="headerlink" title="主流技术"></a>主流技术</h5><p>1.arctivemq</p>
<p>2.rabbitmq</p>
<p>3.kafka</p>
<p>4.rocketmq</p>
<p>5.zeromq</p>
<p>6.pulsar（云原生）</p>
<p>7.Apache InLong(Tube)</p>
<h5 id="技术对比"><a href="#技术对比" class="headerlink" title="技术对比"></a>技术对比</h5><p>技术选型指标</p>
<p>​	吞吐量：IO,并发</p>
<p>​	时效性：类似延迟，消息的发送，到达时间</p>
<table>
<thead>
<tr>
<th>技术名称</th>
<th>吞吐量</th>
<th>时效性</th>
<th>可用性</th>
<th>可靠性</th>
<th>优势</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>arctivemq</td>
<td>万级</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>简单易学</td>
<td>中小型企业，项目</td>
</tr>
<tr>
<td>rabbitmq</td>
<td>万级</td>
<td>极高（微妙）</td>
<td>高</td>
<td>高</td>
<td>生态好（基本什么语言都支持），时效性高，易学</td>
<td>适合绝大多数分布式的应用，这也是先学它的原因</td>
</tr>
<tr>
<td>kafka</td>
<td>十万级</td>
<td>高（毫秒以内）</td>
<td>极高</td>
<td>极高</td>
<td>吞吐量大，可靠性，可用性，强大的数据流处理能力</td>
<td>适合于<strong>大规模处理数据</strong>的场景，比如构建日志收集系统，实时数据流传输，事件数据流传输</td>
</tr>
<tr>
<td>rocketmq</td>
<td>十万级</td>
<td>高（ms）</td>
<td>极高</td>
<td>极高</td>
<td>吞吐量大，可靠性，可用性，可扩展性高</td>
<td>适用于<strong>金融</strong>、电商等对可靠性要求较高的场景，适合大规模的消息处理</td>
</tr>
<tr>
<td>pulsar</td>
<td>十万级</td>
<td>高（ms）</td>
<td>极高</td>
<td>极高</td>
<td>可靠性，可用性，基于发布订阅模式 ，新兴（技术架构先进）</td>
<td>适合大规模，高并发的分布式系统（云原生）。适合实时分析，事件流处理，IoT物联网数据处理等</td>
</tr>
</tbody></table>
<h4 id="RabbitMQ入门实战"><a href="#RabbitMQ入门实战" class="headerlink" title="RabbitMQ入门实战"></a>RabbitMQ入门实战</h4><p>官方网站：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></p>
<p>特点：⽣态好，好学习、易于理解，时效性强，⽀特很多不同语⾔的客户端，扩展性、可⽤性都很不错。学习性价⽐⾮常⾼的消息队列，适⽤于绝⼤多数中⼩规模分布式系统。</p>
<h6 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h6><p>AMQP协议</p>
<p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">https://www.rabbitmq.com/tutorials/amqp-concepts.html</a></p>
<p>⽣产者(Publisher)：发消息到某个交换机 </p>
<p>消费者(Consumer)：从某个队列中取消息</p>
<p> 交换机(Exchange)：负责把消息转发到对应的队列 队列(Queue)：存储消息的 </p>
<p>路由(Routes)：转发，就是怎么把消息从⼀个地⽅转到另⼀个地⽅（⽐如从⽣产 者转发到某个队列）</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_21-59-49.png" alt="Snipaste_2024-02-12_21-59-49"></p>
<p>安装：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/#getstarted">https://www.rabbitmq.com/#getstarted</a></p>
<p>1.先安装erlang25.3.2（因为RabbitMq依赖erlang）,这个语言的性能非常高</p>
<p>erlang下载：<a target="_blank" rel="noopener" href="https://www.erlang.org/patches/otp-25.3.2">https://www.erlang.org/patches/otp-25.3.2</a></p>
<p>2.安装完erlang后，安装rabbitmq即可</p>
<p>command+r打开services.msc服务菜单，查看rabbitmq服务是都已启动</p>
<p>3.安装rabbitmq监控面板</p>
<p>在rabbitmq安装目录的sbin中执行下述脚本</p>
<p>rabbitmq-plugins.bat enable rabbitmq_management</p>
<p>4.打开<a target="_blank" rel="noopener" href="http://localhost:15672/">http://localhost:15672/</a></p>
<p>默认的⽤户名和密码是”guest”</p>
<p>tips：如果想要在远程服务器安装访问rabbitmq管理面板，你要自己创建一个管理员账户，不能用默认的guest，否则会被拦截（官方出于安全考虑）</p>
<p>如果被拦截，可以自己创建管理员用户：</p>
<p>参考文档：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/access-control.html">https://www.rabbitmq.com/access-control.html</a></p>
<p>rabbitmq端口占用</p>
<p>5672：程序连接的端口</p>
<p>15672：webUI</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_22-45-17.png" alt="Snipaste_2024-02-12_22-45-17"></p>
<h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>MQ官方教程</p>
<p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/#getstarted">https://www.rabbitmq.com/#getstarted</a></p>
<p>⼀个⽣产者给⼀个队列发送消息，⼀个消费者从这个队列中获取到消息。1 对 1 关 系</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_22-56-03.png" alt="Snipaste_2024-02-12_22-56-03"></p>
<p>1.引⼊ Rabbit MQ 组件依赖</p>
<p><a target="_blank" rel="noopener" href="https://mvnrepository.com/%E6%90%9Camqp-client">https://mvnrepository.com/搜amqp-client</a></p>
<!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client -->
<dependency>
    <groupId>com.rabbitmq</groupId>
    <artifactId>amqp-client</artifactId>
    <version>5.20.0</version>
</dependency>



<p>之前命令行启动的是消息队列本身，但是少了生成者和消费者，所以需要自己定义</p>
<h5 id="单消费者"><a href="#单消费者" class="headerlink" title="单消费者"></a>单消费者</h5><p>生产者代码</p>
<pre><code>import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.nio.charset.StandardCharsets;

public class Send &#123;
private final static String QUEUE_NAME = &quot;hello&quot;;

public static void main(String[] argv) throws Exception &#123;
    ConnectionFactory factory = new ConnectionFactory();
    factory.setHost(&quot;localhost&quot;);
    try (Connection connection = factory.newConnection();
         Channel channel = connection.createChannel()) &#123;
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        String message = &quot;Hello World!&quot;;
        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes(StandardCharsets.UTF_8));
        System.out.println(&quot; [x] Sent &#39;&quot; + message + &quot;&#39;&quot;);
    &#125;
&#125;
&#125;
</code></pre>
<p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recv</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Channel频道：理解为操作消息队列的client（比如jdbcClient,redisClient）,提供了和消息队列server建立通信的传输方法（为了复用链接，提高传输效率）.程序通过channel操作rabbitmq(收发消息)</p>
<p>创建消息队列：</p>
<p>参数：</p>
<p>queueName：消息队列名称（注意，同名称的消息队列，只能⽤同样的参数创建⼀次）</p>
<p>durabale：消息队列重启后，消息是否丢失，持久化处理</p>
<p>exclusive：是否只允许当前这个创建消息队列的连接操作消息队列</p>
<p>autoDelete：没有⼈⽤队列后，是否要删除队列</p>
<p>测试：单消费者</p>
<hr>
<p>demo：</p>
<p>生产者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SingleProducer &#123;</span><br><span class="line">private final static String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    //创建链接工厂</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">//    factory.setUsername();</span><br><span class="line">//    factory.setPassword();</span><br><span class="line">//    factory.setPort();</span><br><span class="line">    //建立链接，创建频道</span><br><span class="line">    try (Connection connection = factory.newConnection();</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line">        //创建消息队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">        //发送消息</span><br><span class="line">        String message = &quot;Hello World!&quot;;</span><br><span class="line">        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SingleConsumer &#123;</span><br><span class="line">private final static String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    //创建链接</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    //创建消息队列，为了保证队列一定是存在的</span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">    System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class="line"></span><br><span class="line">    //定义了如何处理消息</span><br><span class="line">    DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        String message = new String(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(&quot; [x] Received &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    //消费消息，会持续阻塞。autoAck参数表示参数取出来后就是表示自动完成消费了</span><br><span class="line">    channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_07-20-47.png" alt="Snipaste_2024-02-13_07-20-47"></p>
<hr>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_07-31-33.png" alt="Snipaste_2024-02-13_07-31-33"></p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_07-33-24.png" alt="Snipaste_2024-02-13_07-33-24"></p>
<h5 id="多消费者"><a href="#多消费者" class="headerlink" title="多消费者"></a>多消费者</h5><p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/tutorials/tutorial-two-java.html">https://www.rabbitmq.com/tutorials/tutorial-two-java.html</a></p>
<p>场景：多个机器接收并处理任务（尤其是每个机器处理能力有限）</p>
<p>一个生产者给一个队列发消息，多个消费者从这个队列取消息。一对多</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_07-36-50.png" alt="Snipaste_2024-02-13_07-36-50"></p>
<p><strong>1.队列持久化</strong></p>
<p>durable参数设置为true:服务器重启后队列不丢失</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(TASK_QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>



<p><strong>2.消息持久化</strong></p>
<p>指定参数：MessageProperties.PERSISTENT_TEXT_PLAIN</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME,</span><br><span class="line">        MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">        message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>



<p>生产者代码</p>
<p>使用Scanner接收用户输入，便于发送多条消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class MultiProducer &#123;</span><br><span class="line"></span><br><span class="line">  private static final String TASK_QUEUE_NAME = &quot;multi_queue&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    try (Connection connection = factory.newConnection();</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext())&#123;</span><br><span class="line">            String message = scanner.nextLine();</span><br><span class="line">            channel.basicPublish(&quot;&quot;, TASK_QUEUE_NAME,</span><br><span class="line">                    MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">                    message.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">            System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>控制单个消费者的处理任务积压数：</strong></p>
<p>每个消费者最多同时处理1个任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<p><strong>消息确认机制</strong></p>
<p>为了保证消息成功被消费（快递成功被取走），rabbitmq提供了消息确认机制，当消费者接收到消息后，必须要给一个反馈</p>
<p>​	ack:消费成功</p>
<p>​	nack:消费失败</p>
<p>​	reject:拒绝</p>
<p>如果告诉rabbitmq服务器消费成功，服务器才会放心地移除消息</p>
<p>支持配置autoack,会自动执行ack命令，相当于接收到消息立刻就成功了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicConsume(TASK_QUEUE_NAME, false, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure>

<p>但是如果我们接收消息的工作没有完成那么就不需要接收成功了</p>
<p>所以实际情况下autoack要改为false，根据实际情况手动确认</p>
<p><strong>指定确认某条消息：</strong></p>
<p>basicAck的第二个参数multiple（批量确认）：是否要一次性确认所有的历史消息直到当前这条</p>
<p>​	true:把之前每确认的消息都确认了（如果服务器希望把以前失败的都改为true）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);</span><br></pre></td></tr></table></figure>



<p><strong>指定拒绝某条消息</strong></p>
<p>basicNack的第二个参数multiple（批量拒绝）</p>
<p>第三个参数requeue:是否把参数再重新放回消息队列里，可用于重试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicNack(delivery.getEnvelope().getDeliveryTag(),false,false);</span><br></pre></td></tr></table></figure>



<p>消费者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class MutiConsumer &#123;</span><br><span class="line"></span><br><span class="line">  private static final String TASK_QUEUE_NAME = &quot;multi_queue&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">      //建立链接</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    final Connection connection = factory.newConnection();</span><br><span class="line">      for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">          final Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">          channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null);</span><br><span class="line">          System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class="line"></span><br><span class="line">          channel.basicQos(1);</span><br><span class="line"></span><br><span class="line">          //定义了如何处理消息</span><br><span class="line">          int finalI = i;</span><br><span class="line">          DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">              String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              try &#123;</span><br><span class="line">                  //处理工作</span><br><span class="line">                  System.out.println(&quot; [x] Received &#x27;&quot; +&quot;编号&quot;+ finalI +&quot;:&quot;+ message + &quot;&#x27;&quot;);</span><br><span class="line">                  channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);</span><br><span class="line">                  //停20秒，模拟机器处理能力有限</span><br><span class="line">                  Thread.sleep(20000);</span><br><span class="line">              &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">                  channel.basicNack(delivery.getEnvelope().getDeliveryTag(),false,false);</span><br><span class="line"></span><br><span class="line">              &#125; finally &#123;</span><br><span class="line">                  System.out.println(&quot; [x] Done&quot;);</span><br><span class="line">                  channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">          //开启消费监听</span><br><span class="line">          channel.basicConsume(TASK_QUEUE_NAME, false, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2个小技巧</p>
<p>​	1.使用Scanner接收用户输入，便于快速发送多条消息</p>
<p>​	2.使用for循环创建多个消费者，便于快速验证队列模型工作机制</p>
<h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>场景：多个机器接收并处理任务（尤其是每个机器处理能力有限）</p>
<p>一个生产者给多个队列发消息，一个生产者对多个队列</p>
<p>教程</p>
<p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/tutorials/tutorial-three-java.html">https://www.rabbitmq.com/tutorials/tutorial-three-java.html</a></p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_08-49-53.png" alt="Snipaste_2024-02-13_08-49-53"></p>
<p>交换机的作用：负责把快递发送到对应的快递站，类似于网络路由器，提供转发功能</p>
<p>解决的问题：怎么把消息转发到不同的队列上。好让消费者从不同的队列消费</p>
<p>绑定：交换机和队列关联起来，也可以叫路由，算是一个算法或转发策略</p>
<p>绑定代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel1.queueBind(queueName, EXCHANGE_NAME, &quot;绑定规则&quot;);</span><br></pre></td></tr></table></figure>



<h5 id="交换机有多种类别"><a href="#交换机有多种类别" class="headerlink" title="交换机有多种类别"></a>交换机有多种类别</h5><p>1.fanout:扇出，广播</p>
<p>场景：很适用于发布订阅的场景，写日志，可以多个系统间共享</p>
<p>特点：消息会被转发到所有绑定到该交换机的队列</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_08-49-53.png" alt="Snipaste_2024-02-13_08-49-53"></p>
<p>示例场景</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_09-05-28.png" alt="Snipaste_2024-02-13_09-05-28"></p>
<p>生产者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class FanoutProducer &#123;</span><br><span class="line"></span><br><span class="line">  private static final String EXCHANGE_NAME = &quot;fanout-exchange&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    try (Connection connection = factory.newConnection();</span><br><span class="line">         //建立链接</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line">        //创建交换机</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext())&#123;</span><br><span class="line">            String message = scanner.nextLine();</span><br><span class="line">            //参数：1.交换机的名称，2.路由规则</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">            System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码</p>
<p>注意：</p>
<p>1.消费者和生产者要绑定同一个交换机</p>
<p>2.要先有队列，才能绑定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class FanoutConsumer &#123;</span><br><span class="line">  private static final String EXCHANGE_NAME = &quot;fanout-exchange&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel1 = connection.createChannel();</span><br><span class="line">    Channel channel2 = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    //声明交换机</span><br><span class="line">    channel1.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);</span><br><span class="line">    //创建小王队列，没有指定队列时随机分配一个队列名称</span><br><span class="line">    String queueName =&quot;小王的工作队列&quot;;</span><br><span class="line">    channel1.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">    //绑定队列</span><br><span class="line">    channel1.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    //创建小李队列</span><br><span class="line">    String queueName2 = &quot;小李的工作队列&quot;;</span><br><span class="line">    channel2.queueDeclare(queueName2, true, false, false, null);</span><br><span class="line">    //绑定队列</span><br><span class="line">    channel2.queueBind(queueName2, EXCHANGE_NAME, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class="line"></span><br><span class="line">    //小王小李的处理流程</span><br><span class="line">    DeliverCallback deliverCallback1 = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">        System.out.println(&quot; [小王] Received &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    DeliverCallback deliverCallback2 = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">      String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">      System.out.println(&quot; [小李] Received &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    channel1.basicConsume(queueName, true, deliverCallback1, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    channel2.basicConsume(queueName2, true, deliverCallback2, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：所有的消费者都能收到消息</p>
<h5 id="Direct交换机"><a href="#Direct交换机" class="headerlink" title="Direct交换机"></a>Direct交换机</h5><p>官方教程：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/tutorials/tutorial-four-java.html">https://www.rabbitmq.com/tutorials/tutorial-four-java.html</a></p>
<p>在fanout交换机的基础上加了<strong>转发规则</strong></p>
<p>交换机：相当于路由表（知道所有转发规则）</p>
<p>绑定：可以让交换机和队列进行关联，可以指定交换机把什么样的消息发送给哪个队列（类似于计算机网络中，两个路由器，或者网络设备相互连接，也可以理解为网线）</p>
<p>routekey：路由键，指定消息转发给哪个队列（ip地址）</p>
<p>特点：消息会根据路由键转发到指定的队列（但一个路由键可以绑定多个队列）</p>
<p>场景：特定的消息只交给特定系统（程序）来处理</p>
<p>绑定关系：完全匹配字符串</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_10-18-32.png" alt="Snipaste_2024-02-13_10-18-32"></p>
<p>比如发日志的场景，希望用独立的程序来处理不同级别的日志，比如C1系统处理error日志，C2系统处理其他级别的日志</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_10-27-55.png" alt="Snipaste_2024-02-13_10-27-55"></p>
<p>示例场景</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_10-25-46.png" alt="Snipaste_2024-02-13_10-25-46"></p>
<p>生产者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class DirectProducer &#123;</span><br><span class="line"></span><br><span class="line">  private static final String EXCHANGE_NAME = &quot;direct_exchange&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    try (Connection connection = factory.newConnection();</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext())&#123;</span><br><span class="line">            String userInput = scanner.nextLine();</span><br><span class="line">            String[] strings = userInput.split(&quot; &quot;);</span><br><span class="line">            if (strings.length &lt; 1)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            String message = strings[0];</span><br><span class="line">            String routeKey = strings[1];</span><br><span class="line">            //参数：1.交换机的名称，2.路由规则</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, routeKey, null, message.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">            System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;with routing&quot; + routeKey + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class DirectConsumer &#123;</span><br><span class="line"></span><br><span class="line">  private static final String EXCHANGE_NAME = &quot;direct_exchange&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);</span><br><span class="line"></span><br><span class="line">    //创建小zhao队列，没有指定队列时随机分配一个队列名称</span><br><span class="line">     String queueName =&quot;小zhao的工作队列&quot;;</span><br><span class="line">    channel.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">    //绑定队列</span><br><span class="line">    channel.queueBind(queueName, EXCHANGE_NAME, &quot;小zhao&quot;);</span><br><span class="line"></span><br><span class="line">    //创建小ling队列，没有指定队列时随机分配一个队列名称</span><br><span class="line">     String queueName2 =&quot;小ling的工作队列&quot;;</span><br><span class="line">    channel.queueDeclare(queueName2, true, false, false, null);</span><br><span class="line">    //绑定队列</span><br><span class="line">    channel.queueBind(queueName2, EXCHANGE_NAME, &quot;小ling&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class="line"></span><br><span class="line">    DeliverCallback xiaozhaoDeliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">        System.out.println(&quot; [xiaozhao] Received &#x27;&quot; +</span><br><span class="line">            delivery.getEnvelope().getRoutingKey() + &quot;&#x27;:&#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">      DeliverCallback xiaolingDeliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">          String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">          System.out.println(&quot; [xiaoling] Received &#x27;&quot; +</span><br><span class="line">                  delivery.getEnvelope().getRoutingKey() + &quot;&#x27;:&#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">    channel.basicConsume(queueName, true, xiaozhaoDeliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    channel.basicConsume(queueName, true, xiaolingDeliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="topic交换机"><a href="#topic交换机" class="headerlink" title="topic交换机"></a>topic交换机</h5><p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/tutorials/tutorial-five-java.html">https://www.rabbitmq.com/tutorials/tutorial-five-java.html</a></p>
<p>特点：消息会根据一个<strong>模糊的</strong>路由键转发到指定的队列（可以是一个或多个队列）</p>
<p>场景：特定的一类消息可以交给特定的一类系统（程序）来处理</p>
<p>绑定关系：可以模糊匹配多个绑定</p>
<ol>
<li><p>* ：匹配⼀个单词，⽐如 *.shier ，那么 a.shier 、 b.shier 都能匹配</p>
</li>
<li><p># ：匹配 0 个或多个单词，⽐如 a.# ，那么 a.a 、 a.b 、 a.a.a 都匹配 </p>
<p>#.a.# 可以匹配 a.b 、 a1.a 等形式 a 的前⾯可以是 0 个或多个字符串，后⾯也是 0 个或者多个字符串</p>
<p>注意，这⾥的匹配和 MySQL 的 like 的 % 不⼀祥，只按照单词来匹配，每 个 ‘.’ 分隔单词，如果是 ‘#.’ ，其实可以忽略，匹配 0 个词可以的</p>
</li>
</ol>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_11-08-38.png" alt="Snipaste_2024-02-13_11-08-38"></p>
<p>应用场景：</p>
<p>老板下发一个任务，让多个组来处理</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_11-55-09.png" alt="Snipaste_2024-02-13_11-55-09"></p>
<p>生产者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TopicProducer &#123;</span><br><span class="line"></span><br><span class="line">  private static final String EXCHANGE_NAME = &quot;topic_exchange&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    try (Connection connection = factory.newConnection();</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext())&#123;</span><br><span class="line">            String userInput = scanner.nextLine();</span><br><span class="line">            String[] strings = userInput.split(&quot; &quot;);</span><br><span class="line">            if (strings.length &lt; 1)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            String message = strings[0];</span><br><span class="line">            String routeKey = strings[1];</span><br><span class="line">            //参数：1.交换机的名称，2.路由规则</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, routeKey, null, message.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">            System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;with routing&quot; + routeKey + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class TopicConsumer &#123;</span><br><span class="line"></span><br><span class="line">  private static final String EXCHANGE_NAME = &quot;topic_exchange&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;);</span><br><span class="line"></span><br><span class="line">      //创建前端队列</span><br><span class="line">      String queueName =&quot;frontend_queue&quot;;</span><br><span class="line">      channel.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">      //绑定队列</span><br><span class="line">      channel.queueBind(queueName, EXCHANGE_NAME, &quot;#.前端.#&quot;);</span><br><span class="line"></span><br><span class="line">      //创建后端队列</span><br><span class="line">      String queueName2 =&quot;backend_queue&quot;;</span><br><span class="line">      channel.queueDeclare(queueName2, true, false, false, null);</span><br><span class="line">      //绑定队列</span><br><span class="line">      channel.queueBind(queueName2, EXCHANGE_NAME, &quot;#.后端.#&quot;);</span><br><span class="line"></span><br><span class="line">      //创建产品队列</span><br><span class="line">      String queueName3 =&quot;product_queue&quot;;</span><br><span class="line">      channel.queueDeclare(queueName3, true, false, false, null);</span><br><span class="line">      //绑定队列</span><br><span class="line">      channel.queueBind(queueName3, EXCHANGE_NAME, &quot;#.产品.#&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class="line"></span><br><span class="line">      DeliverCallback xiaoADeliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">          String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">          System.out.println(&quot; [xiaozhao] Received &#x27;&quot; +</span><br><span class="line">                  delivery.getEnvelope().getRoutingKey() + &quot;&#x27;:&#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">      &#125;;</span><br><span class="line">      DeliverCallback xiaoBDeliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">          String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">          System.out.println(&quot; [xiaoling] Received &#x27;&quot; +</span><br><span class="line">                  delivery.getEnvelope().getRoutingKey() + &quot;&#x27;:&#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      DeliverCallback xiaoCDeliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">          String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">          System.out.println(&quot; [xiaoling] Received &#x27;&quot; +</span><br><span class="line">                  delivery.getEnvelope().getRoutingKey() + &quot;&#x27;:&#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      channel.basicConsume(queueName, true, xiaoADeliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">      channel.basicConsume(queueName, true, xiaoBDeliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">      channel.basicConsume(queueName, true, xiaoCDeliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Headers交换机"><a href="#Headers交换机" class="headerlink" title="Headers交换机"></a>Headers交换机</h5><p>类似Topic交换机和Direct交换机，可以根据headers中的内容来指定发送到哪个队列</p>
<p>由于性能差，比较复杂，一般不推荐使用</p>
<h5 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h5><p>支持消息队列来模拟RPC的调用，但是一般没必要，直接用Dubbo,GRPC等RPC框架就好</p>
<p>就好比redis模拟消息队列，其实没必要，redis的应用场景就是做缓存或者分布式存储</p>
<p>实现一个场景总有更合适的、更专注的技术</p>
<p>AI学习连环问：是什么？有什么用？什么应用场景下会用？有什么优缺点？有没有示例代码？</p>
<h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h4><h5 id="消息过期机制"><a href="#消息过期机制" class="headerlink" title="消息过期机制"></a>消息过期机制</h5><p>官方文档：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/ttl.html">https://www.rabbitmq.com/ttl.html</a></p>
<p>可以给每条消息指定⼀个有效期，⼀段时间内未被消费者处理，就过期了。</p>
<p>示例场景： </p>
<p>消费者（库存系统）挂了，⼀个订单 15 分钟还没被库存系统处理，这个订单其 实已经失效了，哪怕库存系统再恢复，其实也不⽤扣减库存。 假设⼀个⽤户向⼀个新系统发送了⼀个请求，⽐如⽀付订单。订单通常有⼀个有 效期限，⽐如 15 分钟。如果在这 15 分钟内，下游系统没有及时处理该订单，这 可能意味着下游系统出现了故障，或者在这个时间段内不再需要处理该订单了。 在这种情况下，如果将该消息放⼊队列中，并设置了 15 分钟的过期时间，那么 如果 15 分钟后还没有消费者来获取该消息，该⽀付订单消息就会过期。订单在 15 分钟内没有⽀付，那么该订单就已经失效了。下游系统就不再需要处理这个订 单，也不需要更新库存或处理物流等相关操作。因此，消息过期机制⾮常适⽤于 这种过期场景的处理。通过设置合适的过期时间，可以确保及时清理⽆效的消 息，提⾼系统的效率和准确性。</p>
<p>适⽤场景：清理过期数据、模拟延迟队列的实现（不开会员就慢速）、专⻔让某个程 序处理过期请求</p>
<ol>
<li><p>订单超时取消：在电商平台中，可以设置订单的过期时间，如果⽤户在规定时间 内未⽀付订单，则将订单标记为过期取消。</p>
</li>
<li><p>预约失效处理：在医院或美容院等场所，⽤户预约服务后，可以设置预约消息的 过期时间，如果⽤户在规定时间内未到达，可以取消预约或释放时间。</p>
</li>
<li><p>缓存更新和失效：在⽹站或应⽤中，可以将数据加载到缓存中，设置过期时间以 保持数据的新鲜度，并在数据过期后重新加载最新数据。 </p>
</li>
<li><p>⽇志记录和清理：在系统中，可以将⽇志记录为消息发送到队列中，并设置过期 时间以限制⽇志数据的保留时间，以及⾃动清理过期的⽇志。</p>
</li>
<li><p>定时任务调度：可以使⽤ RabbitMQ 结合过期时间来实现定时任务调度。通过设 置消息的过期时间，将任务消息发送到队列中，并在过期后触发执⾏相应的任务 操作。</p>
</li>
</ol>
<p>类型</p>
<p>1.给队列中的消息指定过期时间</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建消息队列，指定消息过期参数</span><br><span class="line">Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(&quot;x-message-ttl&quot;, 5000);</span><br><span class="line">//args指定参数</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, false, false, false, args);</span><br></pre></td></tr></table></figure>

<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_13-46-51.png" alt="Snipaste_2024-02-13_13-46-51"></p>
<p>消费者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class TtlConsumer &#123;</span><br><span class="line">private final static String QUEUE_NAME = &quot;ttl_queue&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    //创建链接</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    //创建消息队列，指定消息过期参数</span><br><span class="line">    Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();</span><br><span class="line">    args.put(&quot;x-message-ttl&quot;, 5000);</span><br><span class="line">    //args指定参数</span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, false, false, false, args);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class="line">    //定义了如何处理消息</span><br><span class="line">    DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        String message = new String(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(&quot; [x] Received &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    //消费消息，会持续阻塞。autoAck参数表示参数取出来后就是表示自动完成消费了</span><br><span class="line">    channel.basicConsume(QUEUE_NAME, false, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class TtlProducer &#123;</span><br><span class="line">private final static String QUEUE_NAME = &quot;ttl_queue&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    //创建链接工厂</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">//    factory.setUsername();</span><br><span class="line">//    factory.setPassword();</span><br><span class="line">//    factory.setPort();</span><br><span class="line">    //建立链接，创建频道</span><br><span class="line">    try (Connection connection = factory.newConnection();</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line">        //发送消息</span><br><span class="line">        String message = &quot;Hello World!&quot;;</span><br><span class="line">        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在过期时间内，还没有消费者取消息，消息才会过期</p>
<p>注意：如果消息已经接收到，但是没确认，是不会过期的。</p>
<p>如果消息处于待消费状态并且过期时间到达后，消息将被标记为过期。但是，如果 消息已经被消费者消费，并且正在处理过程中，即使过期时间到达，消息仍然会被 正常处理。</p>
<p>一般消费者先启动，保证后面生产者发的消息都能监听到，而不是生产者发了很多消息，消息都存在积压了，而消费者才启动</p>
<p>2.给某条消息指定过期时间</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//给消息指定过期时间</span><br><span class="line">AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()</span><br><span class="line">        .expiration(&quot;1000&quot;)</span><br><span class="line">        .build();</span><br><span class="line">channel.basicPublish(&quot;my-exchange&quot;, &quot;routing-key&quot;, properties,message.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>

<p>生产者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TtlProducer &#123;</span><br><span class="line">private final static String QUEUE_NAME = &quot;ttl_queue&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    //创建链接工厂</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    //建立链接，创建频道</span><br><span class="line">    try (Connection connection = factory.newConnection();</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line">        //发送消息</span><br><span class="line">        String message = &quot;Hello World!&quot;;</span><br><span class="line"></span><br><span class="line">        //给消息指定过期时间</span><br><span class="line">        AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()</span><br><span class="line">                .expiration(&quot;1000&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        channel.basicPublish(&quot;my-exchange&quot;, &quot;routing-key&quot;, properties,message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h5 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h5><p>官方文档：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/confirms.html">https://www.rabbitmq.com/confirms.html</a></p>
<p>之前讲过</p>
<h5 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h5><p>官方文档：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/dlx.html">https://www.rabbitmq.com/dlx.html</a></p>
<p>为了保证消息的可靠性，比如每条消息都成功消费，需要提供一个容错机制，即：失败的消息怎么处理？</p>
<p>死信：过期的消息、拒收的消息、消息队列满了、处理失败的消息的统称</p>
<p>死信队列：专门处理死信的队列（注意它就是一个普通队列，只不过是专门用来处理死信的，甚至可以理解这个队列的名称叫“死信队列”）</p>
<p>死信交换机：专门给死信队列转发消息的交换机（注意：它就是一个普通的交换机，只不过专门给死信队列发消息而已，理解这个交换机的名称就叫“死信交换机”），也存在路由绑定</p>
<p>死信可以通过死信交换机绑定到死信队列</p>
<p>示例场景</p>
<p>实现：</p>
<p>1.创建死信交换机和死信队列，并且绑定关系</p>
<p><img src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_20-05-48.png" alt="Snipaste_2024-02-13_20-05-48"></p>
<p>2.给失败之后需要容错处理的队列绑定死信交换机</p>
<p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//指定死信队列参数</span><br><span class="line">Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();</span><br><span class="line">//要绑定到哪个交换机</span><br><span class="line">args.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE_NAME);</span><br><span class="line">//指定死信要转发到哪个队列</span><br><span class="line">args.put(&quot;x-dead-letter-routing-key&quot;, &quot;waibao&quot;);</span><br><span class="line"></span><br><span class="line">//创建队列，没有指定队列时随机分配一个队列名称</span><br><span class="line"> String queueName =&quot;xiaodog_queue&quot;;</span><br><span class="line">channel.queueDeclare(queueName, true, false, false, args);</span><br><span class="line">//绑定队列</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, &quot;xiaodog&quot;);</span><br></pre></td></tr></table></figure>

<p>3.可以给要容错的队列指定死信之后的转发规则，死信应该再转发到哪个死信队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//指定死信要转发到哪个队列</span><br><span class="line">args.put(&quot;x-dead-letter-routing-key&quot;, &quot;waibao&quot;);</span><br></pre></td></tr></table></figure>







<h4 id="RabbitMQ的重要特性（面试考点）"><a href="#RabbitMQ的重要特性（面试考点）" class="headerlink" title="RabbitMQ的重要特性（面试考点）"></a>RabbitMQ的重要特性（面试考点）</h4><p>1.消息队列的概念、模型、应用场景</p>
<p>2.交换机的类别，路由绑定的关系</p>
<p>3.消息可靠性</p>
<p>​	a.消息确认机制（ack,nack,reject）</p>
<p>​	b.消息持久化(durable)</p>
<p>​	c.消息过期机制</p>
<p>​	d.死信队列</p>
<p>4.延迟队列（类似死信队列）</p>
<p>5.顺序消费、消费幂等性（本次不讲）</p>
<p>6.可扩展性（仅做了解）</p>
<p>​	a.集群</p>
<p>​	b.故障的恢复机制</p>
<p>​	c.镜像</p>
<p>7.运维监控告警（仅做了解）</p>
<h4 id="RabbitMQ项目实战"><a href="#RabbitMQ项目实战" class="headerlink" title="RabbitMQ项目实战"></a>RabbitMQ项目实战</h4><h5 id="选择客户端"><a href="#选择客户端" class="headerlink" title="选择客户端"></a>选择客户端</h5><p>1.使⽤官⽅的客户端 </p>
<p>优点：兼容性好，换语⾔成本低，⽐较灵活 </p>
<p>缺点：太灵活，要⾃⼰去处理⼀些事情。⽐如要⾃⼰维护管理链接，很麻烦。 </p>
<p>2.使⽤封装好的客户端，⽐如 Spring Boot RabbitMQ Starter </p>
<p>优点：简单易⽤，直接配置直接⽤，更⽅便地去管理连接 </p>
<p>缺点：封装的太好了，你没学过的话反⽽不知道怎么⽤。不够灵活，被框架限制。 </p>
<p>根据场景来选择，没有绝对的优劣，类似 jdbc 和 MyBatis</p>
<p> 优点：</p>
<ol>
<li><p>强⼤的功能⽀持：RabbitMQ Java 客户端提供了丰富的功能和特性，例如消息 确认、事务⽀持、消费者拉取、消息重试、可靠性消息传递等。 </p>
</li>
<li><p>可靠性和稳定性：通过使⽤可靠的消息确认机制和事务⽀持，Java 客户端可以 确保消息的可靠传递和处理。 </p>
</li>
<li><p>开发⼈员社区⽀持：RabbitMQ Java 客户端拥有⼴泛的开发⼈员社区⽀持，并 且有⼤量的⽂档和示例代码可供参考。</p>
</li>
<li><p>良好的性能：Java 客户端采⽤了⾼性能的⽹络通信协议和线程模型，可以在⾼ 并发的场景下表现出较好的性能。</p>
<p>缺点： </p>
<ol>
<li>复杂性：相对于其他语⾔的 RabbitMQ 客户端，Java 客户端可能会更加复杂和 臃肿，需要更多的代码和配置。 </li>
<li>内存占⽤：由于 Java 客户端的⼀些设计和依赖，可能会占⽤较多的内存资源， 尤其在⾼并发的情况下。</li>
</ol>
</li>
</ol>
<p>3.本次使⽤ Spring Boot RabbitMQ Starter (因为我们是 Spring Boot 项⽬) 如果你有⼀定⽔平，有基础，英⽂好，建议看官⽅⽂档，不要看过期博客！ 官⽹地址：<a target="_blank" rel="noopener" href="https://spring.io/guides/gs/messaging-rabbitmq">https://spring.io/guides/gs/messaging-rabbitmq</a></p>
<h5 id="项目引入RabbitMQ"><a href="#项目引入RabbitMQ" class="headerlink" title="项目引入RabbitMQ"></a>项目引入RabbitMQ</h5><p>1.安装依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-amqp --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>注意：使用的版本和springboot使用的版本一致</p>
<p>2.在yml中引入配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    rabbitmq:</span><br><span class="line">      host: localhost</span><br><span class="line">      port: 5672</span><br><span class="line">      password: guest</span><br><span class="line">      username: guest</span><br></pre></td></tr></table></figure>

<p>3.创建交换机和队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用于创建测试程序用到的交换机和队列（只用在程序启动前执行一次）</span><br><span class="line"> */</span><br><span class="line">public class MqInitMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">            factory.setHost(&quot;localhost&quot;);</span><br><span class="line">            Connection connection = factory.newConnection();</span><br><span class="line">            Channel channel = connection.createChannel();</span><br><span class="line">            String EXCHANGE_NAME = &quot;code_exchange&quot;;</span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);</span><br><span class="line">            //创建小zhao队列，没有指定队列时随机分配一个队列名称</span><br><span class="line">            String queueName =&quot;code_queue&quot;;</span><br><span class="line">            channel.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">            //绑定队列</span><br><span class="line">            channel.queueBind(queueName, EXCHANGE_NAME, &quot;my_routingKey&quot;);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.生产者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyMessageProducer &#123;</span><br><span class="line"></span><br><span class="line">    //根据yml配置生成对象</span><br><span class="line">    @Resource</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 消费者发送消息方法</span><br><span class="line">     *</span><br><span class="line">     * @param exchange 交换机</span><br><span class="line">     * @param routeKey 路由键</span><br><span class="line">     * @param message 消息</span><br><span class="line">     */</span><br><span class="line">    public void sendMessage(String exchange, String routeKey, String message)&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routeKey, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.消费者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class MyMessageConsumer &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //不想抛异常可以使用@SneakyThrows注解，不建议这样做</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    //指定程序监听的消息队列和确认机制</span><br><span class="line">    @RabbitListener(queues = &#123;&quot;code_queue&quot;&#125;,ackMode = &quot;MANUAL&quot;)</span><br><span class="line">    public void receiveMessage(String message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliverTag)&#123;</span><br><span class="line">        log.info(&quot;receiveMessage = &#123;&#125;&quot;,message);</span><br><span class="line">        channel.basicAck(deliverTag, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.单元测试执行</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class MyMessageProducerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private MyMessageProducer myMessageProducer;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void sendMessage() &#123;</span><br><span class="line">        myMessageProducer.sendMessage(&quot;code_exchange&quot;,&quot;my_routingKey&quot;,&quot;你好&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先debug启动yml，在测试sendMessage方法</p>
<hr>
<h4 id="BI项目改造"><a href="#BI项目改造" class="headerlink" title="BI项目改造"></a>BI项目改造</h4><h5 id="改造前"><a href="#改造前" class="headerlink" title="改造前"></a>改造前</h5><p>以前是把任务提交到线程池，然后在线程池提交中编写处理程序的代码，线程池内排 队。 如果程序中断了，任务就没了，就丢了。</p>
<h5 id="改造后"><a href="#改造后" class="headerlink" title="改造后"></a>改造后</h5><p>改造后的流程： </p>
<ol>
<li><p>把任务提交改为向队列发送消息 </p>
</li>
<li><p>写⼀个专引⻔的接受消息的程序，处理任务 </p>
</li>
<li><p>如果程序中断了，消息未被确认，还会重发 </p>
</li>
<li><p>现在，消息全部集中发到消息队列，可以部署多个后端，都从同⼀个地⽅取任 务，从⽽实现了分布式负载均衡</p>
<p>通过这样的改进，我们实现了⼀种更可靠的任务处理⽅式。任务不再依赖于线程池， ⽽是通过消息队列来进⾏分发和处理，即使程序中断或出现故障，任务也能得到保证 并得到正确处理。同时，我们还可以通过部署多个后端程序来实现负载均衡，提⾼系 统的处理能⼒和可靠性。</p>
<p> 实现步骤： </p>
<ol>
<li><p>创建交换机和队列 </p>
</li>
<li><p>将线程池中的执⾏代码移到消费者类中 </p>
</li>
<li><p>根据消费者的需求来确认消息的格式(chartld) </p>
</li>
<li><p>将提交线程池改造为发送消息到队列 </p>
<p>验证 </p>
<p>验证发现，如果程序中断了，没有 ack、也没有 nack (服务中断，没有任何响应)， 那么这条消息会被重新放到消息队列中，从⽽实现了每个任务都会执⾏。</p>
</li>
</ol>
</li>
</ol>
<p>注：线程池更适用于需要多线程处理任务，而MQ更适用于服务间通信，应用解耦，消息保障性</p>
<p>准备：</p>
<p>1.创建队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用于创建测试程序用到的交换机和队列（只用在程序启动前执行一次）</span><br><span class="line"> */</span><br><span class="line">public class BiInitMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">            factory.setHost(&quot;localhost&quot;);</span><br><span class="line">            Connection connection = factory.newConnection();</span><br><span class="line">            Channel channel = connection.createChannel();</span><br><span class="line">            String EXCHANGE_NAME = BiMqConstant.BI_EXCHANGE_NAME;</span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);</span><br><span class="line">            //创建队列，没有指定队列时随机分配一个队列名称</span><br><span class="line">            String queueName =BiMqConstant.BI_QUEUE_NAME;</span><br><span class="line">            channel.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">            //绑定队列</span><br><span class="line">            channel.queueBind(queueName, EXCHANGE_NAME, BiMqConstant.BI_ROUTING_KEY);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.建立BiConstant:存常量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface BiMqConstant &#123;</span><br><span class="line">    String BI_QUEUE_NAME = &quot;bi_queue&quot;;</span><br><span class="line">    String BI_EXCHANGE_NAME = &quot;bi_exchange&quot;;</span><br><span class="line">    String BI_ROUTING_KEY = &quot;bi_routingKey&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.设置BI生产者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class BiMessageProducer &#123;</span><br><span class="line"></span><br><span class="line">    //根据yml配置生成对象</span><br><span class="line">    @Resource</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 消费者发送消息方法</span><br><span class="line">     *</span><br><span class="line">     * @param message 消息</span><br><span class="line">     */</span><br><span class="line">    public void sendMessage( String message)&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(BiMqConstant.BI_EXCHANGE_NAME, BiMqConstant.BI_ROUTING_KEY, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.设置BI消费者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class BiMessageConsumer &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //不想抛异常可以使用@SneakyThrows注解，不建议这样做</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    //指定程序监听的消息队列和确认机制</span><br><span class="line">    @RabbitListener(queues = &#123;BiMqConstant.BI_EXCHANGE_NAME&#125;,ackMode = &quot;MANUAL&quot;)</span><br><span class="line">    public void receiveMessage(String message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliverTag)&#123;</span><br><span class="line">        log.info(&quot;receiveMessage = &#123;&#125;&quot;,message);</span><br><span class="line">        channel.basicAck(deliverTag, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>chartContoller里新建接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 智能分析（异步消息队列）</span><br><span class="line">     *</span><br><span class="line">     * @param multipartFile</span><br><span class="line">     * @param genChartByAiRequest</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/gen/async/mq&quot;)</span><br><span class="line">    public BaseResponse&lt;BiResponse&gt; genChartByAiAsyncMq(@RequestPart(&quot;file&quot;) MultipartFile multipartFile,</span><br><span class="line">                                                      GenChartByAiRequest genChartByAiRequest, HttpServletRequest request) &#123;</span><br><span class="line">        String name = genChartByAiRequest.getName();</span><br><span class="line">        String goal = genChartByAiRequest.getGoal();</span><br><span class="line">        String chartType = genChartByAiRequest.getChartType();</span><br><span class="line">        //校验</span><br><span class="line">        ThrowUtils.throwIf(StringUtils.isBlank(goal), ErrorCode.PARAMS_ERROR, &quot;目标为空&quot;);</span><br><span class="line">        ThrowUtils.throwIf(StringUtils.isNotBlank(name) &amp;&amp; name.length() &gt; 100, ErrorCode.PARAMS_ERROR, &quot;名称过长&quot;);</span><br><span class="line">        //校验文件</span><br><span class="line">        long size = multipartFile.getSize();</span><br><span class="line">        String originalFilename = multipartFile.getOriginalFilename();</span><br><span class="line">        //校验文件大小</span><br><span class="line">        final long ONE_MB = 1024 * 1024L;</span><br><span class="line">        ThrowUtils.throwIf(size &gt; ONE_MB, ErrorCode.PARAMS_ERROR, &quot;文件超过1M&quot;);</span><br><span class="line">        //校验文件后缀 aaa.png</span><br><span class="line">        String suffix = FileUtil.getSuffix(originalFilename);</span><br><span class="line">        final List&lt;String&gt; validFileSuffixList = Arrays.asList(&quot;xlsx&quot;, &quot;xls&quot;);</span><br><span class="line">        ThrowUtils.throwIf(!validFileSuffixList.contains(suffix), ErrorCode.PARAMS_ERROR, &quot;文件后缀非法&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //获取当前用户信息</span><br><span class="line">        User loginUser = userService.getLoginUser(request);</span><br><span class="line">        //限流判断,每个用户一个限流器,</span><br><span class="line">        // 参数这样写的好处是每个方法的限流器不会冲突，一个方法的调用了的次数，不会影响其他方法的使用</span><br><span class="line">//        redisLimiterManager.doRateLimit(&quot;genChartByAi_&quot;+loginUser.getId());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        StringBuilder userInput = new StringBuilder();</span><br><span class="line">        userInput.append(&quot;分析需求：&quot;).append(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">        // 拼接分析目标</span><br><span class="line">        String userGoal = goal;</span><br><span class="line">        if (StringUtils.isNotBlank(chartType)) &#123;</span><br><span class="line">            userGoal += &quot;，请使用&quot; + chartType;</span><br><span class="line">        &#125;</span><br><span class="line">        userInput.append(userGoal).append(&quot;\n&quot;);</span><br><span class="line">        userInput.append(&quot;原始数据：&quot;).append(&quot;\n&quot;);</span><br><span class="line">        // 压缩后的数据</span><br><span class="line">        String csvData = ExcelUtils.excelToCsv(multipartFile);</span><br><span class="line">        userInput.append(csvData).append(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //插入到数据库</span><br><span class="line">        Chart chart = new Chart();</span><br><span class="line">        chart.setName(name);</span><br><span class="line">        chart.setGoal(goal);</span><br><span class="line">        chart.setChartData(csvData);</span><br><span class="line">        chart.setChartType(chartType);</span><br><span class="line">        chart.setStatus(&quot;wait&quot;);</span><br><span class="line"></span><br><span class="line">        chart.setUserId(loginUser.getId());</span><br><span class="line">        boolean saveResult = chartService.save(chart);</span><br><span class="line">        ThrowUtils.throwIf(!saveResult, ErrorCode.SYSTEM_ERROR, &quot;图表保存失败&quot;);</span><br><span class="line">        long newChartId = chart.getId();</span><br><span class="line">        //现在改为在消费者中单独处理任务，而不是在线程池中处理</span><br><span class="line">        biMessageProducer.sendMessage(String.valueOf(newChartId));</span><br><span class="line"></span><br><span class="line">        BiResponse biResponse = new BiResponse();</span><br><span class="line">        biResponse.setChartId(newChartId);</span><br><span class="line">        return ResultUtils.success(biResponse);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/03/26/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/" data-id="clymgsig50001bgw09uzl25nc" data-title="客流量智能分析平台" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/15/%E8%81%9A%E5%90%88%E6%90%9C%E7%B4%A2/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/07/15/OJ%E5%88%A4%E9%A2%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/03/26/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/">客流量智能分析平台</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>