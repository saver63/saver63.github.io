<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Keep Team">
    
    <title>
        
        Keep Theme
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.svg">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"Keep Theme","author":"Keep Team","avatar":"/images/avatar.svg","logo":"/images/logo.svg","favicon":"/images/logo.svg"},"menu":{"home":"/","archives":"/archives"},"first_screen":{"enable":false,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Keep writing and Keep loving.","hitokoto":false},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":false,"hide_header":true},"home":{"announcement":null,"category":false,"tag":false,"post_datetime":"updated"},"post":{"author_badge":{"enable":true,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":false,"min2read":false},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":false,"share":false,"reward":{"enable":false,"img_link":null,"text":null}},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"toc":{"enable":false,"number":false,"expand_all":false,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":false,"site_uv":false,"site_pv":false,"page_pv":false}},"local_search":{"enable":false,"preload":false},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.36"},"waline":{"server_url":null,"reaction":false,"version":"3.2.1"},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":false},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":false},"footer":{"since":2020,"word_count":false,"site_deploy":{"enable":false,"provider":"github","url":null},"record":{"enable":false,"list":[{"code":null,"link":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"root":"","source_data":{},"version":"4.1.5"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original post title","author":"Original post author","link":"Original post link"}
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               Keep Theme
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                
                                HOME
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                
                                ARCHIVES
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/"
                    >HOME</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives"
                    >ARCHIVES</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/avatar.svg">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">Keep Team</span>
                                
                                    <span class="author-badge">Lv1</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024-07-15 11:20:28</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Mon Jun 17 2024 10:51:36 GMT+0800">2024-06-17 10:51:36</span>
            </span>
        

        

        

        
        
        
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    
                         <h4 id="库表设计"><a href="#库表设计" class="headerlink" title="库表设计"></a>库表设计</h4><p>题目表</p>
<p>题目内容：存放题目介绍，输入输出提示、描述、具体的详情</p>
<p>题目标签（Json数组字符串）：栈、队列、链表、简单、中等、困难</p>
<p>题目答案</p>
<p>提交数：通过题目的人数等，便于分析（可以考虑根据通过率自动给题目打难易度标签）</p>
<p>输入用例：</p>
<p>输出用例：</p>
<p>注意：如果输出用例和输入用例大于512M时，单独放在文件中，数据库存放url。</p>
<p>judgeConfig判题配置(Json对象)</p>
<p>时间限制：timeLimt</p>
<p>内存限制：memoryLimit</p>
<p>judgeConfig判题用例</p>
<p>输入用例：inputCase</p>
<p>输出用例：outputCase</p>
<p>结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		&quot;input&quot;: &quot;1,2&quot;,</span><br><span class="line">		&quot;output&quot;:&quot;3,4&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		&quot;input&quot;: &quot;1,3&quot;,</span><br><span class="line">		&quot;output&quot;:&quot;2,4&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>把判题相关的字段存放在Json对象中的好处？</p>
<p>便于维护，便于扩展。后面想要加功能时只需要在 Json中加字段即可，而不用修改数据库表（可能会影响数据库）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;timeLimit&quot;: 1000,</span><br><span class="line">	&quot;memoryLimit&quot;: 1000,</span><br><span class="line">	&quot;stackLimit&quot;: 1000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>什么情况下考虑存Json?</p>
<ol>
<li>不需要根据Json的字段反查，这个配置属于那条数据</li>
</ol>
<p>例：</p>
<p>​	  1. 不会根据输入输出用例去查题目，只会根据题目查</p>
<p>​	   2. 不会根据内存的限制和时间限制查题目</p>
<ol start="2">
<li>相似的字段可以存到Json中</li>
</ol>
<p>​	3. Json占用空间不能太大</p>
<p>题目表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 题目表</span><br><span class="line">create table if not exists question</span><br><span class="line">(</span><br><span class="line">    id         bigint auto_increment comment &#x27;id&#x27; primary key,</span><br><span class="line">    title      varchar(512)                       null comment &#x27;标题&#x27;,</span><br><span class="line">    content    text                               null comment &#x27;内容&#x27;,</span><br><span class="line">    tags       varchar(1024)                      null comment &#x27;标签列表（json 数组）&#x27;,</span><br><span class="line">    answer     text                               null comment &#x27;题目答案&#x27;,</span><br><span class="line">    submitNum  int      default 0                 not null comment &#x27;提交数&#x27;,</span><br><span class="line">    acceptNum  int      default 0                 not null comment &#x27;通过数&#x27;,</span><br><span class="line">    judgeCase text                                null comment &#x27;判题用例&#x27;,</span><br><span class="line">    judgeConfig text                                null comment &#x27;判题配置&#x27;,</span><br><span class="line">    thumbNum   int      default 0                 not null comment &#x27;点赞数&#x27;,</span><br><span class="line">    favourNum  int      default 0                 not null comment &#x27;收藏数&#x27;,</span><br><span class="line">    userId     bigint                             not null comment &#x27;创建用户 id&#x27;,</span><br><span class="line">    createTime datetime default CURRENT_TIMESTAMP not null comment &#x27;创建时间&#x27;,</span><br><span class="line">    updateTime datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment &#x27;更新时间&#x27;,</span><br><span class="line">    isDelete   tinyint  default 0                 not null comment &#x27;是否删除&#x27;,</span><br><span class="line">    index idx_userId (userId)</span><br><span class="line">) comment &#x27;帖子&#x27; collate = utf8mb4_unicode_ci;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>题目提交表</p>
<p>哪个用户提交了哪道题目，存放判题结果</p>
<p>提交用户id: userId</p>
<p>题目id: questionId</p>
<p>语言: language</p>
<p>用户的代码：code</p>
<p>判题状态: status(0-待判题，1-判题中，2判题成功，3-判题失败)</p>
<p>判题结果: result</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;message&quot;: &quot;程序执行信息&quot;,</span><br><span class="line">	&quot;time&quot;: 1000,//单位为毫秒</span><br><span class="line">	&quot;memory&quot;: 1000,//单位为kb</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>判题信息枚举值：</p>
<p>1.Accepted成功</p>
<p>2.Wrong Answer 答案错误</p>
<p>3.Compole Error 编译错误</p>
<p>4.Memory Limit Exceeded 内存溢出</p>
<p>5.Time Limit Exceed 时间超时</p>
<p>6.Presentation Error 展示错误</p>
<p>7.Output Limit Exceed:输出移除</p>
<p>8.Waiting 等待中</p>
<p>9.Dangerous Operation危险操作</p>
<p>10Runtime Error 运行错误（用户程序的问题）</p>
<p>11.System Error 系统错误（做系统的人的问题）</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>什么情况下适合加索引？如何选择给哪个字段加索引？</p>
<p>答：从业务触发，无论是单个索引，还是联合索引，都要从你实际的查询语句，字段枚举的区分度，字段的类型考虑（where条件指定的字段）</p>
<p>比如：where userId &#x3D; 1 and questionId &#x3D; 2</p>
<p>可以选择根据userId和questionId分别简历索引（需要分别根据这两个字段独立查询），也可以选择两个字段建立联合索引（锁查询的字段绑定在一起）</p>
<p>原则上：能不用索引就不用索引；能用单个索引就不用联合&#x2F;多个索引；因为索引也是占用空间的。不要给没区分度的字段加索引。</p>
<h4 id="后端接口开发"><a href="#后端接口开发" class="headerlink" title="后端接口开发"></a>后端接口开发</h4><p>后端接口开发流程</p>
<p>1.根据功能设计库表</p>
<p>2.自动生成基本的增删改查（mapper和service层的基本功能）</p>
<p>​	为了方便处理json字段中的某个字段，需要给对应的json字段编写独立的类，比如judgeConfig，judgeInfo，judgeCase。</p>
<p>​		什么情况下要加业务前缀？什么情况下不加？</p>
<p>​		加业务前缀的好处，防止多个表都有相似的字段，产生冲突</p>
<p>​		不加的前提，因为可能这个类是业务之间共享的，能够复用的。</p>
<p>​		updateRequest和editRequest的区别：前者是给管理员更新的，可以指定更多字段；后者是给普通用户试用的，只能指定部分字段。</p>
<p>​		定义VO类：作用是专门给前端返回对象，可以节约网络传输大小，或者过滤字段（脱敏）,保证安全性。比如judgeCase字段。</p>
<p>​		校验Controller层的代码，看看除了方法缺失外，还有无报错。</p>
<p>​		实现Sevice层代码</p>
<p>​		编写QuestionVO的json&#x2F;对象转换工具类</p>
<p>​		编写枚举类</p>
<p>3.编写Controller层，实现基本的增删改查和权限校验（复制粘贴）</p>
<p>4.去根据业务定制开发新的功能&#x2F;编写新的代码</p>
<p>更好的方法，编写自己的代码生成器</p>
<h4 id="查询提交信息"><a href="#查询提交信息" class="headerlink" title="查询提交信息"></a>查询提交信息</h4><p>功能：能够根据用户id或者题目id，编程语言，提交状态去查询提交记录</p>
<p>注意事项：仅本人和管理员能看见自己（提交userId和登录用户id不同）提交代码的答案、提交的代码</p>
<p>实现方案：先查询，再根据权限脱敏。</p>
<p>核心代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取题目表封装</span><br><span class="line"> *</span><br><span class="line"> * @param questionSubmit</span><br><span class="line"> * @param loginUser</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public QuestionSubmitVO getQuestionSubmitVO(QuestionSubmit questionSubmit, User loginUser) &#123;</span><br><span class="line">    // 对象转封装类</span><br><span class="line">    QuestionSubmitVO questionSubmitVO = QuestionSubmitVO.objToVo(questionSubmit);</span><br><span class="line">    //脱敏：仅本人和管理员能看见自己（提交userId和登录用户id不同）提交的代码</span><br><span class="line">    long userId = loginUser.getId();</span><br><span class="line">    if (userId != questionSubmit.getUserId() &amp;&amp; !userService.isAdmin(loginUser))&#123;</span><br><span class="line">        questionSubmitVO.setCode(null);</span><br><span class="line">    &#125;</span><br><span class="line">    return questionSubmitVO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="判题机模块预开发"><a href="#判题机模块预开发" class="headerlink" title="判题机模块预开发"></a>判题机模块预开发</h3><h4 id="梳理判题模块和代码沙箱的关系"><a href="#梳理判题模块和代码沙箱的关系" class="headerlink" title="梳理判题模块和代码沙箱的关系"></a>梳理判题模块和代码沙箱的关系</h4><p>判题模块：调用代码沙箱，把代码和输入交给沙箱去执行。</p>
<p>代码沙箱：只负责接收代码和输入，返回编译运行的结果，不负责判题。（可以作为独立的项目&#x2F;服务，提供给其它需要执行的代码）</p>
<p>这两个模块完全解耦。</p>
<p><img   src="F:\迅雷下载\work\notebook\source_posts\OJ判题\Snipaste_2024-06-11_15-56-53.png"  alt="Snipaste_2024-06-11_15-56-53"></p>
<h5 id="思考：为什么代码沙箱要接受和输出一组运行用例"><a href="#思考：为什么代码沙箱要接受和输出一组运行用例" class="headerlink" title="思考：为什么代码沙箱要接受和输出一组运行用例"></a>思考：为什么代码沙箱要接受和输出一组运行用例</h5><p>前提：每道题目有多组测试用例</p>
<p>如果是每个用例单独调用一次代码沙箱，会调用多次接口，需要多次网络传输、程序要多次编译，记录程序的执行状态（重复的代码不重复编译）</p>
<p>代码沙箱无状态。（调用远程接口时，想办法只调用一次）</p>
<p>这是一种常见的性能优化的方法！（批处理）</p>
<h4 id="代码沙箱模块开发"><a href="#代码沙箱模块开发" class="headerlink" title="代码沙箱模块开发"></a>代码沙箱模块开发</h4><p>1.定义代码沙箱接口，提高通用性</p>
<p>之后我们的项目代码只调用接口，不调用具体的实现类，这样在你使用其它的代码沙箱实现类时，就不用修改名称了，便于扩展。</p>
<blockquote>
<p>代码沙箱的请求接口，timeLimit可加可不加，可自行扩展，即时中断程序</p>
</blockquote>
<blockquote>
<p>扩展思路：增加一个查看代码沙箱状态的接口</p>
</blockquote>
<p>2.定义多种不同代码沙箱的实现。</p>
<p>​	示例代码沙箱</p>
<p>​	远程代码沙箱</p>
<p>​	第三方代码沙箱</p>
<p>lombok Builder注解</p>
<p>实体类加上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">//构造器创建对象</span><br><span class="line">@Builder</span><br><span class="line">//生成无参的构造函数</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">//生成有所有参数的构造函数</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class ExecuteCodeRequest &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; inputList;</span><br><span class="line"></span><br><span class="line">    private String code;</span><br><span class="line"></span><br><span class="line">    private String language;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3.编写单元测试，验证单个代码沙箱的执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void executeCode() &#123;</span><br><span class="line">    //建造者模式</span><br><span class="line">    CodeSandbox codeSandbox = new ExampleCodeSandboxImpl();</span><br><span class="line">    String code = &quot;int main()&#123; &#125;&quot;;</span><br><span class="line">    String language = QuestionSubmitLanguageEnum.JAVA.getValue();</span><br><span class="line">    List&lt;String&gt; inputList = Arrays.asList(&quot;1 2&quot;,&quot;3 4&quot;);</span><br><span class="line">    ExecuteCodeRequest executeCodeRequest = ExecuteCodeRequest.builder()</span><br><span class="line">            .code(code)</span><br><span class="line">            .language(language)</span><br><span class="line">            .inputList(inputList)</span><br><span class="line">            .build();</span><br><span class="line">    ExecuteCodeResponse executeCodeResponse = codeSandbox.executeCode(executeCodeRequest);</span><br><span class="line">    Assertions.assertNotNull(executeCodeResponse);</span><br></pre></td></tr></table></figure>



<p>现在的问题：我们把new某个沙箱的代码写死了，如果后面项目要改用其他沙箱，可能要改很多地方的代码。</p>
<p>4.使用工厂模式，根据用户传入的字符串（沙箱类别），来生成对应的代码沙箱实现类</p>
<p>这里没必要用抽象工厂：因为一个工厂只生产一个商品，而抽象工厂是生产多个商品。</p>
<p>此处使用静态工厂模式，实现比较简单，符合需求。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建代码沙箱示例</span><br><span class="line"> * @param type 沙箱类型</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static CodeSandbox newInstance(String type)&#123;</span><br><span class="line">    switch (type)&#123;</span><br><span class="line">        case &quot;example&quot;:</span><br><span class="line">            return new ExampleCodeSandboxImpl();</span><br><span class="line">        case &quot;remote&quot;:</span><br><span class="line">            return new RemoteCodeSandboxImpl();</span><br><span class="line">        case &quot;thirdParty&quot;:</span><br><span class="line">            return new ThirdPartyCodeSandboxImpl();</span><br><span class="line">        default:</span><br><span class="line">            return new ExampleCodeSandboxImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>扩展思路：如果确定代码沙箱示例不会出现线程安全问题，可复用，那么可以使用单例工厂模式（注册器模式）</p>
</blockquote>
<p>由此：我们可以根据字符串动态生成实例，提高了通用性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    void executeCode() &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext())&#123;</span><br><span class="line">            String type = scanner.next();</span><br><span class="line">            CodeSandbox codeSandbox = CodeSandboxFactory.newInstance(type);</span><br><span class="line">            String code = &quot;int main()&#123; &#125;&quot;;</span><br><span class="line">            String language = QuestionSubmitLanguageEnum.JAVA.getValue();</span><br><span class="line">            List&lt;String&gt; inputList = Arrays.asList(&quot;1 2&quot;,&quot;3 4&quot;);</span><br><span class="line">            //建造者模式</span><br><span class="line">            ExecuteCodeRequest executeCodeRequest = ExecuteCodeRequest.builder()</span><br><span class="line">                    .code(code)</span><br><span class="line">                    .language(language)</span><br><span class="line">                    .inputList(inputList)</span><br><span class="line">                    .build();</span><br><span class="line">            ExecuteCodeResponse executeCodeResponse = codeSandbox.executeCode(executeCodeRequest);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>可以暴露给用户，让用户调试使用哪个沙箱</p>
</blockquote>
<p>5.参数配置化，把项目中的一些可以交给用户去自定义的选项或字符串，写道配置文件中，这样开发者只需要改配置文件，而不需要看你的项目代码，就能自定义使用你项目的更多功能。</p>
<p>application.yml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 代码沙箱配置</span><br><span class="line">codesandbox:</span><br><span class="line">  type: example</span><br></pre></td></tr></table></figure>

<p>在Spring的Bean中通过@Value注解读取:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;&#123;codesandbox.type:example&#125;&quot;)</span><br><span class="line">private String value;</span><br></pre></td></tr></table></figure>



<p>问题：我们想知道传给代码沙箱的输入代码以及代码沙箱给的返回值，想要在日志中查看。每一个代码沙箱实例要打日志</p>
<p>6.代码沙箱能力增强</p>
<p>比如: 我们需要在调用代码沙箱前，输出请求参数日志；在代码沙箱调用后，输出想要结果日志，便于管理员去分析。</p>
<p>传统方式：每个代码沙箱类都写一遍log.info?难道每次调用代码沙箱前后都执行log?</p>
<p>使用代理模式：</p>
<p>原本：需要用户调用多次</p>
<p><img   src="F:\迅雷下载\work\notebook\source_posts\OJ判题\Snipaste_2024-06-11_22-26-28.png"  alt="Snipaste_2024-06-11_22-26-28"></p>
<p>使用代理后：不仅不用改变原本的代码沙箱实现类，而且对调用者来说，调用方式几乎没用任何改变任何改变，也不需要在调用沙箱的地方去写统计代码。</p>
<p><img   src="F:\迅雷下载\work\notebook\source_posts\OJ判题\Snipaste_2024-06-11_22-28-06.png"  alt="Snipaste_2024-06-11_22-28-06"></p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 代码沙箱代理类：增强代码沙箱的能力（增加打印输出）</span><br><span class="line"> * 本质上就相当于是中介</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">public class CodeSandboxProxy implements CodeSandbox&#123;</span><br><span class="line"></span><br><span class="line">    private final CodeSandbox codeSandbox;</span><br><span class="line"></span><br><span class="line">    public CodeSandboxProxy(CodeSandbox codeSandbox) &#123;</span><br><span class="line">        this.codeSandbox = codeSandbox;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public ExecuteCodeResponse executeCode(ExecuteCodeRequest executeCodeRequest) &#123;</span><br><span class="line">        log.info(&quot;代码沙箱请求信息&quot;+executeCodeRequest.toString());</span><br><span class="line">        ExecuteCodeResponse executeCodeResponse = codeSandbox.executeCode(executeCodeRequest);</span><br><span class="line">        log.info(&quot;代码沙箱响应信息&quot;+executeCodeResponse.toString());</span><br><span class="line">        return executeCodeResponse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CodeSanbox codeSanbox = COdeSanboxFactory.newInstance(type);</span><br><span class="line">codeSanbox = new CodeSanboxProxy(codeSanbox)</span><br></pre></td></tr></table></figure>



<p>刚刚做的：配置化，代理，方法的增强，根据参数动态的生成沙箱，包括哪些代码设置成接口</p>
<p>7.实现实例代码沙箱</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实例代码沙箱（仅为了跑通流程）</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">public class ExampleCodeSandboxImpl implements CodeSandbox &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ExecuteCodeResponse executeCode(ExecuteCodeRequest executeCodeRequest) &#123;</span><br><span class="line">        List&lt;String&gt; inputList = executeCodeRequest.getInputList();</span><br><span class="line"></span><br><span class="line">        ExecuteCodeResponse executeCodeResponse = new ExecuteCodeResponse();</span><br><span class="line">        executeCodeResponse.setOutputList(inputList);</span><br><span class="line">        executeCodeResponse.setMessage(&quot;测试执行成功&quot;);</span><br><span class="line">        executeCodeResponse.setStatus(QuestionSubmitStatusEnum.SUCCEED.getValue());</span><br><span class="line">        JudgeInfo judgeInfo = new JudgeInfo();</span><br><span class="line">        judgeInfo.setMessage(JudgeInfoMessageEnum.ACCEPTED.getText());</span><br><span class="line">        judgeInfo.setMemory(100L);</span><br><span class="line">        judgeInfo.setTime(100L);</span><br><span class="line">        executeCodeResponse.setJudgeInfo(judgeInfo);</span><br><span class="line">        return executeCodeResponse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以使用链式的方式更方便的给对象赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//建造者模式</span><br><span class="line">            ExecuteCodeRequest executeCodeRequest = ExecuteCodeRequest.builder()</span><br><span class="line">                    .code(code)</span><br><span class="line">                    .language(language)</span><br><span class="line">                    .inputList(inputList)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure>





<h4 id="判题服务完整业务流程实现"><a href="#判题服务完整业务流程实现" class="headerlink" title="判题服务完整业务流程实现"></a>判题服务完整业务流程实现</h4><p>判题服务业务流程</p>
<p>1.传入题目的提交id,获取到对应的题目，提交信息（包含代码、编程语言等）</p>
<p>2.如果题目的提交状态不为等待中，就不用重复执行了</p>
<p>3.更改判题（题目提交）的状态为“判题中”，防止重复执行，也能让用户看到状态。</p>
<p>4.调用沙箱，获取到执行结果</p>
<p>5.根据沙箱的执行结果，设置题目的判题状态和信息</p>
<p>​	</p>
<p>判断逻辑：</p>
<p>1.先判断执行的结果输出梳理是否和预期输出数量相等</p>
<p>2.依次判断每一项输出和预期输出是否相等</p>
<p>3.判断题目的限制是否符合要求</p>
<p>4.可能还有其它的异常情况</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class JudgeServiceImpl implements JudgeService &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private QuestionService questionService;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private QuestionSubmitService questionSubmitService;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;&#123;codesandbox.type:example&#125;&quot;)</span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public QuestionSubmitVO doJudge(long questionSubmitId) &#123;</span><br><span class="line">        //1.传入题目的提交id,获取到对应的题目，提交信息（包含代码、编程语言等）</span><br><span class="line">        QuestionSubmit questionSubmit = questionSubmitService.getById(questionSubmitId);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (questionSubmit == null)&#123;</span><br><span class="line">            throw new BusinessException(ErrorCode.NOT_FOUND_ERROR,&quot;提交信息不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Long questionId = questionSubmit.getQuestionId();</span><br><span class="line">        Question question = questionService.getById(questionId);</span><br><span class="line">        if (question == null)&#123;</span><br><span class="line">            throw new BusinessException(ErrorCode.NOT_FOUND_ERROR,&quot;题目不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //2.如果题目的提交状态不为等待中，就不用重复执行了</span><br><span class="line">        if (questionSubmit.getStatus() != QuestionSubmitStatusEnum.WAITING.getValue())&#123;</span><br><span class="line">            throw new BusinessException(ErrorCode.OPERATION_ERROR,&quot;题目正在判题中&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //3.更改判题（题目提交）的状态为“判题中”，防止重复执行，也能让用户看到状态。</span><br><span class="line">        QuestionSubmit questionSubmitUpdate = new QuestionSubmit();</span><br><span class="line">        questionSubmitUpdate.setQuestionId(questionId);</span><br><span class="line">        questionSubmitUpdate.setStatus(QuestionSubmitStatusEnum.RUNNING.getValue());</span><br><span class="line">        boolean update = questionSubmitService.updateById(questionSubmitUpdate);</span><br><span class="line">        if (!update)&#123;</span><br><span class="line">            throw new BusinessException(ErrorCode.SYSTEM_ERROR,&quot;更新题目提交状态错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //4.调用沙箱，获取到执行结果</span><br><span class="line">        CodeSandbox codeSandbox = CodeSandboxFactory.newInstance(type);</span><br><span class="line">        codeSandbox = new CodeSandboxProxy(codeSandbox);</span><br><span class="line">        String language = questionSubmit.getLanguage();</span><br><span class="line">        String code = questionSubmit.getCode();</span><br><span class="line">        //获取输入用例</span><br><span class="line">        String judgeCaseStr = question.getJudgeCase();</span><br><span class="line">        List&lt;JudgeCase&gt; judgeCaseList = JSONUtil.toList(judgeCaseStr, JudgeCase.class);</span><br><span class="line">        List&lt;String&gt; inputList = judgeCaseList.stream().map(JudgeCase::getInput).collect(Collectors.toList());</span><br><span class="line">        //建造者模式</span><br><span class="line">        ExecuteCodeRequest executeCodeRequest = ExecuteCodeRequest.builder()</span><br><span class="line">                .code(code)</span><br><span class="line">                .language(language)</span><br><span class="line">                .inputList(inputList)</span><br><span class="line">                .build();</span><br><span class="line">        ExecuteCodeResponse executeCodeResponse = codeSandbox.executeCode(executeCodeRequest);</span><br><span class="line">        List&lt;String&gt; outputList = executeCodeResponse.getOutputList();</span><br><span class="line">        //5.根据沙箱的执行结果，设置题目的判题状态和信息</span><br><span class="line">        JudgeInfoMessageEnum judgeInfoMessageEnum = JudgeInfoMessageEnum.WAITING;</span><br><span class="line">        //先判断执行的结果输出梳理是否和预期输出数量相等</span><br><span class="line">        if (outputList.size() != inputList.size())&#123;</span><br><span class="line">            //如果输出结果和输入用例数量不一致，判题失败</span><br><span class="line">            judgeInfoMessageEnum = JudgeInfoMessageEnum.WRONG_ANSWER;</span><br><span class="line">        &#125;</span><br><span class="line">        //依次判断每一项输出和预期输出是否相等</span><br><span class="line">        for (int i = 0; i &lt; judgeCaseList.size(); i++) &#123;</span><br><span class="line">            JudgeCase judgeCase = judgeCaseList.get(i);</span><br><span class="line">            if (!judgeCase.getOutput().equals(outputList.get(i)))&#123;</span><br><span class="line">                //如果输出结果和输入用例不一致，判题失败</span><br><span class="line">                judgeInfoMessageEnum = JudgeInfoMessageEnum.WRONG_ANSWER;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断题目的限制是否符合要求</span><br><span class="line">        JudgeInfo judgeInfo = executeCodeResponse.getJudgeInfo();</span><br><span class="line">        Long memory = judgeInfo.getMemory();</span><br><span class="line">        Long time = judgeInfo.getTime();</span><br><span class="line">        String judgeConfigStr = question.getJudgeConfig();</span><br><span class="line">        JudgeConfig judgeConfig = JSONUtil.toBean(judgeConfigStr, JudgeConfig.class);</span><br><span class="line">        Long needMemoryLimit = judgeConfig.getMemoryLimit();</span><br><span class="line">        Long needTimeLimit = judgeConfig.getTimeLimit();</span><br><span class="line">        if (memory &gt; needMemoryLimit)&#123;</span><br><span class="line">            judgeInfoMessageEnum = JudgeInfoMessageEnum.MEMORY_LIMIT_EXCEED;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (time &gt; needTimeLimit)&#123;</span><br><span class="line">            judgeInfoMessageEnum = JudgeInfoMessageEnum.TIME_LIMIT_EXCEED;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="策略模式优化判题代码"><a href="#策略模式优化判题代码" class="headerlink" title="策略模式优化判题代码"></a>策略模式优化判题代码</h4><p>我们的判题策略可能会有很多种，比如我们的代码沙箱本身执行程序需要消耗时间，这个时间可能不同的编程语言是不同的，比如沙箱执行Java要额外花10s。</p>
<p>我们可以采用策略模式，针对不同情况，定义独立的策略，而不是把所有的判题逻辑if…else代码放在一起写。</p>
<p>1.定义策略接口</p>
<p>2.定义实现类为默认策略</p>
<p>3.复制策略，发现爆红</p>
<p>4.创建上下文类，把爆红的变量在改类中定义</p>
<p>默认判题逻辑模块代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 默认判题策略</span><br><span class="line"> */</span><br><span class="line">public class DefaultJudgeStrategy implements JudgeStrategy &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 执行判题</span><br><span class="line">     * </span><br><span class="line">     * @param judgeContext</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public JudgeInfo doJudge(JudgeContext judgeContext) &#123;</span><br><span class="line"></span><br><span class="line">        JudgeInfo judgeInfo = judgeContext.getJudgeInfo();</span><br><span class="line">        Long memory = judgeInfo.getMemory();</span><br><span class="line">        Long time = judgeInfo.getTime();</span><br><span class="line">        List&lt;String&gt; inputList = judgeContext.getInputList();</span><br><span class="line">        List&lt;String&gt; outputList = judgeContext.getOutputList();</span><br><span class="line">        Question question = judgeContext.getQuestion();</span><br><span class="line">        List&lt;JudgeCase&gt; judgeCaseList = judgeContext.getJudgeCaseList();</span><br><span class="line">        //默认值为accept</span><br><span class="line">        JudgeInfoMessageEnum judgeInfoMessageEnum = JudgeInfoMessageEnum.ACCEPTED;</span><br><span class="line">        JudgeInfo judgeInfoResponse = new JudgeInfo();</span><br><span class="line">        judgeInfoResponse.setMemory(memory);</span><br><span class="line">        judgeInfoResponse.setTime(time);</span><br><span class="line">        //先判断执行的结果输出梳理是否和预期输出数量相等</span><br><span class="line">        if (outputList.size() != inputList.size())&#123;</span><br><span class="line">            //如果输出结果和输入用例数量不一致，判题失败</span><br><span class="line">            judgeInfoMessageEnum = JudgeInfoMessageEnum.WRONG_ANSWER;</span><br><span class="line">        &#125;</span><br><span class="line">        //依次判断每一项输出和预期输出是否相等</span><br><span class="line">        for (int i = 0; i &lt; judgeCaseList.size(); i++) &#123;</span><br><span class="line">            JudgeCase judgeCase = judgeCaseList.get(i);</span><br><span class="line">            if (!judgeCase.getOutput().equals(outputList.get(i)))&#123;</span><br><span class="line">                //如果输出结果和输入用例不一致，判题失败</span><br><span class="line">                judgeInfoMessageEnum = JudgeInfoMessageEnum.WRONG_ANSWER;</span><br><span class="line">                judgeInfoResponse.setMessage(judgeInfoMessageEnum.getValue());</span><br><span class="line">                return judgeInfoResponse;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断题目的限制是否符合要求</span><br><span class="line">        String judgeConfigStr = question.getJudgeConfig();</span><br><span class="line">        JudgeConfig judgeConfig = JSONUtil.toBean(judgeConfigStr, JudgeConfig.class);</span><br><span class="line">        Long needMemoryLimit = judgeConfig.getMemoryLimit();</span><br><span class="line">        Long needTimeLimit = judgeConfig.getTimeLimit();</span><br><span class="line">        if (memory &gt; needMemoryLimit)&#123;</span><br><span class="line">            judgeInfoMessageEnum = JudgeInfoMessageEnum.MEMORY_LIMIT_EXCEED;</span><br><span class="line">            judgeInfoResponse.setMessage(judgeInfoMessageEnum.getValue());</span><br><span class="line">            return judgeInfoResponse;</span><br><span class="line">        &#125;</span><br><span class="line">        if (time &gt; needTimeLimit)&#123;</span><br><span class="line">            judgeInfoMessageEnum = JudgeInfoMessageEnum.TIME_LIMIT_EXCEED;</span><br><span class="line">            judgeInfoResponse.setMessage(judgeInfoMessageEnum.getValue());</span><br><span class="line">            return judgeInfoResponse;</span><br><span class="line">        &#125;</span><br><span class="line">        //返回judgeInfoResponse</span><br><span class="line">        judgeInfoResponse.setMessage(judgeInfoMessageEnum.getValue());</span><br><span class="line">        return judgeInfoResponse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>如果选择某种判题策略的过程比较复杂，都写在调用判题服务的代码中，代码会越来越复杂，会有很多if…else…,建议单独编写一共判断策略的类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JudgeStrategy judgeStrategy = new DefaultJudgeStrategy();</span><br><span class="line">        //如果是java程序</span><br><span class="line">        if (language.equals(&quot;java&quot;))&#123;</span><br><span class="line">            judgeStrategy = new JavaLanguageJudgeStrategy();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>JudgeManager的目的：尽量简化对判题功能的调用，让调用方最简单。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判题管理（简化调用）:做了一层封装</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class JudgeManager &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行判题</span><br><span class="line">     *</span><br><span class="line">     * @param judgeContext</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    JudgeInfo doJudge(JudgeContext judgeContext)&#123;</span><br><span class="line">        QuestionSubmit questionSubmit = judgeContext.getQuestionSubmit();</span><br><span class="line">        String language = questionSubmit.getLanguage();</span><br><span class="line">        JudgeStrategy judgeStrategy = new DefaultJudgeStrategy();</span><br><span class="line">        //如果是java程序</span><br><span class="line">        if (&quot;java&quot;.equals(language))&#123;</span><br><span class="line">            judgeStrategy = new JavaLanguageJudgeStrategy();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return judgeStrategy.doJudge(judgeContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="代码沙箱实现"><a href="#代码沙箱实现" class="headerlink" title="代码沙箱实现"></a>代码沙箱实现</h3><p>代码沙箱：只负责接收代码和输入，返回编译运行结果，不负责判题（可以作为独立的项目&#x2F;服务，提供给其它的需要执行代码的项目去使用）</p>
<p>以Java编程语言为主，重要的是学思想，学关键流程</p>
<blockquote>
<p>扩展：可以自行实现C++语言的代码沙箱</p>
</blockquote>
<p>新建一个Spring Boot Web 项目，最终这个项目要提供一共能执行代码，操作代码沙箱的接口。</p>
<h4 id="Java原生实现代码沙箱"><a href="#Java原生实现代码沙箱" class="headerlink" title="Java原生实现代码沙箱"></a>Java原生实现代码沙箱</h4><p>原生：尽可能不借助第三方库和依赖，用最干净、最原始的方式实现代码沙箱</p>
<p>代码沙箱需要：接收代码-&#x3D;&gt;编译代码(javac)&#x3D;&gt;执行代码(java)</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java -cp . SimpleCompute 1 2</span><br><span class="line"></span><br><span class="line">//编写示例代码，注意去掉包名，放到resource的目录下</span><br><span class="line">public class SimpleCompute &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = Integer.parseInt(args[0]);</span><br><span class="line">        int b = Integer.parseInt(args[1]);</span><br><span class="line">        System.out.println(&quot;结果:&quot; + (a+b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为什么编译后的程序中文乱码？</p>
<p>命令行终端的编码是GBK和java代码文件本身的编码UTF-8不一致，导致乱码。</p>
<p>改变控制台的编码：chcp 65001（UTF-8） 936（GBK）</p>
<p>不建议改变终端编码，因为其它运行你代码的人也要改变环境，兼容性查。</p>
<p>可以指定编码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding utf-8 .\SimpleCompute.java</span><br></pre></td></tr></table></figure>



<p>实际OJ系统中，对用户输入的代码会有一定的要求，便于系统统一的处理，所以此处，我们把用户输入代码的类名限制为Main(参考Poj)，减少类名不一致的风险，而且不用从用户代码中提取类名。</p>
<p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = Integer.parseInt(args[0]);</span><br><span class="line">        int b = Integer.parseInt(args[1]);</span><br><span class="line">        System.out.println(&quot;结果:&quot; + (a+b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实际执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding utf-8 Main.java</span><br><span class="line">java -cp .Main 1 2 </span><br></pre></td></tr></table></figure>





<h4 id="核心流程实现"><a href="#核心流程实现" class="headerlink" title="核心流程实现"></a>核心流程实现</h4><p>核心实现思路：用程序去代替人工，用程序来操作命令行，去编译执行代码</p>
<p>Java进程执行管理类Process。</p>
<p>1.把用户的代码保存为文件</p>
<p>2.编译代码。得到class文件</p>
<p>3.执行代码，得到输出结果</p>
<p>4.收集整理输出结果</p>
<p>5.文件清理</p>
<p>6.错误处理，提升程序健壮性</p>
<h5 id="1-把用户的代码保存为文件"><a href="#1-把用户的代码保存为文件" class="headerlink" title="1.把用户的代码保存为文件"></a>1.把用户的代码保存为文件</h5><p>引入hutool工具类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://hutool.cn/docs/index.html#/--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.8.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>新建目录，每个用户的代码都存放在独立目录下，便于维护</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; inputList = executeCodeRequest.getInputList();</span><br><span class="line">        String code = executeCodeRequest.getCode();</span><br><span class="line">        String language = executeCodeRequest.getLanguage();</span><br><span class="line"></span><br><span class="line">        String userDir = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line">        String globalCodePathName = userDir + File.separator +GLOBAL_CODE_DIR_NAME;</span><br><span class="line"></span><br><span class="line">        //判断全局diamagnetic目录是否存在，没有则新建,有线程安全，不应该反复执行，放在全局共享类</span><br><span class="line">        if (!FileUtil.exist(globalCodePathName)) &#123;</span><br><span class="line">            FileUtil.mkdir(globalCodePathName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //把用户的代码隔离存放</span><br><span class="line">        String userCodeParentPath = globalCodePathName + File.separator + UUID.randomUUID();</span><br><span class="line">        String userCodePath = userCodeParentPath + File.separator + DEFAULT_JAVA_CLASS_NAME;</span><br><span class="line">        File userCodeFile = FileUtil.writeString(code, userCodePath, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>



<h5 id="2-编译代码。得到class文件"><a href="#2-编译代码。得到class文件" class="headerlink" title="2.编译代码。得到class文件"></a>2.编译代码。得到class文件</h5><p>Java执行程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process process = Runtime.getRuntime().exec(compileCmd);</span><br></pre></td></tr></table></figure>



<p>Java获取控制台的输出</p>
<p>通过exitValue判断程序是否正常返回，从inputStream和errorStream获取控制台输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String compileCmd = String.format(&quot;javac -encoding utf-8 %s&quot;,userCodeFile.getAbsoluteFile());</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; inputList = executeCodeRequest.getInputList();</span><br><span class="line">        String code = executeCodeRequest.getCode();</span><br><span class="line">        String language = executeCodeRequest.getLanguage();</span><br><span class="line"></span><br><span class="line">        //1.把用户的代码保存为文件</span><br><span class="line">        String userDir = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line">        String globalCodePathName = userDir + File.separator +GLOBAL_CODE_DIR_NAME;</span><br><span class="line"></span><br><span class="line">        //判断全局diamagnetic目录是否存在，没有则新建,有线程安全，不应该反复执行，放在全局共享类</span><br><span class="line">        if (!FileUtil.exist(globalCodePathName)) &#123;</span><br><span class="line">            FileUtil.mkdir(globalCodePathName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //把用户的代码隔离存放</span><br><span class="line">        String userCodeParentPath = globalCodePathName + File.separator + UUID.randomUUID();</span><br><span class="line">        String userCodePath = userCodeParentPath + File.separator + DEFAULT_JAVA_CLASS_NAME;</span><br><span class="line">        File userCodeFile = FileUtil.writeString(code, userCodePath, StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        //2.编译代码。得到class文件</span><br><span class="line">        String compileCmd = String.format(&quot;javac -encoding utf-8 %s&quot;,userCodeFile.getAbsoluteFile());</span><br><span class="line">        try &#123;</span><br><span class="line">            Process compileProcess = Runtime.getRuntime().exec(compileCmd);</span><br><span class="line">            //等待程序执行，获取错误码</span><br><span class="line">            int exitValue = compileProcess.waitFor();</span><br><span class="line">            //正常退出</span><br><span class="line">            if (exitValue == 0)&#123;</span><br><span class="line">                System.out.println(&quot;编译成功&quot;);</span><br><span class="line">                //分批获取进程的正常输出</span><br><span class="line">                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(compileProcess.getInputStream()));</span><br><span class="line">                StringBuilder compileOutPutStringBuilder = new StringBuilder();</span><br><span class="line">                //逐行读取</span><br><span class="line">                String compileOutputLine;</span><br><span class="line">                while ((compileOutputLine = bufferedReader.readLine())!= null)&#123;</span><br><span class="line">                    compileOutPutStringBuilder.append(compileOutputLine);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(compileOutPutStringBuilder);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                //异常退出</span><br><span class="line">                System.out.println(&quot;编译失败，错误码&quot;+exitValue);</span><br><span class="line">                //分批获取进程的正常输出</span><br><span class="line">                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(compileProcess.getInputStream()));</span><br><span class="line">                StringBuilder compileOutPutStringBuilder = new StringBuilder();</span><br><span class="line">                //逐行读取</span><br><span class="line">                String compileOutputLine;</span><br><span class="line">                while ((compileOutputLine = bufferedReader.readLine())!= null)&#123;</span><br><span class="line">                    compileOutPutStringBuilder.append(compileOutputLine);</span><br><span class="line">                &#125;</span><br><span class="line">                //分批获取进程的错误输出</span><br><span class="line">                BufferedReader errorBufferedReader = new BufferedReader(new InputStreamReader(compileProcess.getErrorStream()));</span><br><span class="line">                StringBuilder errorCompileOutPutStringBuilder = new StringBuilder();</span><br><span class="line">                //逐行读取</span><br><span class="line">                String errorCompileOutputLine;</span><br><span class="line">                while ((errorCompileOutputLine = errorBufferedReader.readLine())!= null)&#123;</span><br><span class="line">                    errorCompileOutPutStringBuilder.append(errorCompileOutputLine);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(compileOutPutStringBuilder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException | InterruptedException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>编写一共工具类，执行进程，并且获取输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 进程工具类</span><br><span class="line"> */</span><br><span class="line">public class ProcessUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行进程并获取信息</span><br><span class="line">     * </span><br><span class="line">     * @param runProcess</span><br><span class="line">     * @param opName</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static ExecuteMessage runProcessAndGetMessage(Process runProcess,String opName)&#123;</span><br><span class="line"></span><br><span class="line">        ExecuteMessage executeMessage = new ExecuteMessage;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //等待程序执行，获取错误码</span><br><span class="line">            int exitValue = runProcess.waitFor();</span><br><span class="line">            executeMessage.setExitCode(exitValue);</span><br><span class="line"></span><br><span class="line">            //正常退出</span><br><span class="line">            if (exitValue == 0)&#123;</span><br><span class="line">                System.out.println(opName+&quot;成功&quot;);</span><br><span class="line">                //分批获取进程的正常输出</span><br><span class="line">                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(runProcess.getInputStream()));</span><br><span class="line">                StringBuilder compileOutPutStringBuilder = new StringBuilder();</span><br><span class="line">                //逐行读取</span><br><span class="line">                String compileOutputLine;</span><br><span class="line">                while ((compileOutputLine = bufferedReader.readLine())!= null)&#123;</span><br><span class="line">                    compileOutPutStringBuilder.append(compileOutputLine);</span><br><span class="line">                &#125;</span><br><span class="line">                executeMessage.setMessage(compileOutPutStringBuilder.toString());</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                //异常退出</span><br><span class="line">                System.out.println(opName+&quot;失败，错误码&quot;+exitValue);</span><br><span class="line">                //分批获取进程的正常输出</span><br><span class="line">                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(runProcess.getInputStream()));</span><br><span class="line">                StringBuilder compileOutPutStringBuilder = new StringBuilder();</span><br><span class="line">                //逐行读取</span><br><span class="line">                String compileOutputLine;</span><br><span class="line">                while ((compileOutputLine = bufferedReader.readLine())!= null)&#123;</span><br><span class="line">                    compileOutPutStringBuilder.append(compileOutputLine);</span><br><span class="line">                &#125;</span><br><span class="line">                //分批获取进程的错误输出</span><br><span class="line">                BufferedReader errorBufferedReader = new BufferedReader(new InputStreamReader(runProcess.getErrorStream()));</span><br><span class="line">                StringBuilder errorCompileOutPutStringBuilder = new StringBuilder();</span><br><span class="line">                //逐行读取</span><br><span class="line">                String errorCompileOutputLine;</span><br><span class="line">                while ((errorCompileOutputLine = errorBufferedReader.readLine())!= null)&#123;</span><br><span class="line">                    errorCompileOutPutStringBuilder.append(errorCompileOutputLine);</span><br><span class="line">                &#125;</span><br><span class="line">                executeMessage.setErrorMessage(errorCompileOutPutStringBuilder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return executeMessage;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-执行程序"><a href="#3-执行程序" class="headerlink" title="3.执行程序"></a>3.执行程序</h5><p>同样是使用process运行，命令中记得增加-Dfile.encoding&#x3D;UTF-8参数，解决中文乱码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String rumCmd = String.format(&quot;java -Dfile.encoding=UTF-8 -cp %s Main %s&quot;,userCodeParentPath,inputArgs);</span><br></pre></td></tr></table></figure>



<p>很多OJ都是ACM模式，需要和用户交互的方式，让用户不断输入内容并获取输出。</p>
<p>对于此类程序，我们需要使用OutpuStream向程序终端发送参数，并及时获取结果，注意最后要关闭流释放资源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 执行交互式进程并获取信息</span><br><span class="line"> *</span><br><span class="line"> * @param runProcess</span><br><span class="line"> * @param opName</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static ExecuteMessage runInteractProcessAndGetMessage(Process runProcess,String args)&#123;</span><br><span class="line"></span><br><span class="line">    ExecuteMessage executeMessage = new ExecuteMessage();</span><br><span class="line">    try &#123;</span><br><span class="line">        //向控制台输入程序</span><br><span class="line">        OutputStream outputStream = runProcess.getOutputStream();</span><br><span class="line">        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);</span><br><span class="line">        String[] s = args.split(&quot; &quot;);</span><br><span class="line">        String join = StrUtil.join(&quot;\n&quot;, s)+&quot;\n&quot;;</span><br><span class="line">        outputStreamWriter.write(join);</span><br><span class="line">        //相当于回车，执行输入的发送</span><br><span class="line">        outputStreamWriter.flush();</span><br><span class="line"></span><br><span class="line">        //分批获取进程的正常输出</span><br><span class="line">        InputStream inputStream = runProcess.getInputStream();</span><br><span class="line">        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">        StringBuilder compileOutPutStringBuilder = new StringBuilder();</span><br><span class="line">        //逐行读取</span><br><span class="line">        String compileOutputLine;</span><br><span class="line">        while ((compileOutputLine = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">            compileOutPutStringBuilder.append(compileOutputLine);</span><br><span class="line">        &#125;</span><br><span class="line">        executeMessage.setMessage(compileOutPutStringBuilder.toString());</span><br><span class="line">        //记得资源释放，否则会卡顿</span><br><span class="line">        outputStreamWriter.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        runProcess.destroy();</span><br><span class="line">    &#125; catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return executeMessage;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-整理输出"><a href="#4-整理输出" class="headerlink" title="4.整理输出"></a>4.整理输出</h5><p>获取程序的执行时间，使用spring的StopWatch获取一段的执行时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StopWatch stopWatch = new StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">stopWatch.stop();    executeMessage.setTime(stopWatch.getLastTaskTimeMillis());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展：可以每个测试用例都有一共独立的内存，时间占用的统计</p>
</blockquote>
<p>此处我们使用最大值统计时间，便于后续判题服务计算程序是否超时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//取用时最大值，便于判断是否超时</span><br><span class="line">long maxTime = 0;</span><br><span class="line">for (ExecuteMessage executeMessage : executeMessagesList) &#123;</span><br><span class="line">    String errorMessage = executeMessage.getErrorMessage();</span><br><span class="line">    if (StrUtil.isNotBlank(errorMessage))&#123;</span><br><span class="line">        executeCodeResponse.setMessage(errorMessage);</span><br><span class="line">        //执行中存在错误</span><br><span class="line">        executeCodeResponse.setStatus(3);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    outputList.add(executeMessage.getMessage());</span><br><span class="line">    Long time = executeMessage.getTime();</span><br><span class="line">    if (time != null)&#123;</span><br><span class="line">        maxTime = Math.max(maxTime,time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-文件清理"><a href="#5-文件清理" class="headerlink" title="5.文件清理"></a>5.文件清理</h5><p>防止服务器空间不足</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//5.文件清理</span><br><span class="line">if (userCodeFile.getParentFile()!=null)&#123;</span><br><span class="line">    boolean del = FileUtil.del(userCodeParentPath);</span><br><span class="line">    System.out.println(&quot;删除&quot;+(del ? &quot;成功&quot; : &quot;失败&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="6-编写错误处理"><a href="#6-编写错误处理" class="headerlink" title="6.编写错误处理"></a>6.编写错误处理</h5><p>封装一共错误处理方法，当程序抛出异常时，直接返回错误响应</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 获取错误响应</span><br><span class="line">    * </span><br><span class="line">    * @param e</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   private ExecuteCodeResponse getErrorResponse(Throwable e)&#123;</span><br><span class="line">       ExecuteCodeResponse executeCodeResponse = new ExecuteCodeResponse();</span><br><span class="line">       executeCodeResponse.setOutputList(new ArrayList&lt;&gt;());</span><br><span class="line">       executeCodeResponse.setMessage(e.getMessage());</span><br><span class="line">       //2表示代码沙箱错误，表示本系统执行过程中的错误</span><br><span class="line">       executeCodeResponse.setStatus(2);</span><br><span class="line">       executeCodeResponse.setJudgeInfo(new JudgeInfo());</span><br><span class="line">       return executeCodeResponse;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="异常情况演示"><a href="#异常情况演示" class="headerlink" title="异常情况演示"></a>异常情况演示</h4><p>到目前为止，核心流程已经实现，但是想要上线的话，安全么？</p>
<p>用户提交恶意代码，如何解决？</p>
<h5 id="1-执行阻塞，占用资源不释放"><a href="#1-执行阻塞，占用资源不释放" class="headerlink" title="1.执行阻塞，占用资源不释放"></a>1.执行阻塞，占用资源不释放</h5><p>时间上的攻击</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 无线睡眠（阻塞程序执行）</span><br><span class="line"> */</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        long ONE_HOUR =60*60*1000L;</span><br><span class="line">        Thread.sleep(ONE_HOUR);</span><br><span class="line">        System.out.println(&quot;睡完了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要把写好的代码复制到resources中，并且一定要把类名改为Main! 包名一定要去掉！</p>
<h5 id="2-占用内存，不释放"><a href="#2-占用内存，不释放" class="headerlink" title="2.占用内存，不释放"></a>2.占用内存，不释放</h5><p>空间上的攻击</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 无限占用空间(浪费系统内存）</span><br><span class="line"> */</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //不能定义对象,JVM会回收</span><br><span class="line">        List&lt;byte[]&gt; bytes = new ArrayList&lt;&gt;();</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            bytes.add(new byte[10000]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实际运行中，会发现，内存占用到达一定的空间后，程序就会自动报错</p>
<p>这是JVM的保护机制。	</p>
<p>JVisualVM或 JConsole工具，可以连接到JVM虚拟机上来可视化查看JVM的状态。</p>
<p>方式：限制JVM内存</p>
<h5 id="3-读文件，文件信息泄露"><a href="#3-读文件，文件信息泄露" class="headerlink" title="3.读文件，文件信息泄露"></a>3.读文件，文件信息泄露</h5><p>直接通过相对路径获取文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 读取服务器文件（文件信息泄露）</span><br><span class="line"> */</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        String userDir = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line">        String filePath = userDir + File.separator + &quot;src/main/resources/application.yml&quot;;</span><br><span class="line">        List&lt;String&gt; allLines = Files.readAllLines(Paths.get(filePath));</span><br><span class="line">        System.out.println(String.join(&quot;\n&quot;,allLines));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-写文件，越权植入木马"><a href="#4-写文件，越权植入木马" class="headerlink" title="4.写文件，越权植入木马"></a>4.写文件，越权植入木马</h5><p>假设有一个木马程序：java -version 2&gt;&amp;1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 向服务器中写文件(植入危险程序)</span><br><span class="line"> */</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        String userDir = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line">        String filePath = userDir + File.separator + &quot;src/main/resources/木马程序.bat&quot;;</span><br><span class="line">        String errorProgram = &quot;java -version 2&gt;&amp;1&quot;;</span><br><span class="line">        Files.write(Paths.get(filePath), Arrays.asList(errorProgram));</span><br><span class="line">        System.out.println(&quot;木马写入成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="5-运行其它程序"><a href="#5-运行其它程序" class="headerlink" title="5.运行其它程序"></a>5.运行其它程序</h5><p>直接通过Process执行危险程序，或者电脑上的其它程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 运行其它程序（比如危险木马）</span><br><span class="line"> */</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class="line">        String userDir = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line">        String filePath = userDir + File.separator + &quot;src/main/resources/木马程序.bat&quot;;</span><br><span class="line">        Process process = Runtime.getRuntime().exec(filePath);</span><br><span class="line">        process.waitFor();</span><br><span class="line">        //分批获取进程的正常输出</span><br><span class="line">        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));</span><br><span class="line">        //逐行读取</span><br><span class="line">        String compileOutputLine;</span><br><span class="line">        while ((compileOutputLine = bufferedReader.readLine())!= null)&#123;</span><br><span class="line">            System.out.println(compileOutputLine);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;执行程序成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="6-执行高危命令"><a href="#6-执行高危命令" class="headerlink" title="6.执行高危命令"></a>6.执行高危命令</h5><p>甚至都不用写木马文件，直接执行系统自带的危险命令</p>
<p>比如删除服务器的所有文件</p>
<p>比如执行dir(windows)、ls(linux)获取你系统上的所有文件信息</p>
<h4 id="怎么解决？"><a href="#怎么解决？" class="headerlink" title="怎么解决？"></a>怎么解决？</h4><p>1.超时控制</p>
<p>2.限制给用户分配资源</p>
<p>3.限制代码-黑白名单</p>
<p>4.限制用户的操作权限（文件、网络、执行）</p>
<p>5.运行环境隔离</p>
<h5 id="1-超时控制"><a href="#1-超时控制" class="headerlink" title="1.超时控制"></a>1.超时控制</h5><p>通过创建一共守护线程，超时后自动中断process实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">                   //超时控制</span><br><span class="line">                   try &#123;</span><br><span class="line">                       Thread.sleep(TIME_OUT);</span><br><span class="line">                       System.out.println(&quot;超时了，中断&quot;);</span><br><span class="line">                       runProcess.destroy();</span><br><span class="line">                   &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                       throw new RuntimeException(e);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;).start();</span><br></pre></td></tr></table></figure>



<h5 id="2-限制资源分配"><a href="#2-限制资源分配" class="headerlink" title="2.限制资源分配"></a>2.限制资源分配</h5><p>我们不能让每个java进程的执行占用的JVM最大堆内存空间和系统的一致，实际上应该小一点。</p>
<p>在启动Java时，可以指定JVM参数：-Xmx256m(最大堆空间大小) -Xms(初始堆空间大小)</p>
<p>-Xms应用场景：一开始进程就可以分配到资源，不用浪费时间进行动态分配。</p>
<p>案例：游戏启动前要加载一堆东西或者hashmap性能高的话，一开始就定义好初始容量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx256m</span><br></pre></td></tr></table></figure>



<p>注意！-Xmx参数，JVM的堆内存限制，不等同于系统实际占用的最大资源，可能会超出。</p>
<p><img   src="F:\迅雷下载\work\notebook\source_posts\OJ判题\Snipaste_2024-06-12_23-08-48.png"  alt="Snipaste_2024-06-12_23-08-48"></p>
<p>如果需要更严格的内存限制，要在系统层面取限制，而不是JVM层面的限制。</p>
<p>如果是linux系统，可以使用cgroup来实现堆某个进程的CPU、内存等资源的分配。</p>
<h5 id="3-限制代码-黑白名单"><a href="#3-限制代码-黑白名单" class="headerlink" title="3.限制代码-黑白名单"></a>3.限制代码-黑白名单</h5><p>先定义一个黑名单，比如哪些操作是禁止的，可以是一个列表。</p>
<p>HuTool 字典树工具类：WordTree，可以用更少的存储空间存储更多的敏感词汇。实现更高效敏感词查找。</p>
<p>示例代码</p>
<p>1.初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static final WordTree WORD_TREE = new WordTree();</span><br><span class="line"></span><br><span class="line">//操作黑名单</span><br><span class="line">private static final List&lt;String&gt; blackList = Arrays.asList(&quot;File&quot;,&quot;exec&quot;);</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    //初始化字典树</span><br><span class="line">    //校验代码,查看代码文件里是否有进行黑名单里的操作</span><br><span class="line">    WORD_TREE.addWords(blackList);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.校验</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//校验代码中是否包含黑名单中的命令</span><br><span class="line">        FoundWord foundWord = WORD_TREE.matchWord(code);</span><br><span class="line">        if (foundWord != null)&#123;</span><br><span class="line">            System.out.println(&quot;包含禁止操作&quot;+foundWord.getFoundWord());</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>字典树原理：使用字典树能够<strong>节约空间</strong>，并且<strong>查找的时候会快一些</strong>（线性查找）</p>
<p><img   src="F:\迅雷下载\work\notebook\source_posts\OJ判题\Snipaste_2024-06-13_00-29-18.png"  alt="Snipaste_2024-06-13_00-29-18"></p>
<p>缺点：</p>
<p>1.你无法遍历所有的黑名单</p>
<p>2.不同的编程语言，对应的领域、关键词都不一样，限制人工成本很大</p>
<h5 id="4-限制用户的操作权限"><a href="#4-限制用户的操作权限" class="headerlink" title="4.限制用户的操作权限"></a>4.限制用户的操作权限</h5><p>限制用户对文件、内存、CPU、网络等资源的操作和访问。</p>
<p>Java安全管理器（Security Manager）是Java提供的保护JVM、Java安全的机制，可以实现更严格的资源和操作限制。</p>
<p>编写安全管理器，只需要继承</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 默认安全管理器</span><br><span class="line"> */</span><br><span class="line">public class DefaultSecurityManager extends SecurityManager &#123;</span><br><span class="line"></span><br><span class="line">    //检查所有的权限</span><br><span class="line">    @Override</span><br><span class="line">    public void checkPermission(Permission perm) &#123;</span><br><span class="line">        System.out.println(&quot;默认不做任何权限设置&quot;);</span><br><span class="line">        // super.checkPermission(perm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所有权限拒绝：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 禁用所有的安全管理器</span><br><span class="line"> */</span><br><span class="line">public class DenySecurityManager extends SecurityManager &#123;</span><br><span class="line"></span><br><span class="line">    //检查所有的权限</span><br><span class="line">    @Override</span><br><span class="line">    public void checkPermission(Permission perm) &#123;</span><br><span class="line">        throw new SecurityException(&quot;权限异常&quot;+perm.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>限制读权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//检测程序是否可读文件</span><br><span class="line">    @Override</span><br><span class="line">    public void checkRead(String file) &#123;</span><br><span class="line">        //放行对象</span><br><span class="line">        if (file.contains(&quot;hutool&quot;))&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new SecurityException(&quot;checkRead 权限异常&quot; + file);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>限制删除文件异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//检测程序是否允许删除文件</span><br><span class="line">    @Override</span><br><span class="line">    public void checkDelete(String file) &#123;</span><br><span class="line">        throw new SecurityException(&quot;checkDelete 权限异常&quot; + file);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>实际情况下，我们只需要限制子程序即可，没必要限制开发者自己写的程序。</p>
<p>在运行java程序时指定安全管理器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String rumCmd = String.format(&quot;java -Xmx256m -Dfile.encoding=UTF-8 -cp %s;%s -Djava.security.manager=MySecurityManger Main %s&quot;,userCodeParentPath,inputArgs);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>直接使用命令与上述安全管理器的区别</p>
<p>把安全器的类编译好后放到公共的目录中，不需要单独存放，减少占用空间，提高时间效率</p>
<p>过程：</p>
<p>1.编写安全管理器</p>
<p>2.编写安全管理器，去掉包名</p>
<p>3.在运行java程序时，指定安全管理器的路径，安全管理器的名称。</p>
<p>优点</p>
<p>权限控制很灵活，实现简单。</p>
<p>安全管理器缺点：</p>
<p>1.如果要做比较严格的权限控制，需要自己去判断哪些文件、包名需要允许读写，粒度太细了，难以精细化控制。</p>
<p>2.安全管理器本身也是Java代码，也有可能存在漏洞（还是程序上的限制，没到系统的层面）。</p>
<h5 id="5-运行环境隔离"><a href="#5-运行环境隔离" class="headerlink" title="5.运行环境隔离"></a>5.运行环境隔离</h5><blockquote>
<p>可以实现上述所有的问题</p>
</blockquote>
<p>系统层面上，把用户程序封装到沙箱里，和宿主机（电脑&#x2F;服务器）隔离开。</p>
<p>Docker容器技术能够实现（底层是用cgroup,namespace等方式实现的）。</p>
<h3 id="Docker容器技术"><a href="#Docker容器技术" class="headerlink" title="Docker容器技术"></a>Docker容器技术</h3><p>为什么要用Dicker容器技术？</p>
<p>为了提升系统的安全性，把某个程序（应用）和宿主机进行隔离，使得执行不会影响到系统本身。</p>
<p>Docker技术可以实现程序和宿主机的隔离。</p>
<h4 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h4><p>理解为对一系列应用程序，服务和环境的封装，从而把程序运行在一个隔离的，密闭的，隐私的空间内，对外提供服务。</p>
<blockquote>
<p>可以把容器理解为一共新的电脑（定制化的操作系统）</p>
</blockquote>
<h4 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h4><p>镜像：用来创建容器的安装包，可以理解为给电脑安装操作系统的系统镜像</p>
<p>容器：通过镜像来创建一套运行环境，一共容器可以运行多个程序，可以理解为一个电脑实例。</p>
<p>Dockerfile：制作镜像的文件，可以理解为制作镜像的一共清单</p>
<blockquote>
<p>类似Maven的pom.xml文件</p>
</blockquote>
<p>镜像仓库：存放镜像的仓库，用户可用从仓库下载现成的镜像，也可用把做好的镜像放到仓库中。</p>
<p>推荐使用docker官方的镜像仓库：<a class="link"   target="_blank" rel="noopener" href="https://hub.docker.com/" >https://hub.docker.com/<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="Docker实现原理"><a href="#Docker实现原理" class="headerlink" title="Docker实现原理"></a>Docker实现原理</h4><blockquote>
<p>Docker能实现哪些资源的隔离？</p>
</blockquote>
<ol>
<li>Docker运行在linux内核上</li>
<li>CGroups: 实现容器的网络资源管理,docker容器内部的网络互不影响</li>
<li>Network网络：实现容器的网络隔离，docker容器内部的网络互不影响</li>
<li>Namespace命名空间: 可以把进程隔离在不同的命名空间下，每个容器他都可以有命名空间，不同的命名空间下的进程互不影响。</li>
<li>Storage存储空间：容器内的文件相互隔离，也可以使用宿主机的文件</li>
</ol>
<p><img   src="F:\迅雷下载\work\notebook\source_posts\OJ判题\Snipaste_2024-06-13_08-13-57.png"  alt="Snipaste_2024-06-13_08-13-57"></p>
<blockquote>
<p>docker compose:是一种同时启动多个容器的集群操作工具（容器管理工具），一般情况下开发者仅做了解即可，实际使用docker compose时去百度配置文件</p>
</blockquote>
<h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><p>一般情况下，不建议在Windows系统上安装</p>
<p>Windows本身就自带了一个虚拟机叫WSL。但是不推荐。肯定不如一共专业的、隔离的虚拟机软件方便。</p>
<p>推荐使用虚拟机</p>
<h4 id="docker的常用操作"><a href="#docker的常用操作" class="headerlink" title="docker的常用操作"></a>docker的常用操作</h4><p>1.查看命令用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -help</span><br></pre></td></tr></table></figure>

<p>查看具体子命令的用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -help</span><br></pre></td></tr></table></figure>



<p>2.从远程仓库拉取镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hello-world</span><br></pre></td></tr></table></figure>



<p>3.根据镜像创建容器实例</p>
<p>启动实例，得到容器containerId:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create hello-wirld</span><br></pre></td></tr></table></figure>



<p>4.查看容器状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure>



<p>5.启动容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker start mystifying_shaimr</span><br></pre></td></tr></table></figure>



<p>6.查看日志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker mystifying_shaimr</span><br></pre></td></tr></table></figure>



<p>7.删除容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器名</span><br></pre></td></tr></table></figure>



<p>8.删除容器的镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像名</span><br></pre></td></tr></table></figure>



<p>9.推送镜像（类似git）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push image</span><br></pre></td></tr></table></figure>



<h4 id="java操作Docker"><a href="#java操作Docker" class="headerlink" title="java操作Docker"></a>java操作Docker</h4><p>使用Docker-Java: <a class="link"   target="_blank" rel="noopener" href="https://github.com/docker-java/docker-java" >https://github.com/docker-java/docker-java<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://github.com/docker-java/docker-java/blob/main/docs/getting_started.md" >https://github.com/docker-java/docker-java/blob/main/docs/getting_started.md<i class="fas fa-external-link-alt"></i></a></p>
<p>1.安装依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.docker-java&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;docker-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.github.docker-java/docker-java-transport-httpclient5 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.docker-java&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;docker-java-transport-httpclient5&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>DockerClientConfig: 用于定义初始化DockerClient的配置(类比MySQL的连接、线程数配置)</p>
<p>DockerHttpClient：用于向Docker守护进程（操作Docker的接口）发送请求的客户端。低层封装（不推荐使用），你要自己构建请求参数。(简单理解成JDBC)</p>
<p>DockerClient（推荐）：才是真正和Docker守护进程交互的，最方便的SDK，高层封装。对DockerHttpClient再进行一层封装（理解成MyBatis），提供了现成的增删改查</p>
<h4 id="Linux-Docker远程开发"><a href="#Linux-Docker远程开发" class="headerlink" title="Linux Docker远程开发"></a>Linux Docker远程开发</h4><h5 id="方法一：将代码上传到ubuntu系统"><a href="#方法一：将代码上传到ubuntu系统" class="headerlink" title="方法一：将代码上传到ubuntu系统"></a>方法一：将代码上传到ubuntu系统</h5><p>1.输入ifconfig查看ip地址</p>
<p>2.安装ssh协议</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<p>3.查看是否安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep ssh</span><br></pre></td></tr></table></figure>

<p>4.安装jdk</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure>

<p>5.安装maven</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install maven</span><br></pre></td></tr></table></figure>

<p>6.在idea指定配置，配置ip，用户名，密码</p>
<p>7.配置映射文件</p>
<p>缺点：麻烦</p>
<h5 id="方法二：Linux-Docker远程开发"><a href="#方法二：Linux-Docker远程开发" class="headerlink" title="方法二：Linux Docker远程开发"></a>方法二：Linux Docker远程开发</h5><p>Files-&gt;RemoteDevelopment</p>
<p>使用IDEA Development先上传代码到Linux，然后使用JetBrains远程开发完全连接Linux实时开发。</p>
<p>报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java: Cannot run program &quot;/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java&quot; (in directory &quot;/home/zlz/.cache/JetBrains/RemoteDev-IU/_home_zlz_zoj-code-sandbox/compile-server&quot;): error=0, Failed to exec spawn helper: pid: 31705, exit value: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果无法启动程序，在File-Setting-Compiler的最下面添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djdk.lang.Process.launchMechanism=vfork</span><br></pre></td></tr></table></figure>



<p>拉取镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> //获取默认的DockerClient</span><br><span class="line">        DockerClient dockerClient = DockerClientBuilder.getInstance().build();</span><br><span class="line">//        PingCmd pingCmd = dockerClient.pingCmd();</span><br><span class="line">//        pingCmd.exec();</span><br><span class="line">        String image = &quot;nginx:latest&quot;;</span><br><span class="line">        PullImageCmd pullImageCmd = dockerClient.pullImageCmd(image);</span><br><span class="line">        PullImageResultCallback pullImageResultCallback = new PullImageResultCallback() &#123;</span><br><span class="line">            //每执行一步调用</span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(PullResponseItem item) &#123;</span><br><span class="line">                System.out.println(&quot;下载镜像：&quot;+item.getStatus());</span><br><span class="line">                super.onNext(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //异步执行</span><br><span class="line">        pullImageCmd.exec(pullImageResultCallback)</span><br><span class="line">                .awaitCompletion();</span><br><span class="line">        System.out.println(&quot;下载完成&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>给docker加权限</p>
<p>1.查找用户组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group | grep &#x27;docker&#x27;</span><br></pre></td></tr></table></figure>

<p>如果此时没有输出则需要添加：sudo group add docker</p>
<p>2.将当前用户添加到用户组中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gpasswd -a $&#123;USER&#125; docker</span><br></pre></td></tr></table></figure>

<p>注意：之后运行可能还会报错，把虚拟机重启即可。</p>
<p>创建容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建容器</span><br><span class="line">CreateContainerCmd containerCmd = dockerClient.createContainerCmd(image);</span><br><span class="line">CreateContainerResponse createContainerResponse = containerCmd</span><br><span class="line">        .withCmd(&quot;echo&quot;,&quot;Hello Docker&quot;)</span><br><span class="line">        .exec();</span><br><span class="line">System.out.println(createContainerResponse);</span><br></pre></td></tr></table></figure>



<p>查看容器状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查看容器状态</span><br><span class="line">ListContainersCmd listContainersCmd = dockerClient.listContainersCmd();</span><br><span class="line">List&lt;Container&gt; containerList = listContainersCmd.withShowAll(true).exec();</span><br><span class="line">for (Container container : containerList) &#123;</span><br><span class="line">    System.out.println(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>启动容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//启动容器</span><br><span class="line">dockerClient.startContainerCmd(containerId).exec();</span><br></pre></td></tr></table></figure>



<p>在linux查看启动的容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a 查看当前正在运行的容器</span><br><span class="line">docker logs edae101e6954 查看容器的日志</span><br></pre></td></tr></table></figure>



<p>查看容器日志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//查看日志(异步读取，因为日志文件非常大)</span><br><span class="line">        LogContainerResultCallback logContainerResultCallback = new LogContainerResultCallback()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Frame item) &#123;</span><br><span class="line">                System.out.println(&quot;日志:&quot;+new String(item.getPayload()));</span><br><span class="line">                super.onNext(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //阻塞等待日志输出</span><br><span class="line">        dockerClient.logContainerCmd(containerId)</span><br><span class="line">                .withStdErr(true)</span><br><span class="line">                .withStdOut(true)</span><br><span class="line">                .exec(logContainerResultCallback)</span><br><span class="line">                .awaitCompletion();</span><br></pre></td></tr></table></figure>



<p>删除容器和镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//删除容器(强制删除)，链式调用</span><br><span class="line">dockerClient.removeContainerCmd(containerId).withForce(true).exec();</span><br><span class="line"></span><br><span class="line">//删除镜像</span><br><span class="line">dockerClient.removeImageCmd(image).exec();</span><br></pre></td></tr></table></figure>



<h4 id="Docker实现代码沙箱"><a href="#Docker实现代码沙箱" class="headerlink" title="Docker实现代码沙箱"></a>Docker实现代码沙箱</h4><p>实现流程：docker负责运行java程序，并且得到结果</p>
<ol>
<li><p>把用户的代码保存为文件</p>
</li>
<li><p>编译代码。得到class文件</p>
</li>
<li><p>把编译好的文件上传到容器环境内</p>
</li>
<li><p>在容器中执行代码，得到输出结果</p>
</li>
<li><p>收集整理输出结果</p>
</li>
<li><p>文件清理</p>
</li>
<li><p>错误处理，提升程序健壮性</p>
</li>
</ol>
<blockquote>
<p>模板方法设计模式</p>
</blockquote>
<h5 id="3-创建容器，上传编译文件"><a href="#3-创建容器，上传编译文件" class="headerlink" title="3.创建容器，上传编译文件"></a>3.创建容器，上传编译文件</h5><p>自定义容器的两者方式：</p>
<p>1.在 已有镜像的基础上再扩充：比如拉取现成的Java环境（包含jdk），再把编译后的文件复制到容器里。适合新项目，跑通流程。</p>
<p>2.完全自定义容器：适合比较成熟的项目，比如封装多个语言的环境和实现。</p>
<p>思考：我们每个测试用例都单独创建一个容器，每个容器都只执行一次java命令？</p>
<p>浪费性能，所以要创建一共<strong>可交互</strong>的容器，能接收多次输入并且输出。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CreateContainerResponse createContainerResponse = containerCmd</span><br><span class="line">        .withHostConfig()</span><br><span class="line">        .withAttachStderr(true)</span><br><span class="line">        .withAttachStdin(true)</span><br><span class="line">        .withAttachStdout(true)</span><br><span class="line">        .withTty(true)</span><br><span class="line">        .exec();</span><br></pre></td></tr></table></figure>



<p>容器会有并发问题吗？</p>
<p>每个容器都是隔离的，只要捕获输出时，线程内部不错乱就行。</p>
<p>创建容器时，可用指定文件路径Volumn映射，作用是把本地的文件同步到容器中，可以让容器访问。</p>
<blockquote>
<p>也可以叫容器挂载目录</p>
</blockquote>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HostConfig hostConfig = new HostConfig();</span><br><span class="line">hostConfig.setBinds(new Bind(userCodePath,new Volume(&quot;/app&quot;)));</span><br></pre></td></tr></table></figure>



<p>容器设置内存和CPU数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hostConfig.withMemory(100*1000*1000L);</span><br><span class="line">hostConfig.withCpuCount(1L);</span><br></pre></td></tr></table></figure>



<h5 id="4-启动容器，执行代码"><a href="#4-启动容器，执行代码" class="headerlink" title="4.启动容器，执行代码"></a>4.启动容器，执行代码</h5><p>Docker执行容器（操作已启动容器）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec</span><br></pre></td></tr></table></figure>



<p>示例执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//docker exec tender_cray java -cp /app Main 1 3</span><br></pre></td></tr></table></figure>



<p>问题:无法拉取docker镜像</p>
<p>解决方法：科学上网</p>
<p>网址：<a class="link"   target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2296763" >https://cloud.tencent.com/developer/article/2296763<i class="fas fa-external-link-alt"></i></a></p>
<p>注意，要把命令按照空格拆开，作为一共数组传递，否则可能会被识别为一个字符串，而不是多个参数。</p>
<p>创建命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] inputArgsArray = inputArgs.split(&quot; &quot;);</span><br><span class="line">        String[] cmdArray = ArrayUtil.append(new String[]&#123;&quot;java&quot;,&quot;-cp&quot;,&quot;Main&quot;,&quot;1&quot;,&quot;3&quot;&#125;,inputArgsArray) ;</span><br><span class="line">        ExecCreateCmdResponse execCreateCmdResponse = dockerClient.execCreateCmd(containerId)</span><br><span class="line">                .withCmd(cmdArray)</span><br><span class="line">                .withAttachStderr(true)</span><br><span class="line">                .withAttachStdin(true)</span><br><span class="line">                .withAttachStdout(true)</span><br><span class="line">                .exec();</span><br></pre></td></tr></table></figure>



<p>执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;创建执行命令&quot;+execCreateCmdResponse);</span><br><span class="line">            String execId = execCreateCmdResponse.getId();</span><br><span class="line">            ExecStartResultCallback execStartResultCallback = new ExecStartResultCallback() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onNext(Frame frame) &#123;</span><br><span class="line">                    StreamType streamType = frame.getStreamType();</span><br><span class="line">                    if (StreamType.STDERR.equals(streamType))&#123;</span><br><span class="line">                        System.out.println(&quot;输出错误结果&quot;+new String(frame.getPayload()));</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        System.out.println(&quot;输出结果&quot;+new String(frame.getPayload()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    super.onNext(frame);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            try &#123;</span><br><span class="line">                dockerClient.execStartCmd(execId)</span><br><span class="line">                        .exec(execStartResultCallback)</span><br><span class="line">                        .awaitCompletion();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(&quot;程序执行异常&quot;);</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>



<p>尽量复用之前的ExecuteMessage模式，在异步接口中填充正常和异常的信息</p>
<p>获取程序执行时间：和Java原生一样，使用StopWatch在执行前后统计时间</p>
<p>获取程序占用内存：</p>
<p>程序占用的内存每个时刻都在变化，所以你不可能获取到所有时间点的内存</p>
<p>我们要做的是，定义一共周期，定期地获取程序的内存。</p>
<p>监控内存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//获取占用的内存</span><br><span class="line">            StatsCmd statsCmd = dockerClient.statsCmd(containerId);</span><br><span class="line">            ResultCallback&lt;Statistics&gt; statisticsResultCallback = statsCmd.exec(new ResultCallback&lt;Statistics&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onNext(Statistics statistics) &#123;</span><br><span class="line">                    System.out.println(&quot;内存占用&quot; + statistics.getMemoryStats().getUsage());</span><br><span class="line">                    maxMemory[0] = Math.max(statistics.getMemoryStats().getUsage(), maxMemory[0]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onStart(Closeable closeable) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onError(Throwable throwable) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onComplete() &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void close() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>





<h4 id="Docker容器安全性"><a href="#Docker容器安全性" class="headerlink" title="Docker容器安全性"></a>Docker容器安全性</h4><p>1.超时控制</p>
<p>执行容器时，可以增加超时参数控制值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dockerClient.execStartCmd(execId)</span><br><span class="line">        .exec(execStartResultCallback)</span><br><span class="line">        .awaitCompletion(TIME_OUT, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<p>程序依旧会往下执行，如何区分超时和不超时？</p>
<p>解决方法：默认是超时，如果在规定时间内完成，再设置为不超时</p>
<p>可以定义一个标志，如果程序执行完成，把超时标志设置为false。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//默认设置为超时</span><br><span class="line">            final boolean[] timeout = &#123;true&#125;;</span><br><span class="line">            ExecStartResultCallback execStartResultCallback = new ExecStartResultCallback() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onComplete() &#123;</span><br><span class="line">                //如果执行完成则表示没超时</span><br><span class="line">                    timeout[0] = false;</span><br><span class="line">                    super.onComplete();</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>



<p>2.限制给用户程序分配资源</p>
<p>内存资源</p>
<p>通过HostConfig的withMemory等方法，设置容器的最大内存和资源限制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//创建容器</span><br><span class="line">CreateContainerCmd containerCmd = dockerClient.createContainerCmd(image);</span><br><span class="line">HostConfig hostConfig = new HostConfig();</span><br><span class="line">hostConfig.setBinds(new Bind(userCodePath,new Volume(&quot;/app&quot;)));</span><br><span class="line">hostConfig.withMemory(100*1000*</span><br><span class="line">1000L);</span><br><span class="line">//减少IO的频率，一定程度上增加稳定性</span><br><span class="line">hostConfig.withMemorySwap(1L);</span><br><span class="line">hostConfig.withCpuCount(1L);</span><br><span class="line">CreateContainerResponse createContainerResponse = containerCmd</span><br><span class="line">        .withHostConfig(hostConfig)</span><br><span class="line">        .withAttachStderr(true)</span><br><span class="line">        .withAttachStdin(true)</span><br><span class="line">        .withAttachStdout(true)</span><br><span class="line">        .withTty(true)</span><br><span class="line">        .exec();</span><br></pre></td></tr></table></figure>



<p>网络资源</p>
<p>创建容器时，设置网络配置为关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//网络拒绝</span><br><span class="line">.withNetworkDisabled(true)</span><br></pre></td></tr></table></figure>



<p>3.限制代码-黑名单</p>
<p>Docker容器已经做了系统层面的隔离，比较安全，但不能保证绝对安全。</p>
<p>​	a.结合Java安全管理器和其它策略去使用</p>
<p>​	b.限制用户不能向根目录写文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CreateContainerResponse createContainerResponse = containerCmd</span><br><span class="line">        .withHostConfig(hostConfig)</span><br><span class="line">        //限制用户不能向root根目录写文件</span><br><span class="line">        .withReadonlyRootfs(true)</span><br></pre></td></tr></table></figure>

<p>​	c.Linux自带的一些安全管理措施 seccdmp(Security Compute Mode)，Linux内核安全机制。</p>
<p>学习方法：</p>
<p>1.点进源码看</p>
<p>2.问AI相关实现</p>
<h4 id="模板方法模式优化代码沙箱"><a href="#模板方法模式优化代码沙箱" class="headerlink" title="模板方法模式优化代码沙箱"></a>模板方法模式优化代码沙箱</h4><p>1.定义一共模板方法抽象类</p>
<p>先复制具体实现类，把代码从完整的方法抽离成一个一个子流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 代码沙箱执行模板方法</span><br><span class="line">     * </span><br><span class="line">     * @param executeCodeRequest</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public ExecuteCodeResponse executeCode(ExecuteCodeRequest executeCodeRequest) &#123;</span><br><span class="line">//        System.setSecurityManager(new DenySecurityManager());</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; inputList = executeCodeRequest.getInputList();</span><br><span class="line">        String code = executeCodeRequest.getCode();</span><br><span class="line">        String language = executeCodeRequest.getLanguage();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //1.把用户的代码保存为文件</span><br><span class="line">        File userCodeFIle = saveCodeFile(code);</span><br><span class="line"></span><br><span class="line">        //2.编译代码。得到class文件</span><br><span class="line">        ExecuteMessage compileFileExecuteMessage = compileFile(userCodeFIle);</span><br><span class="line">        System.out.println(compileFileExecuteMessage);</span><br><span class="line"></span><br><span class="line">        //3.创建容器，把容器放到文件内</span><br><span class="line">        List&lt;ExecuteMessage&gt; executeMessages = runFile(userCodeFIle, inputList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //4.收集整理输出结果</span><br><span class="line">        ExecuteCodeResponse outputResponse = getOutputResponse(executeMessages);</span><br><span class="line"></span><br><span class="line">        //5.文件清理</span><br><span class="line">        boolean b = deleteFile(userCodeFIle);</span><br><span class="line">        if(!b)&#123;</span><br><span class="line">            log.error(&quot;deleteFile Error,userCodeFilePath = &#123;&#125;&quot;,userCodeFIle.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return outputResponse;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>2.定义子类的实现</p>
<p>Java原生代码实现，直接复用模板方法定义好的模板实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Java 原始代码沙箱实现（直接复用模板方法）</span><br><span class="line"> */</span><br><span class="line">public class JavaNativeCodeSandbox extends JavaCodeSandboxTemplate &#123;</span><br><span class="line"></span><br><span class="line">    //可以自定义流程</span><br><span class="line">//    @Override</span><br><span class="line">//    public File saveCodeFile(String code) &#123;</span><br><span class="line">//        File file = super.saveCodeFile(code);</span><br><span class="line">//        System.out.println(&quot;监控&quot;);</span><br><span class="line">//        return file;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ExecuteCodeResponse executeCode(ExecuteCodeRequest executeCodeRequest) &#123;</span><br><span class="line">        return super.executeCode(executeCodeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Docker代码沙箱实现，需要自行重写RunFile:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 3.创建容器，把容器放到文件内（自定义）</span><br><span class="line"> * @param userCodeFile</span><br><span class="line"> * @param inputList</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public List&lt;ExecuteMessage&gt; runFile(File userCodeFile, List&lt;String&gt; inputList) &#123;</span><br><span class="line">    String userCodeParentFile = userCodeFile.getParentFile().getAbsolutePath();</span><br><span class="line">    //获取默认的DockerClient</span><br><span class="line">    DockerClient dockerClient = DockerClientBuilder.getInstance().build();</span><br><span class="line">    //拉取镜像</span><br><span class="line">    String image = &quot;openjdk:8-alpine&quot;;</span><br><span class="line">    PullImageCmd pullImageCmd = dockerClient.pullImageCmd(image);</span><br><span class="line">    //如果是第一次执行则拉取镜像</span><br><span class="line">    if (FIRST_INIT)&#123;</span><br><span class="line">        PullImageResultCallback pullImageResultCallback = new PullImageResultCallback() &#123;</span><br><span class="line">            //每执行一步调用</span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(PullResponseItem item) &#123;</span><br><span class="line">                System.out.println(&quot;下载镜像：&quot;+item.getStatus());</span><br><span class="line">                super.onNext(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //异步执行</span><br><span class="line">        try &#123;</span><br><span class="line">            pullImageCmd.exec(pullImageResultCallback)</span><br><span class="line">                    .awaitCompletion();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(&quot;拉取镜像异常&quot;);</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;下载完成&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建容器</span><br><span class="line">    CreateContainerCmd containerCmd = dockerClient.createContainerCmd(image);</span><br><span class="line">    HostConfig hostConfig = new HostConfig();</span><br><span class="line">    hostConfig.withMemory(100*1000*1000L);</span><br><span class="line">    //减少IO的频率，一定程度上增加稳定性</span><br><span class="line">    hostConfig.withMemorySwap(1L);</span><br><span class="line">    hostConfig.withCpuCount(1L);</span><br><span class="line">    //todo 安全管理配置字符串</span><br><span class="line">    hostConfig.withSecurityOpts(Arrays.asList(&quot;seccomp=安全管理配置字符串&quot;));</span><br><span class="line">    hostConfig.setBinds(new Bind(userCodeParentFile,new Volume(&quot;/app&quot;)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CreateContainerResponse createContainerResponse = containerCmd</span><br><span class="line">            .withHostConfig(hostConfig)</span><br><span class="line">            //限制用户不能向root根目录写文件</span><br><span class="line">            .withReadonlyRootfs(true)</span><br><span class="line">            //网络拒绝</span><br><span class="line">            .withNetworkDisabled(true)</span><br><span class="line">            .withAttachStderr(true)</span><br><span class="line">            .withAttachStdin(true)</span><br><span class="line">            .withAttachStdout(true)</span><br><span class="line">            .withTty(true)</span><br><span class="line">            .exec();</span><br><span class="line">    System.out.println(createContainerResponse);</span><br><span class="line">    String containerId = createContainerResponse.getId();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //启动容器</span><br><span class="line">    dockerClient.startContainerCmd(containerId).exec();</span><br><span class="line"></span><br><span class="line">    //docker exec tender_cray java -cp /app Main 1 3</span><br><span class="line">    //执行命令并返回结果</span><br><span class="line">    List&lt;ExecuteMessage&gt; executeMessagesList = new ArrayList&lt;&gt;();</span><br><span class="line">    for (String inputArgs : inputList) &#123;</span><br><span class="line">        StopWatch stopWatch = new StopWatch();</span><br><span class="line">        String[] inputArgsArray = inputArgs.split(&quot; &quot;);</span><br><span class="line">        String[] cmdArray = ArrayUtil.append(new String[]&#123;&quot;java&quot;,&quot;-cp&quot;,&quot;Main&quot;,&quot;1&quot;,&quot;3&quot;&#125;,inputArgsArray) ;</span><br><span class="line">        ExecCreateCmdResponse execCreateCmdResponse = dockerClient.execCreateCmd(containerId)</span><br><span class="line">                .withCmd(cmdArray)</span><br><span class="line">                .withAttachStderr(true)</span><br><span class="line">                .withAttachStdin(true)</span><br><span class="line">                .withAttachStdout(true)</span><br><span class="line">                .exec();</span><br><span class="line">        System.out.println(&quot;创建执行命令&quot;+execCreateCmdResponse);</span><br><span class="line">        ExecuteMessage executeMessage = new ExecuteMessage();</span><br><span class="line">        final String[] message = &#123;null&#125;;</span><br><span class="line">        final String[] errorMessage = &#123;null&#125;;</span><br><span class="line">        long time = 0L;</span><br><span class="line">        //默认设置为超时</span><br><span class="line">        final boolean[] timeout = &#123;true&#125;;</span><br><span class="line">        String execId = execCreateCmdResponse.getId();</span><br><span class="line">        ExecStartResultCallback execStartResultCallback = new ExecStartResultCallback() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                //如果执行完成则表示没超时</span><br><span class="line">                timeout[0] = false;</span><br><span class="line">                super.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Frame frame) &#123;</span><br><span class="line">                StreamType streamType = frame.getStreamType();</span><br><span class="line">                if (StreamType.STDERR.equals(streamType))&#123;</span><br><span class="line">                    errorMessage[0] = new String(frame.getPayload());</span><br><span class="line">                    System.out.println(&quot;输出错误结果&quot;+ errorMessage[0]);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    message[0] = new String(frame.getPayload());</span><br><span class="line">                    System.out.println(&quot;输出结果&quot;+ message[0]);</span><br><span class="line">                &#125;</span><br><span class="line">                super.onNext(frame);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        final long[] maxMemory = &#123;0L&#125;;</span><br><span class="line"></span><br><span class="line">        //获取占用的内存</span><br><span class="line">        StatsCmd statsCmd = dockerClient.statsCmd(containerId);</span><br><span class="line">        ResultCallback&lt;Statistics&gt; statisticsResultCallback = statsCmd.exec(new ResultCallback&lt;Statistics&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Statistics statistics) &#123;</span><br><span class="line">                System.out.println(&quot;内存占用&quot; + statistics.getMemoryStats().getUsage());</span><br><span class="line">                maxMemory[0] = Math.max(statistics.getMemoryStats().getUsage(), maxMemory[0]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onStart(Closeable closeable) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable throwable) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void close() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        statsCmd.exec(statisticsResultCallback);</span><br><span class="line">        try &#123;</span><br><span class="line">            stopWatch.start();</span><br><span class="line">            dockerClient.execStartCmd(execId)</span><br><span class="line">                    .exec(execStartResultCallback)</span><br><span class="line">                    .awaitCompletion(TIME_OUT, TimeUnit.MILLISECONDS);</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            time = stopWatch.getTotalTimeMillis();</span><br><span class="line">            statsCmd.close();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(&quot;程序执行异常&quot;);</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        executeMessage.setMessage(message[0]);</span><br><span class="line">        executeMessage.setErrorMessage(errorMessage[0]);</span><br><span class="line">        executeMessage.setTime(time);</span><br><span class="line">        executeMessage.setMemory(maxMemory[0]);</span><br><span class="line">        executeMessagesList.add(executeMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    return executeMessagesList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="代码沙箱开放API"><a href="#代码沙箱开放API" class="headerlink" title="代码沙箱开放API"></a>代码沙箱开放API</h4><p>直接在controller暴露CodeSandbox定义的接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/execute&quot;)</span><br><span class="line">ExecuteCodeResponse execute(@RequestBody ExecuteCodeRequest executeCodeRequest)&#123;</span><br><span class="line">    if (executeCodeRequest == null)&#123;</span><br><span class="line">        throw new RuntimeException(&quot;请求参数为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return javaNativeCodeSandbox.executeCode(executeCodeRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>问题：调用别人的开放API调用失败，应该返回什么错误码?</p>
<p>本质上是内部系统出问题，使用500开头</p>
<h5 id="调用安全性"><a href="#调用安全性" class="headerlink" title="调用安全性"></a>调用安全性</h5><p>如果将服务不做任何权限校验，直接放到公网，是不安全的。</p>
<p>1.调用方与服务提供方之间约定一个字符串<strong>（最好加密）</strong></p>
<p>调用方</p>
<p>改造请求头</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//基本认证</span><br><span class="line">String authHeader = request.getHeader(AUTH_REQUEST_HEADER);</span><br><span class="line">if (!AUTH_REQUEST_SECRET.equals(authHeader))&#123;</span><br><span class="line">    response.setStatus(403);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>服务方</p>
<p>​	1.先定义约定的字符串</p>
<p>​	2.改造请求，从请求头中获取认证信息，并校验。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String responseStr = HttpUtil.createPost(url).header(AUTH_REQUEST_HEADER,AUTH_REQUEST_SECRET).body(json).execute().body();</span><br><span class="line">       if (StringUtils.isBlank(responseStr))&#123;</span><br><span class="line">           throw new BusinessException(ErrorCode.API_REQUEST_ERROR,&quot;executeCode remoteSanbox error, message = &quot;+responseStr);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>优点：实现最简单，比较适合内部系统之间的相互调用（相对可信的环境内部调用）</p>
<p>缺点：不够灵活，如果key泄露或变更，需要重启代码。</p>
<p>2.API签名认证的方式，给允许调用的人员分配accessKey、secretKey,然后校验两组key 是否匹配。</p>
<h4 id="跑通项目流程"><a href="#跑通项目流程" class="headerlink" title="跑通项目流程"></a>跑通项目流程</h4><p>准备微服务：将题目提交controller合并到题目controller</p>
<h3 id="单体项目改造成微服务"><a href="#单体项目改造成微服务" class="headerlink" title="单体项目改造成微服务"></a>单体项目改造成微服务</h3><h4 id="什么是微服务（思想）？"><a href="#什么是微服务（思想）？" class="headerlink" title="什么是微服务（思想）？"></a>什么是微服务（思想）？</h4><p>服务：提供某类功能的代码</p>
<p>微服务：专注于提供某类特定功能的代码，而不是把所有的代码全部放到同一个项目里。会把整个大的项目按照一定的功能，逻辑进行拆分，拆分为多个子模块，每个子模块独立允许，独立负责一类功能，子模块之间相互调用，互不影响。</p>
<p>一个公司：一个人干活，这个人icu了，公司直接倒闭</p>
<p>一个公司有多个不同类别的岗位，多个人干活，一个组挂了还有其它组可以正常工作，不会说公司直接倒闭，各组之间可能需要交互，来完成大的项目。</p>
<p>微服务的几个重要的因素：服务管理、服务调用、服务拆分。</p>
<h4 id="微服务实现技术？"><a href="#微服务实现技术？" class="headerlink" title="微服务实现技术？"></a>微服务实现技术？</h4><p>Spring Cloud</p>
<p><strong>Spring Cloud Alibaba(本项目采用)</strong></p>
<p>Dubbo(DubboX)</p>
<p>RPC(GRPC,TRPC)</p>
<p>本质上是通过HTTP、或者其它的网络协议进行通讯来实现的。</p>
<p>分布式：把一个项目部署到多个机器，把一个场景从单机到多机。</p>
<p>微服务：把一个大的项目进行拆分</p>
<h4 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h4><p><a class="link"   target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba" >https://github.com/alibaba/spring-cloud-alibaba<i class="fas fa-external-link-alt"></i></a></p>
<p>官网：<a class="link"   target="_blank" rel="noopener" href="https://sca.aliyun.com/" >https://sca.aliyun.com/<i class="fas fa-external-link-alt"></i></a></p>
<p>本质：在Spring Cloud的基础上，进行了增强。补充了一些额外的能力，根据阿里多年的业务沉淀做了一些定制化的开发。</p>
<p><strong>注意：要使用正确的Spring Cloud版本</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://sca.aliyun.com/docs/2021/overview/version-explain/?spm=5176.29160081.0.0.74801a1580pUYC" >https://sca.aliyun.com/docs/2021/overview/version-explain/?spm=5176.29160081.0.0.74801a1580pUYC<i class="fas fa-external-link-alt"></i></a></p>
<p>相关技术栈</p>
<ol>
<li><p>Spring Cloud Gateway：网关</p>
</li>
<li><p>Nacos：服务注册和配置中心,集中存管项目中所有服务的信息，便于服务之间找到彼此；同时，还支持集中存储整个项目中的配置。</p>
</li>
<li><p>Sentinel：熔断限流</p>
</li>
<li><p>Seata：分布式事务</p>
</li>
<li><p>RocketMQ：消息队列，削峰填谷</p>
</li>
<li><p>Docker：使用Docker进行容器化部署</p>
</li>
<li><p>Kubernetes：使用k8s进行容器化部署</p>
</li>
</ol>
<blockquote>
<p>扩展：discovery: <a class="link"   target="_blank" rel="noopener" href="https://github.com/Nepxion/Discovery" >https://github.com/Nepxion/Discovery<i class="fas fa-external-link-alt"></i></a> </p>
<p>对Spring Cloud进一步增强</p>
</blockquote>
<h4 id="改造前思考"><a href="#改造前思考" class="headerlink" title="改造前思考"></a>改造前思考</h4><p>从业务需求出发，思考单机和分布式的区别。</p>
<p>1.用户登录功能：需要改造为分布式登录</p>
<p>2.其它内容：</p>
<p>​	有没有用到单机锁？改造为分布式锁</p>
<p>​	有没有用到本地缓存？改造为分布式缓存（Redis）</p>
<p>​	需不需要用到分布式事务？比如操作多个库</p>
<h5 id="改造分布式登录"><a href="#改造分布式登录" class="headerlink" title="改造分布式登录"></a>改造分布式登录</h5><p>1.配置文件增加redis配置</p>
<p>2.引入redis依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- redis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>3.主类取消Redis自动配置的移除</p>
<p>4.在配置文件中修改session的存储方式为redis</p>
<p>5.使用redis-cli或者redis管理工具，查看是否有登录后的信息</p>
<h5 id="微服务的划分"><a href="#微服务的划分" class="headerlink" title="微服务的划分"></a>微服务的划分</h5><p>从业务出发，想一下哪些功能&#x2F;职责是一起的？</p>
<blockquote>
<p>公司老板给员工分工</p>
</blockquote>
<p>依赖服务：</p>
<ol>
<li>注册中心: Nacos</li>
<li>微服务网关（如果不开，前端需要调不同的接口）：Gateway汇总所有的接口,统一接收前端处理的请求。</li>
</ol>
<p>​	</p>
<p>公共模块：</p>
<p>​	common公共模块（zoj-backend-common）:全局异常处理器、请求响应封装类，公用的工具类等。</p>
<p>​	model模型模块（zoj-backend-model）：很多服务公用的实体类</p>
<p>​	公用接口模块（zoj-backend-service-client）:只存放接口，不存放实现（多个服务之间共享）。</p>
<p>业务功能和部署结构</p>
<ol>
<li>用户服务（zoj-backend-user-service：8102端口）<ol>
<li>注册</li>
<li>登录</li>
<li>用户管理</li>
</ol>
</li>
<li>题目服务（zoj-backend-question-service: 8103端口）<ol>
<li>创建题目（管理员）</li>
<li>删除题目（管理员）</li>
<li>修改题目（管理员）</li>
<li>搜索题目（用户）</li>
<li>在线做题（题目详情页）</li>
<li><strong>题目提交</strong></li>
</ol>
</li>
<li>判题服务（zoj-backend-judge-service，较重的操作，8104端口）<ol>
<li>执行判题逻辑</li>
<li>错误处理（内存溢出、安全性、超时）</li>
<li><strong>自主实现代码沙箱（安全沙箱）</strong></li>
<li>开放接口（提供一个独立的新服务）</li>
</ol>
</li>
</ol>
<blockquote>
<p>代码沙箱服务本身就是独立的，不用纳入Spring Cloud的管理</p>
</blockquote>
<h5 id="路由划分"><a href="#路由划分" class="headerlink" title="路由划分"></a>路由划分</h5><p>用SpringBoot的context-path统一修改各项目的接口前缀，比如：</p>
<p>用户服务：</p>
<pre><code> 1. /api/user
 2. /api/user/inner(原因：微服务需要相互协作，但是相互协作需要的接口不是全部都要暴露在外的，不是都要给用户请求)
</code></pre>
<p>​	比如：员工之间需要传输私密信息，而这些信息是不能暴露在外面的。</p>
<p>​	内部调用，网关层面要做限制。</p>
<p>题目服务：</p>
<pre><code> 1. /api/question（也包括题目提交信息）
 2. /api/question/inner(原因：微服务需要相互协作，但是相互协作需要的接口不是全部都要暴露在外的，不是都要给用户请求)
</code></pre>
<p>​	比如：员工之间需要传输私密信息，而这些信息是不能暴露在外面的。</p>
<p>​	内部调用，网关层面要做限制。</p>
<p>判题服务：</p>
<pre><code> 1. /api/judge
 2. /api/judge/inner(原因：微服务需要相互协作，但是相互协作需要的接口不是全部都要暴露在外的，不是都要给用户请求)
</code></pre>
<p>​	比如：员工之间需要传输私密信息，而这些信息是不能暴露在外面的。</p>
<p>​	内部调用，网关层面要做限制。</p>
<h5 id="Nacos注册中心启动"><a href="#Nacos注册中心启动" class="headerlink" title="Nacos注册中心启动"></a>Nacos注册中心启动</h5><blockquote>
<p>要在SpringCloud Alibaba文档中找对应的版本</p>
</blockquote>
<p>一定要选择2.2.0版本！！！</p>
<h4 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h4><p>Spring Cloud有相当多的依赖，参差不齐，不建议随意找一套配置，或者自己写。</p>
<p>建议用脚手架创建项目：<a class="link"   target="_blank" rel="noopener" href="https://start.aliyun.com/" >https://start.aliyun.com/<i class="fas fa-external-link-alt"></i></a></p>
<p>注意：不需要一开始就引入所有的需要的包，比较定制化的内容，可以单独引入</p>
<p>给项目引入全局依赖配置。</p>
<p>创建完初始项目后，补充Spring Cloud 依赖:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2021.0.5&lt;/version&gt;</span><br><span class="line">    &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">    &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>OpenFegin:服务之间相互调用的组件。</p>
<p>1.依次使用 new modules和spring boot Initializer创建各模块</p>
<p>2.需要给各模块之间绑定子父依赖关系</p>
<p>​	父模块定义modules,子模块引入parent语法，可以通过继承父模块配置，统一项目的定义和版本号。</p>
<h4 id="同步代码和依赖"><a href="#同步代码和依赖" class="headerlink" title="同步代码和依赖"></a>同步代码和依赖</h4><p>移动backend代码，把公共模块移动到common下，删除AOP</p>
<p>在外层的pom.xml中引入公共类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.8.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-collections4 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>2.model模块</p>
<p>引入model包，注意引入代码沙箱的model包</p>
<p>3.公用接口模块</p>
<p>把所有的service引入。</p>
<p>需要指定openfegin客户端调用工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>4.具体服务的实现</p>
<p>给所有业务服务引入公共依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.zlz&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zoj-backend-common&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.zlz&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zoj-backend-model&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>注意：要使用全局异常处理器（Bean）,但是又不是在同一个模块，默认是扫描不到这个类的，所以异常处理器就不会生效，苏便宜需要在主类上指定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan(&quot;com.zlz&quot;)</span><br></pre></td></tr></table></figure>

<p>删除所有无关的代码</p>
<p>修改application.yml的配置，比如名称，端口号</p>
<p>主类引入注解</p>
<h4 id="服务内部调用"><a href="#服务内部调用" class="headerlink" title="服务内部调用"></a>服务内部调用</h4><p>问题：模块拆分后无法找到对应的模块？找不到对应的Bean</p>
<p>涉及服务通讯。</p>
<p>可以使用Open Fegin组件实现跨服务的远程调用</p>
<p>Open Fegin: Http调用客户端，提供了更方便的方式来让你远程调用其它服务，不用关心服务的调用地址。</p>
<p>Nacos注册中心获取服务调用地址。</p>
<h5 id="1-梳理服务的调用关系，确定哪些服务（接口）需要给内部调用"><a href="#1-梳理服务的调用关系，确定哪些服务（接口）需要给内部调用" class="headerlink" title="1.梳理服务的调用关系，确定哪些服务（接口）需要给内部调用"></a>1.梳理服务的调用关系，确定哪些服务（接口）需要给内部调用</h5><p>​	查看代码</p>
<p>用户服务：没有其它的依赖</p>
<p>题目服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">userService.getLoginUser(request);</span><br><span class="line">userService.isAdmin(request);</span><br><span class="line">userService.getById(userId);</span><br><span class="line">userService.getUserVO(user);</span><br><span class="line">userService.listByIds(userIdSet).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(User::getId));</span><br><span class="line">judgeService.doJudge(questionSubmitId);</span><br></pre></td></tr></table></figure>

<p>判题服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">questionService.getById(questionId);</span><br><span class="line">questionSubmitService.getById(questionSubmitId);</span><br><span class="line">questionSubmitService.updateById(questionSubmitUpdate)</span><br></pre></td></tr></table></figure>



<h5 id="2-要确认提供哪些服务。"><a href="#2-要确认提供哪些服务。" class="headerlink" title="2.要确认提供哪些服务。"></a>2.要确认提供哪些服务。</h5><p>用户服务：没有其它的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">userService.getLoginUser(request);</span><br><span class="line">userService.isAdmin(request);</span><br><span class="line">userService.getById(userId);</span><br><span class="line">userService.getUserVO(user);</span><br><span class="line">userService.listByIds(userIdSet).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(User::getId));</span><br></pre></td></tr></table></figure>

<p>题目服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">questionService.getById(questionId);</span><br><span class="line">questionSubmitService.getById(questionSubmitId);</span><br><span class="line">questionSubmitService.updateById(questionSubmitUpdate);</span><br></pre></td></tr></table></figure>

<p>判题服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">judgeService.doJudge(questionSubmitId);</span><br></pre></td></tr></table></figure>



<h5 id="3-在serviceClient编写工具类代码"><a href="#3-在serviceClient编写工具类代码" class="headerlink" title="3.在serviceClient编写工具类代码"></a>3.在serviceClient编写工具类代码</h5><p>修改接口名称为 服务名+FeignClient</p>
<p>如果是简单的接口，为了节省性能，可以直接实现，不需要使用Fegin调用了，把改类当成工具类使用即可。</p>
<p>不涉及数据库的操作，就是简单的java语法判断。</p>
<p>例如：获取当前登录用户（直接从session中得到，不查数据库，会浪费很多性能）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取当前登录用户</span><br><span class="line"> *</span><br><span class="line"> * @param request</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">default User getLoginUser(HttpServletRequest request)&#123;</span><br><span class="line">    // 先判断是否已登录</span><br><span class="line">    Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);</span><br><span class="line">    User currentUser = (User) userObj;</span><br><span class="line">    if (currentUser == null || currentUser.getId() == null) &#123;</span><br><span class="line">        throw new BusinessException(ErrorCode.NOT_LOGIN_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    return currentUser;</span><br><span class="line">&#125;</span><br><span class="line">    /**</span><br><span class="line"> * 是否为管理员</span><br><span class="line"> *</span><br><span class="line"> * @param user</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">default boolean isAdmin(User user)&#123;</span><br><span class="line">    return user != null &amp;&amp; UserRoleEnum.ADMIN.getValue().equals(user.getUserRole());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取脱敏的用户信息</span><br><span class="line"> *</span><br><span class="line"> * @param user</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">default UserVO getUserVO(User user) &#123;</span><br><span class="line">    if (user == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    UserVO userVO = new UserVO();</span><br><span class="line">    BeanUtils.copyProperties(user, userVO);</span><br><span class="line">    return userVO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这里不能使用ThreadLocal，因为它使用的是本地的服务</p>
<h5 id="4-编写client接口注解"><a href="#4-编写client接口注解" class="headerlink" title="4.编写client接口注解"></a>4.编写client接口注解</h5><p>开启openfegin的支持，把接口暴露出去（服务注册到注册中心上），作为API给其它服务调用（其它服务从注册中心寻找）。</p>
<p>​	1.需要在对外暴露的接口上打上注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name = &quot;zoj-backend-user-service&quot;,path = &quot;/api/user&quot;)</span><br></pre></td></tr></table></figure>

<p>其中name属性和application.yml定义的name属性对应</p>
<p>​	</p>
<p>​	2.修改每个服务提供者的context-path全局请求路径以及修改controller接口上的路径，不然出现路径错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/&quot;)</span><br></pre></td></tr></table></figure>



<p>服务提供者：理解为接口的实现类，实际提供服务的模块（服务注册到注册中心上）。</p>
<p>服务消费者：理解为接口的调用方，需要去找到服务提供者，然后调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  address: 0.0.0.0</span><br><span class="line">  port: 8103</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /api/question</span><br></pre></td></tr></table></figure>

<p>​	3.对每个服务的方法还要编写具体的请求地址（跟单体项目中controller的请求地址一样），参数也要打上注解，不然参数是无法传递的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据id获取用户</span><br><span class="line"> *</span><br><span class="line"> * @param userId</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@GetMapping(&quot;/get/id&quot;)</span><br><span class="line">User getById(@RequestParam(&quot;userId&quot;) long userId);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>(1).<strong>区分Get、Post</strong></p>
<p>(2).<strong>Json使用@RequestBody，参数使用@RequestParam</strong></p>
<p>路径不需要参数吗？写法：&#x2F;get&#x2F;${id}</p>
<p>可以不用，取决于对接口的定义。</p>
<p><strong>不需要远程调用的方法不用打注解，用关键词default修饰的方法</strong></p>
<p>对于用户服务，有一些不利于远程调用的参数传递或者实现起来非常简单（工具类），可以直接使用默认类，无需远程调用，节约性能。</p>
<p>应用场景：公共类</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取当前登录用户</span><br><span class="line"> *</span><br><span class="line"> * @param request</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">default User getLoginUser(HttpServletRequest request)&#123;</span><br><span class="line">    // 先判断是否已登录</span><br><span class="line">    Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);</span><br><span class="line">    User currentUser = (User) userObj;</span><br><span class="line">    if (currentUser == null || currentUser.getId() == null) &#123;</span><br><span class="line">        throw new BusinessException(ErrorCode.NOT_LOGIN_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    return currentUser;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 题目表服务</span><br><span class="line"> *</span><br><span class="line"> * @author &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="line"> * @from &lt;a href=&quot;https://www.code-nav.cn&quot;&gt;编程导航学习圈&lt;/a&gt;</span><br><span class="line"> */</span><br><span class="line">@FeignClient(name = &quot;zoj-backend-question-service&quot;, path = &quot;/api/question&quot;)</span><br><span class="line">public interface QuestionFeignClient &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/get/id&quot;)</span><br><span class="line">    Question getQuestionById(@RequestParam(&quot;questionId&quot;) long questionId);</span><br><span class="line">    </span><br><span class="line">    @GetMapping(&quot;/question_submit/get/id&quot;)</span><br><span class="line">    Question getQuestionSubmitById(@RequestParam(&quot;questionSubmitId&quot;) long questionSubmitId);</span><br><span class="line">    </span><br><span class="line">    @GetMapping(&quot;/question_submit/update&quot;)</span><br><span class="line">    boolean updateQuestionSubmitById(@RequestBody QuestionSubmit questionSubmit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>注意：这里不需要对着controller写，因为这里只是对着服务实现类（调用方）调用的情况（参数和返回值）进行编写，这些服务还没有在controller中实现。</p>
<p>规范：在编写文档的时候就要把这些调用服务的接口路径定义好。</p>
<p>(3)<strong>.FeginClient定义的请求路径一定要和服务器提供方实际的请求路径保持一致</strong>。</p>
<p>内部服务要打上&#x2F;inner</p>
<p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判题相关代码：为微服务做准备</span><br><span class="line"> * 判题服务</span><br><span class="line"> */</span><br><span class="line">@FeignClient(name = &quot;zoj-backend-judge-service&quot;, path = &quot;/api/judge/inner&quot;)</span><br><span class="line">public interface JudgeFeignClient &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判题</span><br><span class="line">     *</span><br><span class="line">     * @param questionSubmitId</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/do&quot;)</span><br><span class="line">    QuestionSubmit doJudge(@RequestParam(&quot;questionSubmitId&quot;) long questionSubmitId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-重构项目代码"><a href="#5-重构项目代码" class="headerlink" title="5.重构项目代码"></a>5.重构项目代码</h5><p>​	a.修改有依赖关系的服务代码</p>
<p>​	注意：内部调用的service不需要改，只改外部调用的服务的服务名，不改服务内部继承的实现接口</p>
<h5 id="6-编写feignClient服务的实现类"><a href="#6-编写feignClient服务的实现类" class="headerlink" title="6.编写feignClient服务的实现类"></a>6.编写feignClient服务的实现类</h5><p>编写内部实现类，供内部访问，注意要和定义的客户端保持一致</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.zlz.zojbackenduserservice.controller.inner;</span><br><span class="line"></span><br><span class="line">import com.zlz.zojbackendmodel.entity.User;</span><br><span class="line">import com.zlz.zojbackendserviceclient.service.UserFeignClient;</span><br><span class="line">import com.zlz.zojbackenduserservice.service.UserService;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 内部服务实现类</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/inner&quot;)</span><br><span class="line">public class InnerUserController implements UserFeignClient &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private UserService userService;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 根据id获取用户</span><br><span class="line">     *</span><br><span class="line">     * @param userId</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    @GetMapping(&quot;/get/id&quot;)</span><br><span class="line">    public User getById(@RequestParam(&quot;userId&quot;) long userId)&#123;</span><br><span class="line">        return userService.getById(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id获取用户列表</span><br><span class="line">     *</span><br><span class="line">     * @param idList mybatisplus默认提供的类</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    @GetMapping(&quot;/get/ids&quot;)</span><br><span class="line">    public List&lt;User&gt; listByIds(@RequestParam(&quot;idList&quot;) Collection&lt;Long&gt; idList)&#123;</span><br><span class="line">        return userService.listByIds(idList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本质上：就是把提供的服务接口进行统一管理，通过重写接口的方式对服务进行拆分。</p>
<p>注意：重写的接口的地址要于接口定义的地址保持一致</p>
<h5 id="7-开启注册中心"><a href="#7-开启注册中心" class="headerlink" title="7.开启注册中心"></a>7.开启注册中心</h5><p>启动nacos</p>
<p>windows</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure>

<p>Linux</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh -m standalone</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	1.引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>​	2.编写配置（必须是服务）</p>
<p>网关、三个服务、ServiceClient</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      serverAddr: 127.0.0.1:8848</span><br><span class="line">  config:</span><br><span class="line">    import:</span><br><span class="line">      - nacos:nacos-config-example.properties?refreshEnabled=true</span><br></pre></td></tr></table></figure>

<p>​	3.给业务服务项目启动类打上注解，开启服务发现，找到对应的客户端Bean的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//开启服务发现</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">//扫描服务接口（指定客户端的包路径）</span><br><span class="line">@EnableFeignClients(&quot;com.zlz.zojbackendserviceclient.service&quot;)</span><br></pre></td></tr></table></figure>

<p>服务启动时，去nacos上注册服务，然后去nacos上找服务。项目启动时去目标包路径上去找，如果找到目标FeginClient就把Bean注册到服务内部,当你使用FeginClient，就能找到已有的实现类，启动服务时就不会出现却Bean</p>
<p>注意：这里网关不需要打上调用服务注解，因为网关不涉及服务的内部的调用所以只需要加服务发现即可。</p>
<p>​	4.编写负载均衡器</p>
<p>原因：OpenFegin调用服务时是多台机器同时提供题目服务，它最终调用多个题目服务的时候选择其中一个服务实例去调用</p>
<p>引入Spring Cloud load balance</p>
<p>全局引入负载均衡器依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.5&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>报错描述：相同的Bean被重复注册？</p>
<p>解决：查看是否有引入服务依赖，有则删除。</p>
<p>如果出现404，可以考虑在网页中输路径调试哪个端口出问题。</p>
<h5 id="8-启动项目，测试依赖能否注入，能否完成相互调用"><a href="#8-启动项目，测试依赖能否注入，能否完成相互调用" class="headerlink" title="8.启动项目，测试依赖能否注入，能否完成相互调用"></a>8.启动项目，测试依赖能否注入，能否完成相互调用</h5><h4 id="微服务网关"><a href="#微服务网关" class="headerlink" title="微服务网关"></a>微服务网关</h4><p>为什么要用？</p>
<p>​	1.所有的服务端口不同，增大了前端调用成本</p>
<p>​	2.所有服务是分散的，你可需要集中进行管理，比如集中解决跨域，鉴权，接口文档，服务的路由、接口安全性，流量染色，限流。</p>
<p>是什么？</p>
<blockquote>
<p>Gateway聚合所有的接口，统一接受处理前端的请求</p>
<p>缺点：想定义一些功能，需要对这个技术有比较深的理解。</p>
</blockquote>
<p>Gateway是应用层网关：会有一些业务逻辑（比如根据用户信息判断权限）</p>
<p>Nginx是接入层网关: 比如每个请求的日志，通常没有业务逻辑。</p>
<p>注意：gateway也需要注册到注册中心。</p>
<h5 id="接口路由"><a href="#接口路由" class="headerlink" title="接口路由"></a>接口路由</h5><p>统一接受前端的请求，转发请求到对应的服务。</p>
<p>如何找到路由？可以编写一套路由配置，通过api地址前缀来找到对应的服务。</p>
<p>网关配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      serverAddr: 127.0.0.1:8848</span><br><span class="line">    gateway:</span><br><span class="line">      routes: </span><br><span class="line">        - id: zoj-backend-user-service</span><br><span class="line">        //lb的作用是负载均衡</span><br><span class="line">          uri: lb://zoj-backend-user-service</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/api/question/**</span><br><span class="line">        - id: zoj-backend-question-service</span><br><span class="line">          uri: lb://zoj-backend-question-service</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/api/user/**</span><br><span class="line">        - id: zoj-backend-judge-service</span><br><span class="line">          uri: lb://zoj-backend-judge-service</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/api/judge/**</span><br><span class="line">  application:</span><br><span class="line">    name: zoj-backend-gateway</span><br><span class="line">  main:</span><br><span class="line">    web-application-type: reactive</span><br></pre></td></tr></table></figure>

<p>网关启动时会自动加载mybatisplus，会报错所以需要在主类加注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span><br></pre></td></tr></table></figure>



<h5 id="聚合文档"><a href="#聚合文档" class="headerlink" title="聚合文档"></a>聚合文档</h5><p>以一个全局的视角集中查看管理。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://doc.xiaominfo.com/docs/middleware-sources/spring-cloud-gateway/spring-gateway-introduction" >https://doc.xiaominfo.com/docs/middleware-sources/spring-cloud-gateway/spring-gateway-introduction<i class="fas fa-external-link-alt"></i></a></p>
<p>1.先给所有业务服务引入依赖，同时开启接口文档</p>
<p>接口文档生成器，非常方便</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;knife4j-gateway-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">knife4j:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<p>2.给网关配置集中管理文档</p>
<p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;knife4j-gateway-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>引入配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">knife4j:</span><br><span class="line">  gateway:</span><br><span class="line">    # ① 第一个配置，开启gateway聚合组件</span><br><span class="line">    enabled: true</span><br><span class="line">    # ② 第二行配置，设置聚合模式采用discover服务发现的模式</span><br><span class="line">    strategy: discover</span><br><span class="line">    discover:</span><br><span class="line">      # ③ 第三行配置，开启discover模式</span><br><span class="line">      enabled: true</span><br><span class="line">      # ④ 第四行配置，聚合子服务全部为Swagger2规范的文档</span><br><span class="line">      version: swagger2</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="跨域解决"><a href="#跨域解决" class="headerlink" title="跨域解决"></a>跨域解决</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 处理跨域</span><br><span class="line">@Configuration</span><br><span class="line">public class CorsConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CorsWebFilter corsFilter() &#123;</span><br><span class="line">        CorsConfiguration config = new CorsConfiguration();</span><br><span class="line">        config.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">        config.setAllowCredentials(true);</span><br><span class="line">        // todo 实际改为线上真实域名、本地域名</span><br><span class="line">        config.setAllowedOriginPatterns(Arrays.asList(&quot;*&quot;));</span><br><span class="line">        config.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser());</span><br><span class="line">        source.registerCorsConfiguration(&quot;/**&quot;, config);</span><br><span class="line">        return new CorsWebFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="权限校验"><a href="#权限校验" class="headerlink" title="权限校验"></a>权限校验</h5><p>可以使用Spring Cloud Gateway的Filter请求拦截器，接收到请求后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 内部拦截器</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class GlobalAuthFilter implements GlobalFilter, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    private AntPathMatcher antPathMatcher = new AntPathMatcher();</span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        ServerHttpRequest serverHttpRequest = exchange.getRequest();</span><br><span class="line">        String path = serverHttpRequest.getURI().getPath();</span><br><span class="line">        //判断路径中是否包含inner，只允许内部调用</span><br><span class="line">        if (antPathMatcher.match(&quot;/**/inner/**&quot;,path))&#123;</span><br><span class="line">            ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">            response.setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">            DataBufferFactory dataBufferFactory = response.bufferFactory();</span><br><span class="line">            DataBuffer dataBuffer = dataBufferFactory.wrap(&quot;无权限&quot;.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            return response.writeWith(Mono.just(dataBuffer));</span><br><span class="line">        &#125;</span><br><span class="line">        //todo 统一权限校验 使用JWT</span><br><span class="line">        return chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 系统变复杂之后，会定义多个拦截器，在这里设置拦截器顺序</span><br><span class="line">     * 拦截器优先级提到最高</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>扩展：可以在网关实现Sentinel接口限流降级</p>
<p>可以使用JWT Token实现用户登录，在网关层面通过token获取登录信息</p>
</blockquote>
<h5 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h5><p>针对有必要用微服务吗？</p>
<p>针对有必要用Spring Cloud微服务吗？</p>
<p>企业内部一般使用API(RPC,HTTP)实现跨部门，跨服务的调用。数据格式和调用代码全部自动生成，保持统一，同时解耦。</p>
<h4 id="消息队列解耦"><a href="#消息队列解耦" class="headerlink" title="消息队列解耦"></a>消息队列解耦</h4><p>此处选用RabbitMQ消息队列改造项目，解耦判题服务和题目服务，题目服务只需要向消息队列发消息，判题服务从消息队列中取消息执行判题，然后异步更新数据库即可。</p>
<p>要传递的消息是什么？</p>
<p>目的：为了解耦判题操作。找对应操作。</p>
<p>注意：消息队列如果执行失败，重新执行任务时会发生死循环，导致电脑卡死，所以还是不要重新入队。</p>
<blockquote>
<p>扩展：处理消息重试，避免消息堆积</p>
<p>扩展：压力测试，验证</p>
</blockquote>

                    
                </div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/2024/07/15/%E8%81%9A%E5%90%88%E6%90%9C%E7%B4%A2/"
                                   title=""
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis"></span>
                                        <span class="post-nav-item">Prev posts</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2024/03/26/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/"
                                   title="客流量智能分析平台"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">客流量智能分析平台</span>
                                        <span class="post-nav-item">Next posts</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
        &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2024
        
            &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">Keep Team</a>
        
    </div>

    <div class="theme-info info-item">
        Powered by&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;&&nbsp;Theme&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div>

    

    

    
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="post-tools-list border-box">
        <!-- PC encrypt again -->
        

        <!-- PC TOC show toggle -->
        

        <!-- PC go comment -->
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-toggle-theme-mode flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    

    <!-- tablet toc -->
    
</main>



<!-- common -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local-search -->


<!-- lazyload -->


<div class="">
    <!-- home page -->
    

    <!-- post page -->
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        

        <!-- copyright-info -->
        

        <!-- share -->
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->



</body>
</html>
