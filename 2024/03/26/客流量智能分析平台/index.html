<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Keep Team">
    
    <title>
        
            客流量智能分析平台 |
        
        Keep Theme
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.svg">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"Keep Theme","author":"Keep Team","avatar":"/images/avatar.svg","logo":"/images/logo.svg","favicon":"/images/logo.svg"},"menu":{"home":"/","archives":"/archives"},"first_screen":{"enable":false,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Keep writing and Keep loving.","hitokoto":false},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":false,"hide_header":true},"home":{"announcement":null,"category":false,"tag":false,"post_datetime":"updated"},"post":{"author_badge":{"enable":true,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":false,"min2read":false},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":false,"share":false,"reward":{"enable":false,"img_link":null,"text":null}},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"toc":{"enable":false,"number":false,"expand_all":false,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":false,"site_uv":false,"site_pv":false,"page_pv":false}},"local_search":{"enable":false,"preload":false},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.36"},"waline":{"server_url":null,"reaction":false,"version":"3.2.1"},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":false},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":false},"footer":{"since":2020,"word_count":false,"site_deploy":{"enable":false,"provider":"github","url":null},"record":{"enable":false,"list":[{"code":null,"link":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"root":"","source_data":{},"version":"4.1.5"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original post title","author":"Original post author","link":"Original post link"}
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               Keep Theme
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                
                                HOME
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                
                                ARCHIVES
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/"
                    >HOME</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives"
                    >ARCHIVES</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        客流量智能分析平台
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/avatar.svg">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">Keep Team</span>
                                
                                    <span class="author-badge">Lv1</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024-03-26 20:24:05</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Thu Apr 18 2024 23:45:07 GMT+0800">2024-04-18 23:45:07</span>
            </span>
        

        

        

        
        
        
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    
                         <p>1.前置准备</p>
<p>2.开发登录，注册页面</p>
<p>3.学习AI生成BI图表的完整流程（梳理功能点和工作）</p>
<p>4.开发智能分析功能</p>
<p>​	文件上传(前后端)</p>
<p>​	excel处理</p>
<p>5.图表管理功能</p>
<h3 id="1-初始化项目-开发前准备"><a href="#1-初始化项目-开发前准备" class="headerlink" title="1.初始化项目 -开发前准备"></a>1.初始化项目 -开发前准备</h3><h4 id="后端启动项目端口冲突问题解决"><a href="#后端启动项目端口冲突问题解决" class="headerlink" title="后端启动项目端口冲突问题解决"></a>后端启动项目端口冲突问题解决</h4><p>原因：windows Hyper-V 虚拟化平台占用了端口</p>
<p>解决方法：先使用: netsh interface ipv4 show exludedportrange protocol&#x3D;tcp 查看被占用的端口，然后选择一个没有被占用的项目端口启动</p>
<h4 id="前端项目优化（删除多余文件）"><a href="#前端项目优化（删除多余文件）" class="headerlink" title="前端项目优化（删除多余文件）"></a>前端项目优化（删除多余文件）</h4><p>1.说明文件</p>
<p>​		.husky:提交代码时检查是否规范</p>
<p>2.删除mock数据（因为本地有后端）和删除config&#x2F;oneapi</p>
<p>3..删除测试相关目录</p>
<p>​	1.删除locals</p>
<p>​	2.删除src&#x2F;service&#x2F;swagger文件</p>
<p>​	3.删除manifest.json(开发app的时候使用)</p>
<p>​	4.删除tests文件夹</p>
<p>​	5.删除types文件夹</p>
<p>​	6.删除jest.config.ts（前端单元测试文件）</p>
<p>4.prettier、eslint、editorConfig、stylelint都用来保证前端代码规范</p>
<p>​	在file-&gt;setting-&gt;搜索prettier-&gt;指定路径-&gt;勾上on refomate….即可</p>
<p>前端与后端对应的代码：只需要在openapi指定后端的api文件就会自动生成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">openAPI: [</span><br><span class="line">  &#123;</span><br><span class="line">    requestLibPath: &quot;import &#123; request &#125; from &#x27;@umijs/max&#x27;&quot;,</span><br><span class="line">    // 或者使用在线的版本</span><br><span class="line">    schemaPath: &quot;http://localhost:8101/api/v2/api-docs&quot;,</span><br><span class="line">    projectName: &#x27;zbi&#x27;,</span><br><span class="line">    // schemaPath: join(__dirname, &#x27;oneapi.json&#x27;),</span><br><span class="line">    mock: false,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="前端页面优化（修改登录页面内容）"><a href="#前端页面优化（修改登录页面内容）" class="headerlink" title="前端页面优化（修改登录页面内容）"></a>前端页面优化（修改登录页面内容）</h4><p>1.首先找到登录注册的页面（先从route文件开始找起，找到userlogin对应的路由，再找到对应的component）</p>
<p>2.删除其余不必要的功能（手机登录，其他登录方式（根据中文内容去对应代码找并且删掉），自动登录，忘记密码功能删掉）</p>
<p>2.替换网站文字部分:全局替换Ant Design Pro和Ant Design</p>
<p>3.替换logo（访问<a class="link"   target="_blank" rel="noopener" href="https://www.iconfont.cn/%EF%BC%89" >https://www.iconfont.cn/）<i class="fas fa-external-link-alt"></i></a></p>
<p>​	1.随表找一张并把格式改为.svg</p>
<p>​	2.替换为favicon_icon:把png格式转化成favicon_icon</p>
<h4 id="修改登录页面表单内容"><a href="#修改登录页面表单内容" class="headerlink" title="修改登录页面表单内容"></a>修改登录页面表单内容</h4><p>1.将前端页面对应表单位置的name与后端接口文档的字段名称对应</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;ProFormText</span><br><span class="line">  name=&quot;userAccount&quot;-&gt;userAccount要与后端接口文档的用户账户字段对应</span><br><span class="line">  fieldProps=&#123;&#123;</span><br><span class="line">    size: &#x27;large&#x27;,</span><br><span class="line">    prefix: &lt;UserOutlined /&gt;,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  placeholder=&#123;&#x27;请输入用户名&#x27;&#125;</span><br><span class="line">  rules=&#123;[</span><br><span class="line">    &#123;</span><br><span class="line">      required: true,</span><br><span class="line">      message: &#x27;用户名是必填项！&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p>2.点击登录提交（前端与后端对接）</p>
<ol>
<li>找到登录按钮所在的表单代码</li>
<li>修改对应的ts类型</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LoginForm</span><br><span class="line">  contentStyle=&#123;&#123;</span><br><span class="line">    minWidth: 280,</span><br><span class="line">    maxWidth: &#x27;75vw&#x27;,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  logo=&#123;&lt;img  alt=&quot;logo&quot;  src=&quot;/logo.svg&quot;  &gt;&#125;</span><br><span class="line">  title=&quot;智能 BI[毕业设计]&quot;</span><br><span class="line">  subTitle=&#123;&#x27;智能 BI[毕业设计] 的目标是为了方便对数据分析的便利而诞生的&#x27;&#125;</span><br><span class="line">  //表单提交：前端与后端对接</span><br><span class="line">  onFinish=&#123;async (values) =&gt; &#123;</span><br><span class="line">  //把TS类型进行修改（改成后端的接口调用名称）</span><br><span class="line">    await handleSubmit(values as API.UserLoginRequest);</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>3.进入handleSubmit函数，修改接收的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//接收的参数为后端的接口名</span><br><span class="line">const handleSubmit = async (values: API.UserLoginRequest) =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    // 登录</span><br><span class="line">    //1.直接请求后端:修改为请求后端代码的函数（这个函数的内容不用自己写，因为我们在oneapi中写了后端的接口地址，前端会自动生成），参数为前端传的参数内容</span><br><span class="line">    const res = await userLoginUsingPOST(values);</span><br><span class="line">    //根据后端接口文档的返回值修改处理逻辑的参数名和逻辑</span><br><span class="line">    if (res.code === 0) &#123;</span><br><span class="line">      const defaultLoginSuccessMessage = &#x27;登录成功！&#x27;;</span><br><span class="line">      message.success(defaultLoginSuccessMessage);</span><br><span class="line">      //用户登录成功后获取用户登录信息</span><br><span class="line">      await fetchUserInfo();</span><br><span class="line">      const urlParams = new URL(window.location.href).searchParams;</span><br><span class="line">      history.push(urlParams.get(&#x27;redirect&#x27;) || &#x27;/&#x27;);</span><br><span class="line">      return;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    //登录失败</span><br><span class="line">      message.error(res.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    const defaultLoginFailureMessage = &#x27;登录失败，请重试！&#x27;;</span><br><span class="line">    console.log(error);</span><br><span class="line">    message.error(defaultLoginFailureMessage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	修改fetchUserInfo函数的内容（用户信息获取）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const fetchUserInfo = async () =&gt; &#123;</span><br><span class="line">  const userInfo = await getLoginUserUsingGET();</span><br><span class="line">  if (userInfo) &#123;</span><br><span class="line">    flushSync(() =&gt; &#123;</span><br><span class="line">    //登录成功后，获取了用户登录信息，并且设置了initialState(整个项目的全局状态:这个项目还在,这些信息就可以在多个组件中共享)</span><br><span class="line">      setInitialState((s) =&gt; (&#123;</span><br><span class="line">        ...s,</span><br><span class="line">        currentUser: userInfo,</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>4.app.tsx中的getInitialState函数：ant.design.pro 框架保存全局状态的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export async function getInitialState(): Promise&lt;&#123;</span><br><span class="line">  currentUser?: API.LoginUserVO;</span><br><span class="line">&#125;&gt; &#123;</span><br><span class="line">  const fetchUserInfo = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      const res = await getLoginUserUsingGET();</span><br><span class="line">      return res.data;</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      history.push(loginPath);</span><br><span class="line">    &#125;</span><br><span class="line">    return undefined;</span><br><span class="line">  &#125;;</span><br><span class="line">  // 如果不是登录页面，说明用户登录过了直接返回当前用户，如果在登录页面则什么都返回</span><br><span class="line">  const &#123; location &#125; = history;</span><br><span class="line">  if (location.pathname !== loginPath) &#123;</span><br><span class="line">    const currentUser = await fetchUserInfo();</span><br><span class="line">    return &#123;</span><br><span class="line">      currentUser,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.头像显示</p>
<p>​	在commponent&#x2F;RightContent&#x2F;AvatarDropdown.tsx文件下</p>
<p>​	全局搜avatar,把爆红的name变成后端传输过来的参数名userName</p>
<p>​	在app.tsx中设置头像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">avatarProps: &#123;</span><br><span class="line">  src: initialState?.currentUser?.userAvatar,</span><br><span class="line">  title: &lt;AvatarName /&gt;,</span><br><span class="line">  render: (_, avatarChildren) =&gt; &#123;</span><br><span class="line">    return &lt;AvatarDropdown&gt;&#123;avatarChildren&#125;&lt;/AvatarDropdown&gt;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<p>6.前端请求头要带上cookie</p>
<p>​	在app.tsx中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export const request = &#123;</span><br><span class="line">  baseURL: &quot;http://localhost:8101&quot;,</span><br><span class="line">  withCredentials:true,</span><br><span class="line">  ...errorConfig,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>7.修改requestErrorConfig文件，可以自定义全局请求响应拦截器</p>
<p>问：为什么每次登录请求后面都有如下，那如何删去token后面的字符</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-07_11-03-53.png"  alt="Snipaste_2024-02-07_11-03-53"></p>
<p>解决：</p>
<p>1.点进errorConfig,找到文件</p>
<p>2.在请求拦截器中就有这个字符串，注释掉就行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 请求拦截器</span><br><span class="line">requestInterceptors: [</span><br><span class="line">  (config: RequestOptions) =&gt; &#123;</span><br><span class="line">    // 拦截请求配置，进行个性化处理。</span><br><span class="line">    // const url = config?.url?.concat(&#x27;?token = 123&#x27;);</span><br><span class="line">    // return &#123; ...config, url &#125;;</span><br><span class="line">    return config</span><br><span class="line">  &#125;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>名字不好，按shift+f6替换文件名字</p>
<h3 id="2-智能分析业务开发"><a href="#2-智能分析业务开发" class="headerlink" title="2.智能分析业务开发"></a>2.智能分析业务开发</h3><h4 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h4><p>1.用户输入</p>
<p>​	a.分析目标</p>
<p>​	b.上传原始数据(excel)</p>
<p>​	c.更精细化的控制图表</p>
<p>2.后端校验</p>
<p>​	a.检验用户输入是否合法(比如长度)</p>
<p>​	b.成本控制(次数统计和校验、鉴权等)</p>
<p>3.把处理后的数据输入给AI模型(调用AI接口),让AI模型给我们提供信息图表，结论文本</p>
<p>4.图表信息（是一段json配置，是一段代码）、结论文本在前端进行展示</p>
<h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>1.文件上传模块</p>
<p>​	1.1.去contronller层中的FileController中把文件上传函数复制到ChartController</p>
<p>​	1.2.改名genChartByAi,并把地址改成gen</p>
<p>​	该函数的参数</p>
<p>​		1.2.1.@RequestPart(“file”) MultipartFile multipartFile：接收文件的方式</p>
<p>​		1.2.2.UploadFileRequest uploadFileRequest：实际用户传的参数（比如用户的目标）</p>
<p>​		1.2.3.前端请求的参数（见用户中心）</p>
<hr>
<p>​				1.点击这个参数的类型名，找到对象文件所在的位置复制到chart中，取名为：genChartByAiRequest，里面的变量（传输给AI的三个参数）：名称和目标，传输方式用1即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 文件上传请求</span><br><span class="line"> * 让AI帮我们分析目标</span><br><span class="line"> * @author &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="line"> * @from &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class GenChartByAiRequest implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 图表名称</span><br><span class="line">     */</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 目标</span><br><span class="line">     */</span><br><span class="line">    private String goal;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 图表类型</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    private String chartType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​				2.发现少了用户传的图表名称的字段：先改sql-&gt;后端补充对应字段（1.修改Chart对象，Chart图表处理对象（dto&#x2F;chart））-&gt;ChartMapper补充相应字段-&gt;contrller层再补充相应的根据名称去查询的条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queryWrapper.like(StringUtils.isNotBlank(name), &quot;name&quot;, name);</span><br></pre></td></tr></table></figure>

<p>​				3.最后将引用的类型名UploadFileRequest -&gt;genChartByAiRequest</p>
<hr>
<p>​		1.2.4：写后端逻辑</p>
<h4 id="原始数据压缩"><a href="#原始数据压缩" class="headerlink" title="原始数据压缩"></a>原始数据压缩</h4><p>AI接口普遍都有输入字数的限制，尽可能压缩数据，能够允许多传一些数据</p>
<h6 id="如何向AI提词-prompt）"><a href="#如何向AI提词-prompt）" class="headerlink" title="如何向AI提词(prompt）"></a>如何向AI提词(prompt）</h6><p>AI提词技巧1：持续输入，持续优化</p>
<p>AI提词技巧2：数据压缩（内容压缩，比如把很长的内容提取关键词,也可以让AI来做）</p>
<p>可以使用csv 对excel 文件的数据进行提取和压缩</p>
<p>1.读取excel文件，根据excel的内容生成CSV</p>
<p>​	1.写一个工具类ExcelUtils</p>
<p>​	2.用easyExcel：<a class="link"   target="_blank" rel="noopener" href="https://easyexcel.opensource.alibaba.com/%EF%BC%88%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%E5%8F%AF%E4%BB%A5%E7%9C%8B%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F%EF%BC%89" >https://easyexcel.opensource.alibaba.com/（具体使用可以看伙伴匹配系统）<i class="fas fa-external-link-alt"></i></a></p>
<p>​	3.全局搜test_excel,找到代码后拷贝下来到ExcelUtils</p>
<hr>
<p>​			测试：直接在该类下面用main方法测试</p>
<p>​						1.先读取数据</p>
<p>​						2.压缩后，并对空做过滤</p>
<p>​							日期,用户数</p>
<p>​							1号,10<br>​							2号,20<br>​							3号,30</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * excel 转 csv</span><br><span class="line"> * </span><br><span class="line"> * @param multipartFile</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static String excelToCsv(MultipartFile multipartFile) &#123;</span><br><span class="line">    //调用胡图的方法读取本地的文件</span><br><span class="line">    File file = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        file = ResourceUtils.getFile(&quot;classpath:网站数据.xlsx&quot;);</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    //用read方法把已知的文件用Map的方式读取</span><br><span class="line">    List&lt;Map&lt;Integer, String&gt;&gt; list = EasyExcel.read(file)</span><br><span class="line">            .excelType(ExcelTypeEnum.XLSX)</span><br><span class="line">            .sheet()</span><br><span class="line">            .headRowNumber(0)</span><br><span class="line">            .doReadSync();</span><br><span class="line">    if (CollUtil.isEmpty(list))&#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    //转化为csv</span><br><span class="line">    StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">    //读取表头:(LinkedHashMap读取表头是线性的，是连续的）</span><br><span class="line">    LinkedHashMap&lt;Integer, String&gt; headerMap = (LinkedHashMap)list.get(0);</span><br><span class="line">    List&lt;String&gt; headerList = headerMap.values().stream().filter(ObjectUtils::isNotEmpty).collect(Collectors.toList());</span><br><span class="line">    stringBuilder.append(StringUtils.join(headerList,&quot;,&quot;)).append(&quot;\n&quot;);</span><br><span class="line">    //读取每一行数据</span><br><span class="line">    for (int i = 1; i &lt; list.size() ; i++) &#123;</span><br><span class="line">        LinkedHashMap&lt;Integer, String&gt; dataMap = (LinkedHashMap)list.get(i);</span><br><span class="line">        List&lt;String&gt; dataList = dataMap.values().stream().filter(ObjectUtils::isNotEmpty).collect(Collectors.toList());</span><br><span class="line">        stringBuilder.append(StringUtils.join(dataList,&quot;,&quot;)).append(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return stringBuilder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>2.在智能分析接口中调用该工具类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 智能分析</span><br><span class="line"> *</span><br><span class="line"> * @param multipartFile</span><br><span class="line"> * @param genChartByAiRequest</span><br><span class="line"> * @param request</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@PostMapping(&quot;/gen&quot;)</span><br><span class="line">public BaseResponse&lt;String&gt; genChartByAi(@RequestPart(&quot;file&quot;) MultipartFile multipartFile,</span><br><span class="line">                                         GenChartByAiRequest genChartByAiRequest, HttpServletRequest request) &#123;</span><br><span class="line">    String name = genChartByAiRequest.getName();</span><br><span class="line">    String goal = genChartByAiRequest.getGoal();</span><br><span class="line">    String chartType = genChartByAiRequest.getChartType();</span><br><span class="line">    //校验</span><br><span class="line">    ThrowUtils.throwIf(StringUtils.isBlank(goal),ErrorCode.PARAMS_ERROR,&quot;目标为空&quot;);</span><br><span class="line">    ThrowUtils.throwIf(StringUtils.isNotBlank(name) &amp;&amp; name.length() &gt; 100,ErrorCode.PARAMS_ERROR,&quot;名称过长&quot;);</span><br><span class="line"></span><br><span class="line">    String result= ExcelUtils.excelToCsv(multipartFile);</span><br><span class="line">    return ResultUtils.success(result);</span><br></pre></td></tr></table></figure>

<p>3.把multipartFile运用到该工具类上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * excel 转 csv</span><br><span class="line">     *</span><br><span class="line">     * @param multipartFile</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    public static String excelToCsv(MultipartFile multipartFile) &#123;</span><br><span class="line"></span><br><span class="line">        //用read方法把已知的文件用Map的方式读取</span><br><span class="line">        List&lt;Map&lt;Integer, String&gt;&gt; list = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            list = EasyExcel.read(multipartFile.getInputStream())</span><br><span class="line">                    .excelType(ExcelTypeEnum.XLSX)</span><br><span class="line">                    .sheet()</span><br><span class="line">                    .headRowNumber(0)</span><br><span class="line">                    .doReadSync();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;表格处理错误&quot;,e);</span><br><span class="line">        &#125;</span><br><span class="line">        if (CollUtil.isEmpty(list))&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        //转化为csv</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        //读取表头:(LinkedHashMap读取表头是线性的，是连续的）</span><br><span class="line">        LinkedHashMap&lt;Integer, String&gt; headerMap = (LinkedHashMap)list.get(0);</span><br><span class="line">        List&lt;String&gt; headerList = headerMap.values().stream().filter(ObjectUtils::isNotEmpty).collect(Collectors.toList());</span><br><span class="line">        stringBuilder.append(StringUtils.join(headerList,&quot;,&quot;)).append(&quot;\n&quot;);</span><br><span class="line">        //读取每一行数据</span><br><span class="line">        for (int i = 1; i &lt; list.size() ; i++) &#123;</span><br><span class="line">            LinkedHashMap&lt;Integer, String&gt; dataMap = (LinkedHashMap)list.get(i);</span><br><span class="line">            List&lt;String&gt; dataList = dataMap.values().stream().filter(ObjectUtils::isNotEmpty).collect(Collectors.toList());</span><br><span class="line">            stringBuilder.append(StringUtils.join(dataList,&quot;,&quot;)).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return stringBuilder.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>4.测试：swagger接口文档中genChartByAi</p>
<h4 id="调用AI"><a href="#调用AI" class="headerlink" title="调用AI"></a>调用AI</h4><p>输入:</p>
<ul>
<li>系统预设（提前告诉他职责、功能、回复格式要求等等）+分析目标+压缩后的数据</li>
</ul>
<p>最简单的系统预设：你是一个系统分析师，接下来我会给你我的分析目标和原始数据，请告诉我分析结论.</p>
<p>1.拼接系统预设+分析目标+压缩后的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//用户的excel文件输入</span><br><span class="line">StringBuilder userInput = new StringBuilder();</span><br><span class="line">userInput.append(&quot;你是一个系统分析师，接下来我会给你我的分析目标和原始数据，请告诉我分析结论.&quot;).append(&quot;\n&quot;);</span><br><span class="line">userInput.append(&quot;分析目标:&quot;).append(goal).append(&quot;\n&quot;);</span><br><span class="line">//压缩后的数据</span><br><span class="line">String result= ExcelUtils.excelToCsv(multipartFile);</span><br><span class="line">userInput.append(&quot;数据:&quot;).append(result).append(&quot;\n&quot;);</span><br><span class="line">return ResultUtils.success(userInput.toString());</span><br></pre></td></tr></table></figure>

<p>输出的结果</p>
<hr>
<p>{<br>  “code”: 0,<br>  “data”: “你是一个系统分析师，接下来我会给你我的分析目标和原始数据，请告诉我分析结论.\n分析目标:分析网站用户\n数据:日期,用户数\n1号,10\n2号,20\n3号,30\n\n”,<br>  “message”: “ok”<br>}</p>
<p>你是一个系统分析师，接下来我会给你我的分析目标和原始数据，请告诉我分析结论.</p>
<p>分析目标:分析网站用户</p>
<p>数据:日期,用户数</p>
<p>1号,10</p>
<p>2号,20</p>
<p>3号,30</p>
<hr>
<p>AI提词技巧3：在系统（模型）层面做预设效果一般来说会比直接拼接在用户消息里的效果要更好一些</p>
<p><strong>没有预设，回答的效果天差地别</strong></p>
<p>AI提词技巧4：除了系统预设外，可以额外关联一问一答两条消息，相当于给AI一个提示</p>
<h4 id="智能分析业务流程开发"><a href="#智能分析业务流程开发" class="headerlink" title="智能分析业务流程开发"></a>智能分析业务流程开发</h4><h5 id="利用AI生成结论和图表"><a href="#利用AI生成结论和图表" class="headerlink" title="利用AI生成结论和图表"></a>利用AI生成结论和图表</h5><p>AI可以直接生成结论，但不能直接生成图表</p>
<p>AI不能直接生成图表，但可以利用AI生成代码&#x3D;&gt;可以把代码利用前端的组件库(Echarts)在网页进行展示</p>
<h5 id="可视化图表工具："><a href="#可视化图表工具：" class="headerlink" title="可视化图表工具："></a>可视化图表工具：</h5><p><a class="link"   target="_blank" rel="noopener" href="https://echarts.apache.org/zh/index.html" >https://echarts.apache.org/zh/index.html<i class="fas fa-external-link-alt"></i></a></p>
<p>预期生成的图表代码</p>
<p>option &#x3D; {<br>  xAxis: {<br>    type: ‘category’,<br>    data: [‘Mon’, ‘Tue’, ‘Wed’, ‘Thu’, ‘Fri’, ‘Sat’, ‘Sun’]<br>  },<br>  yAxis: {<br>    type: ‘value’<br>  },<br>  series: [<br>    {<br>      data: [150, 230, 224, 218, 135, 147, 260],<br>      type: ‘line’<br>    }<br>  ]<br>};</p>
<h5 id="AI提问技巧："><a href="#AI提问技巧：" class="headerlink" title="AI提问技巧："></a>AI提问技巧：</h5><p>如果想要让AI更好的理解我们的输入，给我预期的，精确格式的输出，我们就要严格控制提问词</p>
<p>0.使用系统预设</p>
<p>1.控制输入格式（便于AI精确的理解需求）</p>
<hr>
<p><strong>优化前</strong></p>
<p>你是一个数据分析师，请帮我分析网站用户的增长趋势，并帮我生成图表的前端代码</p>
<p>原始数据如下：</p>
<p>日期，用户数</p>
<p>1号，10</p>
<p>2号，20</p>
<p>3号，30</p>
<p><strong>优化后</strong>（预设）</p>
<p>你是一个数据分析师和前端开发专家，接下来我会按照以下固定格式给你提供内容:</p>
<p>分析需求:</p>
<p>{数据分析的需求或者目标}</p>
<p>原始数据:</p>
<p>{csv格式的原始数据，用,作为分隔符}</p>
<p>请根据以上内容，帮我生成数据分析结论和可视化图表代码</p>
<p>样例</p>
<p>分析需求：</p>
<p>分析网站用户增长情况</p>
<p>原始数据：</p>
<p>日期,用户数</p>
<p>1号,10</p>
<p>2号,20</p>
<p>3号,30</p>
<hr>
<p>2.控制输出格式（便于AI返回的内容能够更加方便的为我们所用）</p>
<hr>
<p>优化前</p>
<p>你是一个数据分析师和前端开发专家，接下来我会按照以下固定格式给你提供内容:</p>
<p>分析需求:</p>
<p>{数据分析的需求或者目标}</p>
<p>原始数据:</p>
<p>{csv格式的原始数据，用,作为分隔符}</p>
<p>请根据以上内容，帮我生成数据分析结论和可视化图表代码，结论至少生成500字</p>
<p>优化后</p>
<p>你是一个数据分析师和前端开发专家，接下来我会按照以下固定格式给你提供内容:</p>
<p>分析需求:</p>
<p>{数据分析的需求或者目标}</p>
<p>原始数据:</p>
<p>{csv格式的原始数据，用,作为分隔符}</p>
<p>请根据这两部分内容，帮我按照以下格式生成内容（此外不要输出任何多余开头、结尾、注释）</p>
<p>【【【【【【</p>
<p>{前端Echarts V5 的option 配置对象js代码，合理的将数据进行可视化，不要生成任何的内容，比如注释}</p>
<p>【【【【【【</p>
<p>{明确的数据分析结论，越详细越好，不要生成多余的注释}</p>
<hr>
<p>3.指定一个示例问答，one-shot或者few-shot</p>
<h4 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h4><h5 id="1-写一个系统预设"><a href="#1-写一个系统预设" class="headerlink" title="1.写一个系统预设"></a>1.写一个系统预设</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final String prompt = &quot;你是一个数据分析师和前端开发专家，接下来我会按照以下固定格式给你提供内容:\n&quot; +</span><br><span class="line">        &quot;分析需求:\n&quot; +</span><br><span class="line">        &quot;&#123;数据分析的需求或者目标&#125;\n&quot; +</span><br><span class="line">        &quot;原始数据:\n&quot; +</span><br><span class="line">        &quot;&#123;csv格式的原始数据，用,作为分隔符&#125;\n&quot; +</span><br><span class="line">        &quot;请根据这两部分内容，帮我按照以下格式生成内容（此外不要输出任何多余开头、结尾、注释）\n&quot; +</span><br><span class="line">        &quot;【【【【【【\n&quot; +</span><br><span class="line">        &quot;&#123;前端Echarts V5 的option 配置对象js代码，合理的将数据进行可视化，不要生成任何的内容，比如注释&#125;\n&quot; +</span><br><span class="line">        &quot;【【【【【【\n&quot; +</span><br><span class="line">        &quot;&#123;明确的数据分析结论，越详细越好，不要生成多余的注释&#125;&quot;;</span><br></pre></td></tr></table></figure>

<h5 id="2-调用AI（3种调用AI的方式）"><a href="#2-调用AI（3种调用AI的方式）" class="headerlink" title="2.调用AI（3种调用AI的方式）"></a>2.调用AI（3种调用AI的方式）</h5><ol>
<li><p>直接调用OpenAI或者其他AI原始大模型官网的接口</p>
<p>官方文档：<a class="link"   target="_blank" rel="noopener" href="https://platform.openai.com/docs/api-reference" >https://platform.openai.com/docs/api-reference<i class="fas fa-external-link-alt"></i></a></p>
<p>优点：不经封装，最灵活，最原始</p>
<p>缺点：要钱，要魔法</p>
<p>本质上OpenAI就是提供了HTTP的接口，我们可以用任何语言取调用</p>
<p>步骤：</p>
<ol>
<li>在请求头中指定OPENAI_API_KEY(Authorization:Bearer OPEN_API_KEY)</li>
<li>找到你要使用的接口，比如AI，比如AI对话接口（<a class="link"   target="_blank" rel="noopener" href="https://platform.openai.com/docs/api-reference/chat%EF%BC%89" >https://platform.openai.com/docs/api-reference/chat）<i class="fas fa-external-link-alt"></i></a></li>
<li>按照接口文档示例，构造HTTP请求，比如用Hutool工具类，或者用HTTPClient</li>
</ol>
</li>
<li><p>使用云服务商提供的，封装后的AI接口</p>
<p>比如:Azure 云</p>
<p>优点：本地都能用</p>
<p>缺点：依然要钱，收费更贵</p>
</li>
<li><p>利用鱼聪明AI提供的开放SDK（看API开放平台）</p>
<p>优点：目前不要钱，而且有很多现成的模型（prompt系统预设）可以用</p>
<p>缺点：不完全灵活，但是可以定义自己的模型</p>
</li>
</ol>
<p>​	鱼聪明AI调用：<a class="link"   target="_blank" rel="noopener" href="https://github.com/liyupi/yucongming-java-sdk" >https://github.com/liyupi/yucongming-java-sdk<i class="fas fa-external-link-alt"></i></a></p>
<p>另一种更快捷的方式：</p>
<p>1.安装依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.yucongming&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;yucongming-java-sdk&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.在application.yml中写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 鱼聪明AI配置</span><br><span class="line">yuapi:</span><br><span class="line">  client:</span><br><span class="line">    access-key: dt5jsd6yf92lbhxfqna5mzb03alwlmvn</span><br><span class="line">    secret-key: fita5c4d9dm0snzl3x21ryszjldtxnpt</span><br></pre></td></tr></table></figure>

<p>3.构造Aimanager请求类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AiManager &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private YuCongMingClient yuCongMingClient;</span><br><span class="line"></span><br><span class="line">    public void doChat(String message)&#123;</span><br><span class="line">        DevChatRequest devChatRequest = new DevChatRequest();</span><br><span class="line">        //指定模型id</span><br><span class="line">        devChatRequest.setModelId(1742866527877050370L);</span><br><span class="line">        devChatRequest.setMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>测试：</p>
<p>建立一个AiManager类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;你是一个数据分析师和前端开发专家，接下来我会按照以下固定格式给你提供内容:\n&quot; +</span><br><span class="line">//                &quot;分析需求:\n&quot; +</span><br><span class="line">//                &quot;&#123;数据分析的需求或者目标&#125;\n&quot; +</span><br><span class="line">//                &quot;原始数据:\n&quot; +</span><br><span class="line">//                &quot;&#123;csv格式的原始数据，用,作为分隔符&#125;\n&quot; +</span><br><span class="line">//                &quot;请根据这两部分内容，帮我按照以下格式生成内容（此外不要输出任何多余开头、结尾、注释）\n&quot; +</span><br><span class="line">//                &quot;【【【【【【\n&quot; +</span><br><span class="line">//                &quot;&#123;前端Echarts V5 的option 配置对象js代码，合理的将数据进行可视化，不要生成任何的内容，比如注释&#125;\n&quot; +</span><br><span class="line">//                &quot;【【【【【【\n&quot; +</span><br><span class="line">//                &quot;&#123;明确的数据分析结论，越详细越好，不要生成多余的注释&#125;&quot;;</span><br></pre></td></tr></table></figure>

<hr>
<p>智能接口的实现</p>
<p>1.构造用户请求（用户消息、csv数据、图表类型等）</p>
<p>2.调用鱼聪明sdk,得到AI响应结果</p>
<p>3.从AI响应结果中，取出需要的结果</p>
<p>4.保存图表</p>
<h4 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h4><p>做用户交互的界面：左侧是表单，右侧是图表</p>
<p>1.先复制登录表单，添加路由，删除多余代码，更改classname</p>
<h5 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h5><p>1.输入表单</p>
<p>​	1.找ant design 组件库：<a class="link"   target="_blank" rel="noopener" href="https://ant-design.antgroup.com/components/form-cn" >https://ant-design.antgroup.com/components/form-cn<i class="fas fa-external-link-alt"></i></a></p>
<p>​	2.删除多余代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//rule表示必填项</span><br><span class="line">&lt;Form.Item name=&quot;goal&quot; label=&quot;分析目标&quot; rules=&#123;[&#123; required: true, message: &#x27;请输入分析目标&#x27; &#125;]&#125;&gt;</span><br><span class="line">  &lt;TextArea placeholder = &quot;请输入你的分析需求，比如分析网站的增长情况&quot; /&gt;</span><br><span class="line">&lt;/Form.Item&gt;</span><br></pre></td></tr></table></figure>

<p>文件上传时注意取出原始对象</p>
<p>2.生成的图表：</p>
<p>​	使用库：<a class="link"   target="_blank" rel="noopener" href="https://git.hust.cc/echarts-for-react/" >https://git.hust.cc/echarts-for-react/<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//如果正在提交中时把该按钮禁用</span><br><span class="line">&lt;Button type=&quot;primary&quot; htmlType=&quot;submit&quot; loading=&#123;submitting&#125; disabled=&#123;submitting&#125;&gt;</span><br><span class="line">              智能分析</span><br><span class="line">            &lt;/Button&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//生成的图表代码是字符串，要把他生成用json格式的对象</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  生成图表:</span><br><span class="line">  &#123;</span><br><span class="line">    chart?.genChart &amp;&amp; &lt;ReactECharts option=&#123;JSON.parse(chart?.genChart)&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>3.生成的结论</p>
<p>计划</p>
<p>1.开发图表管理功能（不用重新生成，历史记录）</p>
<p>2.优化系统（4种优化）</p>
<h3 id="3-开发图表管理功能（增删改查）"><a href="#3-开发图表管理功能（增删改查）" class="headerlink" title="3.开发图表管理功能（增删改查）"></a>3.开发图表管理功能（增删改查）</h3><p>核心：获取个人创建的图表列表</p>
<p>后端：复用spingboot-init 初始化模板的增删改查代码（listChartByPage）</p>
<p>前端：</p>
<p>​	1.开发一个列表页</p>
<p>​	2.支持按照图表名称搜索</p>
<p>步骤</p>
<hr>
<p>​	1.创建路由和页面</p>
<p>​		a. 复制AddChart文件</p>
<p>​		b. 删除多余代码</p>
<p>​		c. shift+f6重构文件名为MyChart</p>
<p>tips:能用现成的组件就不要写样式，因为现成的组件都做好适配，如果自己写的话可能会出现多端不协调的情况</p>
<hr>
<p>​	2.获取需要的数据 ，定义state变量来存储数据，用于给页面展示</p>
<p>​		 oneapi自动生成与后端接口对应的方法listMyChartByPageUsingPOST，因此直接调用即可</p>
<p>​		注：要使用await （把异步变成同步，等后端返回结果之后才会执行后续代码）就必须使用async</p>
<hr>
<p>3.设置发送给后端的查询条件：</p>
<p>​		3.1.找参数：点进listMyChartByPageUsingPOST，找到API.ChartQueryRequest，这个就是传给后端的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const loadData = async () =&gt;&#123;</span><br><span class="line">  const res= await listMyChartByPageUsingPOST();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		3.2.设置查询条件，把初始条件提出便于后面更改初始条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> const initSearchParams = &#123;</span><br><span class="line">    pageSize: 12,</span><br><span class="line">  &#125;</span><br><span class="line">//&#123;...initSearchParams&#125;这样做的目的是防止对象污染，防止initSearchParams改变</span><br><span class="line">  const [searchParams, setSearchParams] = useState&lt;API.ChartQueryRequest&gt;(&#123;...initSearchParams&#125;);</span><br></pre></td></tr></table></figure>

<p>​	ctrl+ alt + t找模板代码（try-catch）</p>
<hr>
<p>  4.显示的逻辑（如果失败则显示失败原因，成功则把数据显示出来）</p>
<p>​			4.1.设置变量存后端传过来的数据（点进listMyChartByPageUsingPOST前端生成的方法-&gt;BaseResponsePageChart-&gt;PageChart_-&gt;Chart）</p>
<p>tips:逻辑都在后端，前端只需要去调用即可</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [chartList, setChartList] = useState&lt;<span class="variable constant_">API</span>.<span class="property">Chart</span>[]&gt;();</span><br><span class="line"><span class="keyword">const</span> [total, setTotal] = useState&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>​			4.2编写获取后端数据的逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const loadData = async () =&gt;&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const res = await listMyChartByPageUsingPOST(searchParams);</span><br><span class="line">    if (res.data)&#123;</span><br><span class="line">      setChartList(res.data.records ?? []);</span><br><span class="line">      setTotal(res.data.total ?? 0);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      message.error(&#x27;获取图表失败.&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (e: any) &#123;</span><br><span class="line">    message.error(&#x27;获取图表失败.&#x27;+ e.message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​			4.3.数据展示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//在页面首次渲染时以及[]数组里面的值发生变化时会执行loadData方法</span><br><span class="line">useEffect(() =&gt;&#123;</span><br><span class="line">  loadData();</span><br><span class="line">&#125;,[searchParams]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line">  &lt;div className=&quot;my-chart-page&quot;&gt;</span><br><span class="line">    数据列表:</span><br><span class="line">    &#123;JSON.stringify(chartList)&#125;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    总数: &#123;total&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>tips：先把最简单直观的数据展示给前端，再去调样式</p>
<p>​	展示效果：</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-10_16-39-17.png"  alt="Snipaste_2024-02-10_16-39-17"></p>
<p>5.设置列表样式：</p>
<p>​	1.引入Ant Design的List组件：<a class="link"   target="_blank" rel="noopener" href="https://ant-design.antgroup.com/components/list-cn#list-demo-basic" >https://ant-design.antgroup.com/components/list-cn#list-demo-basic<i class="fas fa-external-link-alt"></i></a></p>
<p>​	2.删除多余代码</p>
<p>​	3.修改代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;my-chart-page&quot;&gt;</span><br><span class="line">  &lt;List</span><br><span class="line">    itemLayout=&quot;vertical&quot;</span><br><span class="line">    size=&quot;large&quot;</span><br><span class="line">    pagination=&#123;&#123;</span><br><span class="line">      onChange: (page) =&gt; &#123;</span><br><span class="line">        console.log(page);</span><br><span class="line">      &#125;,</span><br><span class="line">      pageSize: 3,</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    dataSource=&#123;chartList&#125;</span><br><span class="line">    footer=&#123;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;b&gt;ant design&lt;/b&gt; footer part</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    renderItem=&#123;(item) =&gt; (</span><br><span class="line">      &lt;List.Item</span><br><span class="line">        key=&#123;item.id&#125;</span><br><span class="line">        extra=&#123;</span><br><span class="line">          &lt;ReactECharts option=&#123;JSON.parse(item.genChart ?? &#x27;&#123;&#125;&#x27;)&#125;/&gt;</span><br><span class="line">        &#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;List.Item.Meta</span><br><span class="line">          avatar=&#123;&lt;Avatar src=&quot;https://api.dicebear.com/7.x/miniavs/svg?seed=0&quot; /&gt;&#125;</span><br><span class="line">          title=&#123;item.name&#125;</span><br><span class="line">          description=&#123;item.chartType ? (&quot;图表类型: &quot;+ item.chartType): undefined&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123;&quot;分析图表目标: &quot;+item.goal&#125;</span><br><span class="line">      &lt;/List.Item&gt;</span><br><span class="line">    )&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">  总数: &#123;total&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<p>问题：图表没渲染</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-10_17-21-20.png"  alt="Snipaste_2024-02-10_17-21-20"></p>
<p>原因：可能是没宽度</p>
<p>解决办法：从extra中移到其他位置即可</p>
<p>6.调整List组件中的内容为自己的(注意:获取用户头像可以从初始状态中获取)</p>
<p>如何在组件中引入initalStates</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123;initalState,setInitalState&#125; = useModel(&#x27;@@initialState&#x27;);</span><br><span class="line">const &#123;currentUser&#125; = initialState ?? &#123;&#125;;</span><br></pre></td></tr></table></figure>



<p>7.针对样式，对数据做一些处理，比如统一隐藏图表自身的title</p>
<p>​	1.在后端放入数据库前过滤掉</p>
<p>​	2.前端过滤后端传过来的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//隐藏图表的title</span><br><span class="line">if (res.data.records)&#123;</span><br><span class="line">  res.data.records.forEach(data =&gt;&#123;</span><br><span class="line">    const chartOption = JSON.parse(data.genChart ?? &#x27;&#123;&#125;&#x27;);</span><br><span class="line">    chartOption.title = undefined;</span><br><span class="line">    data.genChart = JSON.stringify(chartOption);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>8.增加分页</p>
<p>​	1.当用户点击分页时，会调用onChange方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  const [searchParams, setSearchParams] = useState&lt;API.ChartQueryRequest&gt;(&#123; ...initSearchParams &#125;);</span><br><span class="line">pagination=&#123;&#123;</span><br><span class="line">  onChange: (page,pageSize) =&gt; &#123;</span><br><span class="line">    setSearchParams(&#123;</span><br><span class="line">      ...searchParams,</span><br><span class="line">      current: page,</span><br><span class="line">      pageSize,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>​	2.而当搜索参数修改时，会重新渲染图表，因此换页会产生新数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  loadData();</span><br><span class="line">&#125;, [searchParams]);</span><br></pre></td></tr></table></figure>

<p>9.增加搜索框</p>
<p>组件库：<a class="link"   target="_blank" rel="noopener" href="https://ant-design.antgroup.com/components/input-cn" >https://ant-design.antgroup.com/components/input-cn<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>如何添加全局样式</strong></p>
<p>原子化CSS</p>
<p>在global.less下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.margin-16 &#123;</span><br><span class="line">  margin-bottom: 16px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目标文件就可以直接使用即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;margin-16&quot;/&gt;</span><br></pre></td></tr></table></figure>



<p><strong>利用F12控制台进行弱网测试</strong></p>
<p>10.其他优化：比如loading效果</p>
<p>扩展点：</p>
<p>1.支持用户查看原始数据</p>
<p>2.支持跳转到图表编辑页，去编辑图表</p>
<h4 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h4><p>现在的网站足够安全么？</p>
<p>​	a.如果用户上传一个超大的文件怎么办</p>
<p>​    b.如果用户用科技疯狂点击提交，怎么办？</p>
<p>​	c.如果AI的生成太慢（比如需要一分钟），又有很多用户要同时生成，给系统造成了压力，怎么办？</p>
<p>​		怎么兼顾用户的体验和系统的可用性？</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>如果用户上传一个超大的文件怎么办？1000G</p>
<p><strong>只要涉及到用户自主上传的操作，一定要校验文件（图像）</strong></p>
<p>校验的维度：</p>
<p>​	a.文件大小</p>
<p>​	b.文件的后缀</p>
<p>​	c.文件的内容(成本要高一些)</p>
<p>​	d.文件的合规性（比如敏感内容，建议使用第三方的审核功能）</p>
<p>扩展点：</p>
<p>1.分片上传</p>
<p>2.接入腾讯云的图片万象数据审核（cos对象存储的审核功能）</p>
<h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><h5 id="现状："><a href="#现状：" class="headerlink" title="现状："></a>现状：</h5><p>我们把每个图表的原始数据全部存放在同一个数据表(chart表)的字段里。</p>
<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>1.如果用户上传的原始数据量很大、图表数日益增多，查询Chart表就会很慢。</p>
<p>2.对于BI平台，用户是由查看原始数据，对原始数据进行简单查询的需求。现在如果把所有数据存放在一个字段（列）中，查询时，只能取出这个列的内容</p>
<h5 id="解决方案：分库分表"><a href="#解决方案：分库分表" class="headerlink" title="解决方案：分库分表"></a>解决方案：分库分表</h5><p>把每个图表对应的原始数据单独的保存为一个新的数据表，而不是都存在一个字段里，查询时按照图表id进行查询</p>
<p>这样的好处：</p>
<p> 1.存储时，能够分开存储，互不影响（安全性：一个恶意用户存了很大数据量的内容，但是分开存储后是通过id查找，这样就不会影响其他用户的搜索效率）</p>
<p> 2.查询时，可以使用各种sql语句灵活取出需要的字段，查询性能更快</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>分开存储</p>
<p>1.存储信息时，不把信息存储为字段，而是新建一个chart_{图表id}的数据表</p>
<p>通过图表id、数据列名、数据类型等字段，生成以下的sql语句，并且执行即可</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> chart_图表id</span><br><span class="line">&#123;</span><br><span class="line">	日期 <span class="type">int</span> <span class="keyword">null</span>;</span><br><span class="line">	用户数 <span class="type">int</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>分开查询</p>
<p>1.之前直接查询图表，取chartData字段，现在改为读取chart_{图表id}的数据表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from chart_&#123;图表id&#125;</span><br></pre></td></tr></table></figure>

<p>分库分表</p>
<p>水平分表：当系统数据量大时，拆表，前一万个图表数据一个表，后一万个图表数据一个表</p>
<p>垂直分库：根据业务分库（用户，订单等）</p>
<p><strong>具体实现：MyBatis的动态SQL(根据代码灵活地动态生成sql)</strong></p>
<p>1.想清楚哪些是需要动态替换的，比如要查询的数据表名（chart_{图表id}）</p>
<p>2.在ChartMapper.xml中输入（返回的是多条数据，所以要用list）</p>
<p>以下方式最灵活，但是要小心SQL注入风险:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryChartData&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        $&#123;querySql&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注：只要在sql语句中有$的就要防范sql注入</p>
<p>例如：select * from chart_12345 where id &#x3D; 1 or 1&#x3D;1;(直接把数据库所有数据都读出)</p>
<p>解决方法:可以在业务代码生成sql语句时，在生成的过程中做校验</p>
<p>3.找到ChartMapper.java调用方法，方法名和上一步select中的id 相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChartMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Chart&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String,Object&gt; <span class="title function_">queryChartData</span><span class="params">(String querySql)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class ChartMapperTest &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private ChartMapper chartMapper;</span><br><span class="line">    @Test</span><br><span class="line">    void queryChartData() &#123;</span><br><span class="line">        String chartId =&quot;1111&quot;;</span><br><span class="line">        String querySql = String.format(&quot;select * from chart_%s&quot;,chartId) ;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; resultData = chartMapper.queryChartData(querySql);</span><br><span class="line">        System.out.println(resultData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p>现在的问题：使用系统是需要消耗成本的，用户有可能疯狂刷流量，让你破产。</p>
<p>解决问题：</p>
<p>1.控制成本&#x3D;》限制用户调用总次数</p>
<p>2.用户在短时间内疯狂使用，导致服务器资源被占满，其他用户无法使用&#x3D;&gt;限流</p>
<p>思考限流阈值多大合适？参考正常用户的使用，比如限制单个用户在每秒只能使用1次</p>
<h5 id="限流的几种算法"><a href="#限流的几种算法" class="headerlink" title="限流的几种算法"></a>限流的几种算法</h5><p>文章参考：<a class="link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6967742960540581918" >https://juejin.cn/post/6967742960540581918<i class="fas fa-external-link-alt"></i></a></p>
<p>1）固定窗口限流</p>
<p>单位时间内允许部分操作</p>
<p>例：1小时允许10个用户操作</p>
<p>优点：最简单</p>
<p>缺点：可能出现流量突刺</p>
<p>比如：前59分钟没有一个操作，第59分钟来了10个操作；1小时01分钟又来了10个操作</p>
<p>相当于2分钟内执行了20个操作，服务器仍然有高峰危险</p>
<p>2）滑动窗口限流（类似于计算机网络的流量控制（TCP&#x2F;IP层））</p>
<p>单位时间内运行部分操作，但是这个单位时间是滑动的，需要指定一个滑动单位</p>
<p>例：假设滑动单位为1min</p>
<p>开始：0s		1h		2h</p>
<p>1min后：1min		1h1min(窗口发生滑动)</p>
<p>优点:能够解决上述流量突刺问题，因为第59分钟-1小时59分时间段内只能接受10次请求，只要还在这个窗口内，更多的操作就会被拒绝。</p>
<p>缺点：实现相对复杂，限流效果和你的滑动单位有关，滑动单位越小，限流效果越好，但往往很难选取到一个特别合适的滑动单位。</p>
<p><strong>3）漏桶限流（推荐）</strong></p>
<p>以<strong>固定的速率</strong>处理请求（漏水），当请求桶满了后，拒绝请求。</p>
<p>例如：每秒处理10个请求，桶的容量是10，以0.1秒的固定处理一次请求，如果1秒来了10个请求就都可以处理完，但如果1秒内来了11个请求，最后那个请求就会溢出桶，被拒绝。</p>
<p>优点：能够一定程度上应对流量突刺，<strong>能够固定速率处理请求，保证服务器的安全</strong></p>
<p>缺点：没有办法迅速处理一批请求，只能一个一个按顺序来处理(固定速率的缺点)</p>
<p><strong>4）令牌桶限流（推荐）</strong></p>
<p>例如：管理员先生成一批令牌，每秒生成10 个令牌；当用户操作前，先拿到一个令牌，有令牌的人就有资格进行操作，能同时执行操作；拿不到令牌就等着</p>
<p>优点：能够并发处理同时的请求，<strong>并发性能会更高</strong></p>
<p>需要考虑的问题：还是存在时间单位的选取问题</p>
<h5 id="限流的粒度"><a href="#限流的粒度" class="headerlink" title="限流的粒度"></a>限流的粒度</h5><p>1.针对某个方法限流，即单位时间内最多允许同时XX个操作使用这个方法</p>
<p>2.针对某个用户限流，比如单个用户单位时间内最多执行XX次操作</p>
<p>3.针对某个用户X方法限流，比如单个用户单位时间内最多可执行XX次这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限流判断,每个用户一个限流器,</span></span><br><span class="line"><span class="comment">// 参数这样写的好处是每个方法的限流器不会冲突，一个方法的调用了的次数，不会影响其他方法的使用</span></span><br><span class="line"> redisLimiterManager.doRateLimit(<span class="string">&quot;genChartByAi_&quot;</span>+loginUser.getId());</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="限流的实现"><a href="#限流的实现" class="headerlink" title="限流的实现"></a>限流的实现</h5><p>1）本地限流（单机限流）</p>
<p>每个服务器单独限流，一般适用于单体项目<strong>，就是项目只有一个服务器</strong></p>
<p>实现：</p>
<p>要使用第三方库实现单机限流，可以使用Guava库中的RateLimiter类。RateLimiter是一个简单且强大的限流工具，可以控制某个操作在一定时间内的调用频率。</p>
<p>首先，你需要在你的项目中引入Guava库的依赖。在Maven项目中，可以在pom.xml文件中添加以下依赖：</p>
<p>xml</p>
<p>复制</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>30.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，你可以使用RateLimiter类来实现单机限流。下面是一个简单的示例代码：</p>
<p>java</p>
<p>复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个每秒允许2个请求的限流器</span></span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟10个请求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 尝试获取一个许可，如果获取不到则等待</span></span><br><span class="line">            limiter.acquire();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;执行第 &quot;</span> + i + <span class="string">&quot; 个请求&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个每秒允许2个请求的限流器。在循环中，我们使用<code>acquire()</code>方法来获取一个许可，如果获取不到许可，则会阻塞等待。然后我们执行业务逻辑，这里只是简单地打印了一条消息。</p>
<p>通过使用RateLimiter类，你可以方便地实现单机限流，控制某个操作的调用频率，保护系统免受过多的请求压力。</p>
<p>2）分布式限流（多机限流）</p>
<p>如果你的项目又多个服务器，比如微服务，那么建议使用分布式限流。</p>
<p>方式</p>
<p>​	1.把统计用户的使用频率等数据放到一个集中的存储进行统计，比如Redis，这样无论用户的请求落到哪个服务器，都以集中的数据存储内的数据为准(Redission-是一个操作Redis的工具库，伙伴匹配系统讲过)</p>
<p>​	2.在网关集中进行限流和统计（比如Sentinel, Spring Cloud Gateway）</p>
<p>实现：</p>
<p>要实现分布式限流，可以使用Redis作为分布式缓存，并结合第三方库实现限流功能。一个常用的库是Redisson，它提供了分布式限流的功能。</p>
<p>首先，你需要在你的项目中引入Redisson的依赖。在Maven项目中，可以在pom.xml文件中添加以下依赖：</p>
<p>xml</p>
<p>复制</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.16.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，你可以使用Redisson的RLock对象来实现分布式限流。下面是一个简单的示例代码：</p>
<p>java</p>
<p>复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedRateLimiterExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Redisson客户端连接</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://localhost:6379&quot;</span>);</span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取分布式锁对象</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;myLock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试获取锁，最多等待3秒</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">acquired</span> <span class="operator">=</span> lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">                <span class="comment">// 执行业务逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;执行请求&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 限流处理</span></span><br><span class="line">                System.out.println(<span class="string">&quot;请求被限流&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭Redisson客户端连接</span></span><br><span class="line">        redisson.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用Redisson创建了一个RedissonClient对象，并通过该对象获取了一个分布式锁对象RLock。在业务逻辑中，我们尝试获取锁，如果获取成功，则执行请求的业务逻辑；如果获取失败，则进行限流处理。</p>
<p>通过使用Redisson库，你可以方便地实现分布式限流，保护系统免受过多的请求压力。同时，Redis的高性能和可靠性也能够满足分布式限流的需求。</p>
<h5 id="Redission-限流实现"><a href="#Redission-限流实现" class="headerlink" title="Redission 限流实现"></a>Redission 限流实现</h5><p>Redission 内置了一个限流工具类，可以帮助你利用Redis来存储，来统计。</p>
<p>地址：<a class="link"   target="_blank" rel="noopener" href="https://github.com/redisson/redisson#quick-start" >https://github.com/redisson/redisson#quick-start<i class="fas fa-external-link-alt"></i></a></p>
<p>1.安装依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.26.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;  </span><br></pre></td></tr></table></figure>

<p>2.在config中创建类（注意要先按照Redis，具体安装过程看伙伴匹配系统）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class RedissonConfig &#123;</span><br><span class="line"></span><br><span class="line">    //把application.yml中的redis的值变成动态</span><br><span class="line">    private Integer database;</span><br><span class="line"></span><br><span class="line">    private String host;</span><br><span class="line"></span><br><span class="line">    private Integer port;</span><br><span class="line"></span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedissonClient redissonClient()&#123;</span><br><span class="line">        Config config = new Config();</span><br><span class="line">        config.useSingleServer()</span><br><span class="line">                .setDatabase(database)</span><br><span class="line">                .setAddress(&quot;redis://&quot;+host+&quot;:&quot;+port)</span><br><span class="line">                .setPassword(password);</span><br><span class="line">        RedissonClient redisson = Redisson.create(config);</span><br><span class="line">        return redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>tips：</p>
<p>1.注意.setDatabase(1)设置编号时要与业务数据库分开（存用户信息是1，其他业务数据库用的是2）</p>
<p>2..setPassword(password)：如果Redis没设置密码就不要加这行会报错</p>
<p>3.写一个单独的管理类 RedisLimiterManager</p>
<p>什么是manager？专门提供RedisLimiter限流基础服务的（<strong>提供了通用的能力</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 专门启动RedisLimiter限流基础服务的（提供了通用的能力）</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class RedisLimiterManager &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 限流操作</span><br><span class="line">     *</span><br><span class="line">     * @param key 区分不同的限流器，比如不同的用户id应该分别统计</span><br><span class="line">     */</span><br><span class="line">    public void doRateLimit(String key)&#123;</span><br><span class="line">        // 获取RateLimiter对象，每秒限制5个请求</span><br><span class="line">        RRateLimiter rateLimiter = redissonClient.getRateLimiter(key);</span><br><span class="line">        rateLimiter.trySetRate(RateType.OVERALL, 5, 1, RateIntervalUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        //每当一个请求来了之后，请求一个令牌</span><br><span class="line">        boolean canOp =rateLimiter.tryAcquire(1);</span><br><span class="line">        if (!canOp)&#123;</span><br><span class="line">            throw new BusinessException(ErrorCode.TOO_MANY_REQUEST);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>系统优化-异步化</p>
<p>0.系统问题分析</p>
<p>1.异步化的思路</p>
<p>2.线程池的理论和实战</p>
<p>3.前端后端异步化改造</p>
<h3 id="4-系统问题分析"><a href="#4-系统问题分析" class="headerlink" title="4.系统问题分析"></a>4.系统问题分析</h3><p>问题的场景：调用的服务处理能力有限，或者接口的（处理和返回时间）较长时，就应该考虑异步化</p>
<p>1.用户等待时间有点长（要等AI生成）</p>
<p>2.业务服务器可能会有很多请求在处理，导致系统资源紧张，严重时导致服务器宕机或者无法处理新的请求</p>
<p>3.调用的第三方服务（AI能力）的处理能力是有限的，比如每3秒只能处理1个请求，会导致AI处理不过来，严重时AI可能会对拒绝服务后台系统</p>
<h3 id="异步化"><a href="#异步化" class="headerlink" title="异步化"></a>异步化</h3><p>同步：一件事情做完，再做另外一件事（烧水后处理工作）</p>
<p>异步：不用等一件事情做完，可以做另外一件事，等第一件事情完成时，可以收到一个通知，通知你这件事情做好了，可以再进行后续处理（烧水时，水壶有一个蜂鸣器：烧水时人可以同时工作。水烧好后人能听到声音，就知道水烧好了）</p>
<h4 id="业务流程分析"><a href="#业务流程分析" class="headerlink" title="业务流程分析"></a>业务流程分析</h4><p>1.当用户要进行耗时很长的操作时，点击提交后不需要在界面傻等，而是应该把这个任务保存在数据库中记录起来</p>
<p>2.用户执行新任务时</p>
<p>​	a.任务提交成功：</p>
<p>​		i.如果我们程序还有多余的空闲线程，可以立即去做这个任务</p>
<p>​		ii.如果线程都在繁忙，无法继续处理，那就放到等待队列中</p>
<p>​	b.任务提交失败：比如我们的程序所有线程都在忙，任务队列满了</p>
<p>​		i.拒绝掉这个任务，再也不执行</p>
<p>​		ii.通过保存到数据库中的记录来看到提交失败的任务，并且在程序空闲的时候，可以把任务从数据库中捞到程序中，再去执行</p>
<p>3.我们的程序（线程）从任务队列取出任务依次执行，每完成一件事情就要修改一下任务的状态</p>
<p>4.用户可以查询任务的执行状态，或者在任务执行成功或失败时得到通知（发邮件，系统消息提示，发邮件），从而优化体验</p>
<p>5.如果我们要执行的任务非常复杂，包含非常多的环节，在每一个小任务完成时，要在程序（数据库中）记录一下任务的执行状态（进度）</p>
<h5 id="智能BI实现标准异步化"><a href="#智能BI实现标准异步化" class="headerlink" title="智能BI实现标准异步化"></a>智能BI实现标准异步化</h5><p>系统业务流程</p>
<p>1.用户点击智能分析页提交按钮时，先把图表立刻保存到数据库中（作为一个任务）</p>
<p>2.用户可以在图表管理页查看所有图表（已生成的，生成中的，生成失败）的信息和状态</p>
<p>3.用户可以修改生成失败的图表信息，点击重新生成</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-11_17-45-21.png"  alt="Snipaste_2024-02-11_17-45-21"></p>
<p>问题：</p>
<p>1.任务队列的最大容量应设置为多少？</p>
<p>2.程序怎么从任务队列中取出任务去执行？这个任务队列的流程怎么实现?怎么保证程序最多同时执行多少个任务?</p>
<h5 id="线程池的理论和实战"><a href="#线程池的理论和实战" class="headerlink" title="线程池的理论和实战"></a>线程池的理论和实战</h5><p>解决方法：线程池</p>
<p>为什么需要线程池</p>
<p>1.线程的管理比较复杂（什么时候新增线程，什么时候减少空闲线程）</p>
<p>2.任务存取比较复杂（什么时候接受任务，什么时候拒绝任务，怎么保证大家不抢到同一个任务）</p>
<p>线程池的作用：帮助你轻松管理线程，协调任务的执行过程</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-11_17-56-22.png"  alt="Snipaste_2024-02-11_17-56-22"></p>
<h6 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h6><p>不用自己写，如果在Spring中，可以用ThreadPoolTaskExecutor配合@Async注解来实现。（不太建议）</p>
<p>如果是在java中，可以使用JUC并发编程包中的ThreadPoolExecutor来实现非常灵活的自定义线程池</p>
<h6 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<p>怎么确定线程池参数呢？结合实际情况（实际业务场景和系统资源）来测试调整，不断优化。</p>
<p>回归到我们的业务，要考虑系统最脆弱的环节（系统的瓶颈）在哪里？</p>
<p>为什么需要线程池：AI处理很慢</p>
<p>现有条件：比如AI生成能力的并发只允许4个任务同时去执行，AI能力允许20个任务排队</p>
<p>参数含义：</p>
<p>1.corePoolSize：（核心线程数&#x3D;&gt;正式员工）：<strong>正常情况</strong>下，我们的系统应该能同时工作的线程数（随时就绪的状态）</p>
<p>2.maximumPoolSize（最大线程数&#x3D;&gt;哪怕任务再多，你最多也要招这些人）：极限情况下，我们的线程池最多有多少个线程？</p>
<p>3.keepAliveTime（空闲线程存活时间）：非核心线程在没有任务的情况下，过多久要删除（理解为开除临时工），从而释放无用的线程资源</p>
<p>4.TimeUnit unit（空闲线程存活时间的单位）：分钟，秒</p>
<p>5.workQueue（阻塞队列）：用于存放给线程执行的任务，存在一个队列的长度（一定要设置，不要说队列长度无限，因为也会占用资源）</p>
<p>6.ThreadFactory（线程工厂）：控制线程的生成，线程的属性（比如线程名）</p>
<p>7.RejectedExecutionHandler（拒绝策略）：任务队列满的时候，采取什么策略，比如抛异常，不抛异常，自定义策略</p>
<p>tips：资源隔离队列：比如VIP任务一个队列，普通任务一个队列，保证这两个任务互不干扰</p>
<p><strong>线程池的工作机制</strong></p>
<p>刚开始：发现线程池的数量还没达到核心线程数，那么就直接执行到达的任务</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-11_19-37-50.png"  alt="Snipaste_2024-02-11_19-37-50"></p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-11_19-37-55.png"  alt="Snipaste_2024-02-11_19-37-55"></p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-11_19-37-59.png"  alt="Snipaste_2024-02-11_19-37-59"></p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-11_19-38-04.png"  alt="Snipaste_2024-02-11_19-38-04"></p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-11_19-38-10.png"  alt="Snipaste_2024-02-11_19-38-10"></p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-11_19-38-16.png"  alt="Snipaste_2024-02-11_19-38-16"></p>
<p><strong>线程池的参数如何设置？</strong></p>
<p>现有条件：比如AI生成能力的并发只允许4个任务同时去执行，AI能力允许20个任务排队</p>
<p>1.corePoolSize：（核心线程数&#x3D;&gt;正式员工）：<strong>正常情况</strong>下，可以设置为2-4</p>
<p>2.maximumPoolSize：设置为 &lt;&#x3D;4</p>
<p>3.keepAliveTime（空闲线程存活时间）：一般设置为秒级或者分钟级</p>
<p>4.TimeUnit unit（空闲线程存活时间的单位）：分钟，秒</p>
<p>5.workQueue（阻塞队列）：结合实际情况去设置，可以设置为20</p>
<p>6.ThreadFactory（线程工厂）：控制线程的生成，线程的属性（比如线程名）</p>
<p>7.RejectedExecutionHandler（拒绝策略）：抛异常，标记数据库的任务状态为“任务满了，已拒绝”</p>
<p>一般情况下：任务分为IO密集型和计算密集型两种</p>
<p>1.计算密集型：<strong>吃CPU</strong>，比如音视频处理，图像处理，数学计算等，一般是设置corePoolSize&#x3D;CPU核数+1</p>
<p>为什么还要加1？主线程或者让线程之间有一个协调的空余，可以让每个线程都能利用号CPU的每个核，而且线程之间不用频繁切换（减少打架，减少开销）</p>
<p>2.IO密集型：<strong>吃带宽&#x2F;硬盘&#x2F;内存的读写资源</strong>，corePoolSize可以设置大一点，一般经验值是2n左右，但是建议以IO的能力为主</p>
<h6 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h6><p>1.自定义线程池</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ThreadPoolExecutorConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ThreadPoolExecutor threadPoolExecutor()&#123;</span><br><span class="line">        ThreadFactory threadFactory = new ThreadFactory() &#123;</span><br><span class="line">            private int count = 1;</span><br><span class="line">            @Override</span><br><span class="line">            public Thread newThread(@NotNull Runnable r) &#123;</span><br><span class="line">                Thread thread = new Thread(r);</span><br><span class="line">                thread.setName(&quot;线程&quot;+count);</span><br><span class="line">                count++;</span><br><span class="line">                return thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2,4,100, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;&gt;(4),threadFactory);</span><br><span class="line">        return threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.指定线程池并且提交任务到线程池</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 队列测试</span><br><span class="line"> *</span><br><span class="line"> * @author &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="line"> * @from &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/queue&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class QueueController &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/add&quot;)</span><br><span class="line">    public void add(String name)&#123;</span><br><span class="line">        CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(&quot;任务执行中&quot;+ name+&quot;, 执行人&quot;+ Thread.currentThread().getName());</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(60000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,threadPoolExecutor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>3.在<a class="link"   target="_blank" rel="noopener" href="http://localhost:8101/api/doc.html#/default/queue-controller/addUsingGET%E6%B5%8B%E8%AF%95" >http://localhost:8101/api/doc.html#/default/queue-controller/addUsingGET测试<i class="fas fa-external-link-alt"></i></a></p>
<p>tips：测试的接口最好加上这个注解@Profile({“dev”,”local”})</p>
<h4 id="前端后端异步化改造"><a href="#前端后端异步化改造" class="headerlink" title="前端后端异步化改造"></a>前端后端异步化改造</h4><h5 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h5><p>系统业务流程</p>
<ol>
<li><p>给chart表增加任务状态字段(比如已完成，执行中，排队中，失败)，任务执行信息字段（用于记录任务执行中，或者失败的一些信息）</p>
</li>
<li><p>用户点击智能分析页提交按钮时，先把图表立刻保存到数据库中，然后提交任务</p>
</li>
<li><p>任务：先修改图表的任务状态为”执行中”。等执行成功后，修改为”已完成“。保存执行结果；执行失败后，修改状态为”失败”，记录任务失败的信息</p>
</li>
<li><p>用户可以在图表管理页查看所有图表（已生成的，生成中的，生成失败）的信息和状态</p>
</li>
<li><p>用户可以修改生成失败的图表信息，点击重新生成（todo）</p>
</li>
</ol>
<p><strong>优化点</strong></p>
<p>1.guava Retrying 重试</p>
<p>2.如果说任务根本没提交到队列中（或者队列满了），是不是可以用定时任务把失败状态的图表放到队列中（补偿）</p>
<p>3.建议给任务的执行增加一个超时时间，超时后自动标记为失败（超时控制）</p>
<p>4.当系统负载低，性能良好时用同步，性能差的时候用异步</p>
<p>5.提前考虑到AI生成错误的情况，在后端生成异常处理（比如A说了多余的话，I提取正确的字符串）</p>
<p>6.反向压力：动态调整线程池的线程数（找AI第三方确认（空闲则调高核心线程数，忙则调低核心线程数））</p>
<p>通过调用的服务状态来选择当前的系统的策略（比如根据AI服务的当前任务队列数来控制系统的核心线程数），<strong>从而最大化利用系统资源</strong></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/404993753" >https://zhuanlan.zhihu.com/p/404993753<i class="fas fa-external-link-alt"></i></a></p>
<p>7.我的图表页面增加一个刷新，定时自动刷新的按钮，保证获取到图表的最新状态（前端轮询）</p>
<p>8.任务执行成功或失败，给用户发送实时消息通知（实时:websocket，server side event）</p>
<p>步骤</p>
<p>1.改造图表(新增字段)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 图表信息表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> chart</span><br><span class="line">(</span><br><span class="line">    status     <span class="type">varchar</span>(<span class="number">128</span>)                       <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;wait&#x27;</span> comment <span class="string">&#x27;wait,succeed,failed,running&#x27;</span>,</span><br><span class="line">    execMessage text                              <span class="keyword">null</span> comment <span class="string">&#x27;执行信息&#x27;</span>,</span><br><span class="line">) comment <span class="string">&#x27;图表信息表&#x27;</span> <span class="keyword">collate</span> <span class="operator">=</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>

<p>2.修改图表中的status字段的数据改为succeed</p>
<p>3.补充Chart字段</p>
<p>4.任务执行逻辑，并用线程池来执行任务</p>
<p>​	先修改任务状态为执行中，减少重复执行的风险，同时让用户知道执行状态</p>
<p>注意异常处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            //调用AI前更新一次数据库</span><br><span class="line">            //任务：先修改图表的任务状态为&quot;执行中&quot;。等执行成功后，修改为”已完成“。保存执行结果；执行失败后，修改状态为&quot;失败&quot;，记录任务失败的信息</span><br><span class="line">            Chart updateChart = new Chart();</span><br><span class="line">            updateChart.setId(chart.getId());</span><br><span class="line">            updateChart.setStatus(&quot;running&quot;);</span><br><span class="line">            boolean b = chartService.updateById(updateChart);</span><br><span class="line">            if (!b) &#123;</span><br><span class="line">                //todo 把状态放到数据库</span><br><span class="line">                handleChartUpdateError(chart.getId(),&quot;更新图表执行中状态失败&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //调用AI</span><br><span class="line">            String result = aiManager.doChat(biModeId, userInput.toString());</span><br><span class="line">            String[] splits = result.split(&quot;【【【【【&quot;);</span><br><span class="line">            if (splits.length &lt; 3) &#123;</span><br><span class="line">                handleChartUpdateError(chart.getId(),&quot;AI生成错误&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            String genChart = splits[1].trim();</span><br><span class="line">            String genResult = splits[2].trim();</span><br><span class="line">            //调用AI后再更新一次数据库</span><br><span class="line">            Chart updateChartResult = new Chart();</span><br><span class="line">            updateChartResult.setId(chart.getId());</span><br><span class="line">            updateChartResult.setGenChart(genChart);</span><br><span class="line">            updateChartResult.setGenResult(genResult);</span><br><span class="line">            updateChartResult.setStatus(&quot;succeed&quot;);</span><br><span class="line">            boolean updateResult = chartService.updateById(updateChartResult);</span><br><span class="line">            if (!updateResult) &#123;</span><br><span class="line">                //todo 把状态放到数据库</span><br><span class="line">                handleChartUpdateError(chart.getId(),&quot;更新图表成功状态失败&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,threadPoolExecutor);</span><br><span class="line"></span><br><span class="line">        BiResponse biResponse = new BiResponse();</span><br><span class="line">        biResponse.setChartId(chart.getId());</span><br><span class="line">        return ResultUtils.success(biResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void handleChartUpdateError(long chartId, String execMessage) &#123;</span><br><span class="line">    Chart updateChartResult = new Chart();</span><br><span class="line">    updateChartResult.setId(chartId);</span><br><span class="line">    updateChartResult.setExecMessage(&quot;execMessage&quot;);</span><br><span class="line">    boolean updateResult = chartService.updateById(updateChartResult);</span><br><span class="line">    if (!updateResult) &#123;</span><br><span class="line">        log.error(&quot;更新图表失败状态失败&quot; + chartId + &quot;,&quot; + execMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>1.复制一个异步创建图表页面</p>
<p>2.修改异步页面的调用接口为异步的接口</p>
<p>3.移除无用元素和变量</p>
<p>4.修改成功后的操作，比如提示语和重置表单</p>
<p>5.调整我的图表页面，补充错误处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    item.status === &#x27;wait&#x27; &amp;&amp; &lt;&gt;</span><br><span class="line">      &lt;Result</span><br><span class="line">        status=&quot;warning&quot;</span><br><span class="line">        title=&quot;图表待生成&quot;</span><br><span class="line">        subTitle=&#123;item.execMessage ?? &#x27;当前图表生成繁忙，请耐心等候&#x27;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    item.status === &#x27;running&#x27; &amp;&amp; &lt;&gt;</span><br><span class="line">      &lt;Result</span><br><span class="line">        status=&quot;info&quot;</span><br><span class="line">        title=&quot;图表生成中&quot;</span><br><span class="line">        subTitle=&#123;item.execMessage&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#123;</span><br><span class="line">  item.status === &#x27;succeed&#x27; &amp;&amp; &lt;&gt;</span><br><span class="line">    &lt;div style=&#123;&#123;marginBottom: 16&#125;&#125;/&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#x27;分析图表目标: &#x27; + item.goal&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div style=&#123;&#123;marginBottom: 16&#125;&#125;/&gt;</span><br><span class="line">    &lt;ReactECharts option=&#123;JSON.parse(item.genChart ?? &#x27;&#123;&#125;&#x27;)&#125;/&gt;&lt;/&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  item.status === &#x27;failed&#x27; &amp;&amp; &lt;&gt;</span><br><span class="line">    &lt;Result</span><br><span class="line">      status=&quot;error&quot;</span><br><span class="line">      title=&quot;图表生成错误&quot;</span><br><span class="line">      subTitle=&#123;item.execMessage&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/&gt;</span><br></pre></td></tr></table></figure>

<p>6.调整图表的查询顺序，按照创建时间降序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const initSearchParams = &#123;</span><br><span class="line">  current: 1,</span><br><span class="line">  pageSize: 1,</span><br><span class="line">  sortField: &#x27;createTime&#x27;,</span><br><span class="line">  sortOrder: &#x27;desc&#x27;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="5-消息队列"><a href="#5-消息队列" class="headerlink" title="5.消息队列"></a>5.消息队列</h3><p>1.分析系统现在的不足</p>
<p>2.分布式消息队列</p>
<p>3.分布式消息队列RabbitMQ入门实战</p>
<p>4.项目扩展</p>
<hr>
<h4 id="分析系统现在的不足（单机系统的问题）"><a href="#分析系统现在的不足（单机系统的问题）" class="headerlink" title="分析系统现在的不足（单机系统的问题）"></a>分析系统现在的不足（单机系统的问题）</h4><p>现状：目前的异步是通过本地的线程池实现的</p>
<p>1.无法集中限制，只能单机限制</p>
<p>​	假如AI服务限制只能2个用户同时使用，单个线程池也可以设置最大核心线程数为2来实现。</p>
<p>​	假如系统用量增大，改为分布式，多台服务器，每个服务器都要有两个线程，就可能有2N个线程，超过了AI服务的限制</p>
<p>解决方案：在一个集中的地方（例如：redis公共状态管理）去管理下发任务（比如集中存储当前正在执行的任务数）</p>
<p>2.任务由于是放在内存中执行，可能会丢失</p>
<p>虽然可以人工从数据库中捞出来再重试，但是其实需要额外开发（比如定时任务），这种重试的场景其实非常典型的，其实不需要我们开发者过于关心，或者自己实现的</p>
<p>解决方案：把任务放在一个可以持久化存储的硬盘</p>
<p>3.优化，如果你的系统功能越来越多，长耗时任务越来越多，系统会越来越复杂（比如开多个线程池，资源可能会出现相互抢占）</p>
<p>服务拆分（应用解耦）：可以把长耗时，消耗很多的任务把它单独抽成一个程序，不影响主业务</p>
<p>解决方案：可以有一个中间人，让中间人帮我们连接两个系统（比如核心系统和智能生成业务）</p>
<h4 id="分布式消息队列"><a href="#分布式消息队列" class="headerlink" title="分布式消息队列"></a>分布式消息队列</h4><h5 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h5><p>开发多个系统和应用时，可以帮助我们连接多个系统，让多个系统可以紧密配合的技术（或者组件）</p>
<p>比如：Redis、消息队列、分布式存储Etcd</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_19-44-31.png"  alt="Snipaste_2024-02-12_19-44-31"></p>
<h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><p>存储消息的队列</p>
<p>关键词：存储，消息，队列</p>
<p>存储：存数据</p>
<p>消息：某种数据结构，比如字符串，对象二进制数据，json等等</p>
<p>队列：先进先出的数据结构</p>
<p><strong>消息队列是特殊的数据库</strong></p>
<p>应用场景（作用）：<strong>在多个不同的系统中，应用之间实现消息的传输</strong>（也可以存储）。不需要考虑传输应用的编程语言、系统、框架等等</p>
<p>可以让java开发的应用发消息，让php开发的应用接收消息，这样就可以不用吧所有代码写到同一个项目里（应用解耦）</p>
<h5 id="消息队列的模型"><a href="#消息队列的模型" class="headerlink" title="消息队列的模型"></a>消息队列的模型</h5><p>生产者：Producer,类比快递员，发送消息的人（客户端）</p>
<p>消费者：Consumer,类比取快递的人，接收消息的人（客户端）</p>
<p>消息：Message,类比快递，就是生产者给消费者的数据</p>
<p>消息队列:Queue</p>
<p>为什么不接传输，要用消息队列？生产者不关心消费者要不要消费，什么时候消费，只要把东西给消息队列，工作就算完成</p>
<p>生产者和消费者解耦，互不影响</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_20-02-11.png"  alt="Snipaste_2024-02-12_20-02-11"></p>
<h5 id="为什么用消息队列"><a href="#为什么用消息队列" class="headerlink" title="为什么用消息队列"></a>为什么用消息队列</h5><p>1.异步处理</p>
<p>生产者发送完消息后，可以继续去忙别的，消费者想什么时候都可以取，不会产生阻塞</p>
<p>2.削峰填谷</p>
<p>先把用户请求放到消息队列中，消费者（实际执行操作的应用）可以按照自己的需求，慢慢去取</p>
<p>原本：12点时来了10万个请求，在原本情况下，10万个请求都在系统内部立即处理，很快系统压力过大就宕机了</p>
<p>现在：把这10万个请求放到消息队列中，处理系统以自己恒定的速率（比如每秒一个）慢慢执行，从而保护系统，稳定处理</p>
<p>3.发布订阅</p>
<h5 id="分布式消息队列的优势"><a href="#分布式消息队列的优势" class="headerlink" title="分布式消息队列的优势"></a>分布式消息队列的优势</h5><p>1.数据持久化：它可以把消息集中存储到硬盘中，服务器重启就不会丢</p>
<p>2.可扩展性：根据需求，随时增加（或减少）结点，继续保持稳定的服务</p>
<p>3.应用解耦：可以连接各个不同语言、框架开发的系统，让这些系统能够灵活的传输读取数据</p>
<p><strong>应用解耦的优点</strong></p>
<p>以前，把所有功能都放到同一项目中，调用多个子功能，一个环节错，系统就整体出错</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_20-15-34.png"  alt="Snipaste_2024-02-12_20-15-34"></p>
<p>使用消息队列进行解耦：</p>
<p>1.一个系统挂了，不影响另一个系统。</p>
<p>2.假设发货系统挂了，但是当发货系统复活后，依旧可以从发货系统中取消息，系统不会出问题</p>
<p>3.只要发送消息到队列，就可以立刻返回，不用同步调用所有系统，性能更高</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_20-19-04.png"  alt="Snipaste_2024-02-12_20-19-04"></p>
<p>4.订阅发布</p>
<p> 如果一个非常大的系统要给其他子系统发送通知，最简单直接的方式是大系统直接依次调用小系统</p>
<p>问题</p>
<p>1.每次发送通知都要调用很多系统，很麻烦，有可能失败</p>
<p>2.新出现的项目（或者说大项目感知不到的项目）无法得到通知</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_20-37-59.png"  alt="Snipaste_2024-02-12_20-37-59"></p>
<p>解决方案：大的核心系统始终往一个地方（消息队列）去发送消息，其他的系统都去订阅这个消息队列（读取消息队列中的消息）</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_20-38-59.png"  alt="Snipaste_2024-02-12_20-38-59"></p>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>1.耗时的场景</p>
<p>2.高并发的场景（异步，削峰填谷）</p>
<p>3.分布式系统协作（尤其是跨团队、跨业务协作，应用解耦）</p>
<p>4.强稳定性的场景（比如金融业务，持久化，可靠性，削峰填谷）</p>
<h5 id="消息队列的缺点"><a href="#消息队列的缺点" class="headerlink" title="消息队列的缺点"></a>消息队列的缺点</h5><p>要给系统引入额外的中间件，系统会更复杂，额外维护中间件，额外的费用（部署）成本</p>
<p>消息队列：消息丢失、顺序性、重复消费、数据的一致性（分布式系统就要考虑）</p>
<h4 id="主流消息队列选型"><a href="#主流消息队列选型" class="headerlink" title="主流消息队列选型"></a>主流消息队列选型</h4><h5 id="主流技术"><a href="#主流技术" class="headerlink" title="主流技术"></a>主流技术</h5><p>1.arctivemq</p>
<p>2.rabbitmq</p>
<p>3.kafka</p>
<p>4.rocketmq</p>
<p>5.zeromq</p>
<p>6.pulsar（云原生）</p>
<p>7.Apache InLong(Tube)</p>
<h5 id="技术对比"><a href="#技术对比" class="headerlink" title="技术对比"></a>技术对比</h5><p>技术选型指标</p>
<p>​	吞吐量：IO,并发</p>
<p>​	时效性：类似延迟，消息的发送，到达时间</p>
<table>
<thead>
<tr>
<th>技术名称</th>
<th>吞吐量</th>
<th>时效性</th>
<th>可用性</th>
<th>可靠性</th>
<th>优势</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>arctivemq</td>
<td>万级</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>简单易学</td>
<td>中小型企业，项目</td>
</tr>
<tr>
<td>rabbitmq</td>
<td>万级</td>
<td>极高（微妙）</td>
<td>高</td>
<td>高</td>
<td>生态好（基本什么语言都支持），时效性高，易学</td>
<td>适合绝大多数分布式的应用，这也是先学它的原因</td>
</tr>
<tr>
<td>kafka</td>
<td>十万级</td>
<td>高（毫秒以内）</td>
<td>极高</td>
<td>极高</td>
<td>吞吐量大，可靠性，可用性，强大的数据流处理能力</td>
<td>适合于<strong>大规模处理数据</strong>的场景，比如构建日志收集系统，实时数据流传输，事件数据流传输</td>
</tr>
<tr>
<td>rocketmq</td>
<td>十万级</td>
<td>高（ms）</td>
<td>极高</td>
<td>极高</td>
<td>吞吐量大，可靠性，可用性，可扩展性高</td>
<td>适用于<strong>金融</strong>、电商等对可靠性要求较高的场景，适合大规模的消息处理</td>
</tr>
<tr>
<td>pulsar</td>
<td>十万级</td>
<td>高（ms）</td>
<td>极高</td>
<td>极高</td>
<td>可靠性，可用性，基于发布订阅模式 ，新兴（技术架构先进）</td>
<td>适合大规模，高并发的分布式系统（云原生）。适合实时分析，事件流处理，IoT物联网数据处理等</td>
</tr>
</tbody></table>
<h4 id="RabbitMQ入门实战"><a href="#RabbitMQ入门实战" class="headerlink" title="RabbitMQ入门实战"></a>RabbitMQ入门实战</h4><p>官方网站：<a class="link"   target="_blank" rel="noopener" href="https://www.rabbitmq.com/getstarted.html" >https://www.rabbitmq.com/getstarted.html<i class="fas fa-external-link-alt"></i></a></p>
<p>特点：⽣态好，好学习、易于理解，时效性强，⽀特很多不同语⾔的客户端，扩展性、可⽤性都很不错。学习性价⽐⾮常⾼的消息队列，适⽤于绝⼤多数中⼩规模分布式系统。</p>
<h6 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h6><p>AMQP协议</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.rabbitmq.com/tutorials/amqp-concepts.html" >https://www.rabbitmq.com/tutorials/amqp-concepts.html<i class="fas fa-external-link-alt"></i></a></p>
<p>⽣产者(Publisher)：发消息到某个交换机 </p>
<p>消费者(Consumer)：从某个队列中取消息</p>
<p> 交换机(Exchange)：负责把消息转发到对应的队列 队列(Queue)：存储消息的 </p>
<p>路由(Routes)：转发，就是怎么把消息从⼀个地⽅转到另⼀个地⽅（⽐如从⽣产 者转发到某个队列）</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_21-59-49.png"  alt="Snipaste_2024-02-12_21-59-49"></p>
<p>安装：<a class="link"   target="_blank" rel="noopener" href="https://www.rabbitmq.com/#getstarted" >https://www.rabbitmq.com/#getstarted<i class="fas fa-external-link-alt"></i></a></p>
<p>1.先安装erlang25.3.2（因为RabbitMq依赖erlang）,这个语言的性能非常高</p>
<p>erlang下载：<a class="link"   target="_blank" rel="noopener" href="https://www.erlang.org/patches/otp-25.3.2" >https://www.erlang.org/patches/otp-25.3.2<i class="fas fa-external-link-alt"></i></a></p>
<p>2.安装完erlang后，安装rabbitmq即可</p>
<p>command+r打开services.msc服务菜单，查看rabbitmq服务是都已启动</p>
<p>3.安装rabbitmq监控面板</p>
<p>在rabbitmq安装目录的sbin中执行下述脚本</p>
<p>rabbitmq-plugins.bat enable rabbitmq_management</p>
<p>4.打开<a class="link"   target="_blank" rel="noopener" href="http://localhost:15672/" >http://localhost:15672/<i class="fas fa-external-link-alt"></i></a></p>
<p>默认的⽤户名和密码是”guest”</p>
<p>tips：如果想要在远程服务器安装访问rabbitmq管理面板，你要自己创建一个管理员账户，不能用默认的guest，否则会被拦截（官方出于安全考虑）</p>
<p>如果被拦截，可以自己创建管理员用户：</p>
<p>参考文档：<a class="link"   target="_blank" rel="noopener" href="https://www.rabbitmq.com/access-control.html" >https://www.rabbitmq.com/access-control.html<i class="fas fa-external-link-alt"></i></a></p>
<p>rabbitmq端口占用</p>
<p>5672：程序连接的端口</p>
<p>15672：webUI</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_22-45-17.png"  alt="Snipaste_2024-02-12_22-45-17"></p>
<h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>MQ官方教程</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.rabbitmq.com/#getstarted" >https://www.rabbitmq.com/#getstarted<i class="fas fa-external-link-alt"></i></a></p>
<p>⼀个⽣产者给⼀个队列发送消息，⼀个消费者从这个队列中获取到消息。1 对 1 关 系</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-12_22-56-03.png"  alt="Snipaste_2024-02-12_22-56-03"></p>
<p>1.引⼊ Rabbit MQ 组件依赖</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://mvnrepository.com/%E6%90%9Camqp-client" >https://mvnrepository.com/搜amqp-client<i class="fas fa-external-link-alt"></i></a></p>
<!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client -->
<dependency>
    <groupId>com.rabbitmq</groupId>
    <artifactId>amqp-client</artifactId>
    <version>5.20.0</version>
</dependency>



<p>之前命令行启动的是消息队列本身，但是少了生成者和消费者，所以需要自己定义</p>
<h5 id="单消费者"><a href="#单消费者" class="headerlink" title="单消费者"></a>单消费者</h5><p>生产者代码</p>
<pre><code>import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.nio.charset.StandardCharsets;

public class Send &#123;
private final static String QUEUE_NAME = &quot;hello&quot;;

public static void main(String[] argv) throws Exception &#123;
    ConnectionFactory factory = new ConnectionFactory();
    factory.setHost(&quot;localhost&quot;);
    try (Connection connection = factory.newConnection();
         Channel channel = connection.createChannel()) &#123;
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        String message = &quot;Hello World!&quot;;
        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes(StandardCharsets.UTF_8));
        System.out.println(&quot; [x] Sent &#39;&quot; + message + &quot;&#39;&quot;);
    &#125;
&#125;
&#125;
</code></pre>
<p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recv</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Channel频道：理解为操作消息队列的client（比如jdbcClient,redisClient）,提供了和消息队列server建立通信的传输方法（为了复用链接，提高传输效率）.程序通过channel操作rabbitmq(收发消息)</p>
<p>创建消息队列：</p>
<p>参数：</p>
<p>queueName：消息队列名称（注意，同名称的消息队列，只能⽤同样的参数创建⼀次）</p>
<p>durabale：消息队列重启后，消息是否丢失，持久化处理</p>
<p>exclusive：是否只允许当前这个创建消息队列的连接操作消息队列</p>
<p>autoDelete：没有⼈⽤队列后，是否要删除队列</p>
<p>测试：单消费者</p>
<hr>
<p>demo：</p>
<p>生产者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SingleProducer &#123;</span><br><span class="line">private final static String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    //创建链接工厂</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">//    factory.setUsername();</span><br><span class="line">//    factory.setPassword();</span><br><span class="line">//    factory.setPort();</span><br><span class="line">    //建立链接，创建频道</span><br><span class="line">    try (Connection connection = factory.newConnection();</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line">        //创建消息队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">        //发送消息</span><br><span class="line">        String message = &quot;Hello World!&quot;;</span><br><span class="line">        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SingleConsumer &#123;</span><br><span class="line">private final static String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    //创建链接</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    //创建消息队列，为了保证队列一定是存在的</span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">    System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class="line"></span><br><span class="line">    //定义了如何处理消息</span><br><span class="line">    DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        String message = new String(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(&quot; [x] Received &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    //消费消息，会持续阻塞。autoAck参数表示参数取出来后就是表示自动完成消费了</span><br><span class="line">    channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_07-20-47.png"  alt="Snipaste_2024-02-13_07-20-47"></p>
<hr>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_07-31-33.png"  alt="Snipaste_2024-02-13_07-31-33"></p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_07-33-24.png"  alt="Snipaste_2024-02-13_07-33-24"></p>
<h5 id="多消费者"><a href="#多消费者" class="headerlink" title="多消费者"></a>多消费者</h5><p><a class="link"   target="_blank" rel="noopener" href="https://www.rabbitmq.com/tutorials/tutorial-two-java.html" >https://www.rabbitmq.com/tutorials/tutorial-two-java.html<i class="fas fa-external-link-alt"></i></a></p>
<p>场景：多个机器接收并处理任务（尤其是每个机器处理能力有限）</p>
<p>一个生产者给一个队列发消息，多个消费者从这个队列取消息。一对多</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_07-36-50.png"  alt="Snipaste_2024-02-13_07-36-50"></p>
<p><strong>1.队列持久化</strong></p>
<p>durable参数设置为true:服务器重启后队列不丢失</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(TASK_QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>



<p><strong>2.消息持久化</strong></p>
<p>指定参数：MessageProperties.PERSISTENT_TEXT_PLAIN</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME,</span><br><span class="line">        MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">        message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>



<p>生产者代码</p>
<p>使用Scanner接收用户输入，便于发送多条消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class MultiProducer &#123;</span><br><span class="line"></span><br><span class="line">  private static final String TASK_QUEUE_NAME = &quot;multi_queue&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    try (Connection connection = factory.newConnection();</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext())&#123;</span><br><span class="line">            String message = scanner.nextLine();</span><br><span class="line">            channel.basicPublish(&quot;&quot;, TASK_QUEUE_NAME,</span><br><span class="line">                    MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">                    message.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">            System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>控制单个消费者的处理任务积压数：</strong></p>
<p>每个消费者最多同时处理1个任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<p><strong>消息确认机制</strong></p>
<p>为了保证消息成功被消费（快递成功被取走），rabbitmq提供了消息确认机制，当消费者接收到消息后，必须要给一个反馈</p>
<p>​	ack:消费成功</p>
<p>​	nack:消费失败</p>
<p>​	reject:拒绝</p>
<p>如果告诉rabbitmq服务器消费成功，服务器才会放心地移除消息</p>
<p>支持配置autoack,会自动执行ack命令，相当于接收到消息立刻就成功了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicConsume(TASK_QUEUE_NAME, false, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure>

<p>但是如果我们接收消息的工作没有完成那么就不需要接收成功了</p>
<p>所以实际情况下autoack要改为false，根据实际情况手动确认</p>
<p><strong>指定确认某条消息：</strong></p>
<p>basicAck的第二个参数multiple（批量确认）：是否要一次性确认所有的历史消息直到当前这条</p>
<p>​	true:把之前每确认的消息都确认了（如果服务器希望把以前失败的都改为true）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);</span><br></pre></td></tr></table></figure>



<p><strong>指定拒绝某条消息</strong></p>
<p>basicNack的第二个参数multiple（批量拒绝）</p>
<p>第三个参数requeue:是否把参数再重新放回消息队列里，可用于重试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicNack(delivery.getEnvelope().getDeliveryTag(),false,false);</span><br></pre></td></tr></table></figure>



<p>消费者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class MutiConsumer &#123;</span><br><span class="line"></span><br><span class="line">  private static final String TASK_QUEUE_NAME = &quot;multi_queue&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">      //建立链接</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    final Connection connection = factory.newConnection();</span><br><span class="line">      for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">          final Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">          channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null);</span><br><span class="line">          System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class="line"></span><br><span class="line">          channel.basicQos(1);</span><br><span class="line"></span><br><span class="line">          //定义了如何处理消息</span><br><span class="line">          int finalI = i;</span><br><span class="line">          DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">              String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              try &#123;</span><br><span class="line">                  //处理工作</span><br><span class="line">                  System.out.println(&quot; [x] Received &#x27;&quot; +&quot;编号&quot;+ finalI +&quot;:&quot;+ message + &quot;&#x27;&quot;);</span><br><span class="line">                  channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);</span><br><span class="line">                  //停20秒，模拟机器处理能力有限</span><br><span class="line">                  Thread.sleep(20000);</span><br><span class="line">              &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">                  channel.basicNack(delivery.getEnvelope().getDeliveryTag(),false,false);</span><br><span class="line"></span><br><span class="line">              &#125; finally &#123;</span><br><span class="line">                  System.out.println(&quot; [x] Done&quot;);</span><br><span class="line">                  channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">          //开启消费监听</span><br><span class="line">          channel.basicConsume(TASK_QUEUE_NAME, false, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2个小技巧</p>
<p>​	1.使用Scanner接收用户输入，便于快速发送多条消息</p>
<p>​	2.使用for循环创建多个消费者，便于快速验证队列模型工作机制</p>
<h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>场景：多个机器接收并处理任务（尤其是每个机器处理能力有限）</p>
<p>一个生产者给多个队列发消息，一个生产者对多个队列</p>
<p>教程</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.rabbitmq.com/tutorials/tutorial-three-java.html" >https://www.rabbitmq.com/tutorials/tutorial-three-java.html<i class="fas fa-external-link-alt"></i></a></p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_08-49-53.png"  alt="Snipaste_2024-02-13_08-49-53"></p>
<p>交换机的作用：负责把快递发送到对应的快递站，类似于网络路由器，提供转发功能</p>
<p>解决的问题：怎么把消息转发到不同的队列上。好让消费者从不同的队列消费</p>
<p>绑定：交换机和队列关联起来，也可以叫路由，算是一个算法或转发策略</p>
<p>绑定代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel1.queueBind(queueName, EXCHANGE_NAME, &quot;绑定规则&quot;);</span><br></pre></td></tr></table></figure>



<h5 id="交换机有多种类别"><a href="#交换机有多种类别" class="headerlink" title="交换机有多种类别"></a>交换机有多种类别</h5><p>1.fanout:扇出，广播</p>
<p>场景：很适用于发布订阅的场景，写日志，可以多个系统间共享</p>
<p>特点：消息会被转发到所有绑定到该交换机的队列</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_08-49-53.png"  alt="Snipaste_2024-02-13_08-49-53"></p>
<p>示例场景</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_09-05-28.png"  alt="Snipaste_2024-02-13_09-05-28"></p>
<p>生产者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class FanoutProducer &#123;</span><br><span class="line"></span><br><span class="line">  private static final String EXCHANGE_NAME = &quot;fanout-exchange&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    try (Connection connection = factory.newConnection();</span><br><span class="line">         //建立链接</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line">        //创建交换机</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext())&#123;</span><br><span class="line">            String message = scanner.nextLine();</span><br><span class="line">            //参数：1.交换机的名称，2.路由规则</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">            System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码</p>
<p>注意：</p>
<p>1.消费者和生产者要绑定同一个交换机</p>
<p>2.要先有队列，才能绑定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class FanoutConsumer &#123;</span><br><span class="line">  private static final String EXCHANGE_NAME = &quot;fanout-exchange&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel1 = connection.createChannel();</span><br><span class="line">    Channel channel2 = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    //声明交换机</span><br><span class="line">    channel1.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);</span><br><span class="line">    //创建小王队列，没有指定队列时随机分配一个队列名称</span><br><span class="line">    String queueName =&quot;小王的工作队列&quot;;</span><br><span class="line">    channel1.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">    //绑定队列</span><br><span class="line">    channel1.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    //创建小李队列</span><br><span class="line">    String queueName2 = &quot;小李的工作队列&quot;;</span><br><span class="line">    channel2.queueDeclare(queueName2, true, false, false, null);</span><br><span class="line">    //绑定队列</span><br><span class="line">    channel2.queueBind(queueName2, EXCHANGE_NAME, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class="line"></span><br><span class="line">    //小王小李的处理流程</span><br><span class="line">    DeliverCallback deliverCallback1 = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">        System.out.println(&quot; [小王] Received &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    DeliverCallback deliverCallback2 = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">      String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">      System.out.println(&quot; [小李] Received &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    channel1.basicConsume(queueName, true, deliverCallback1, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    channel2.basicConsume(queueName2, true, deliverCallback2, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：所有的消费者都能收到消息</p>
<h5 id="Direct交换机"><a href="#Direct交换机" class="headerlink" title="Direct交换机"></a>Direct交换机</h5><p>官方教程：<a class="link"   target="_blank" rel="noopener" href="https://www.rabbitmq.com/tutorials/tutorial-four-java.html" >https://www.rabbitmq.com/tutorials/tutorial-four-java.html<i class="fas fa-external-link-alt"></i></a></p>
<p>在fanout交换机的基础上加了<strong>转发规则</strong></p>
<p>交换机：相当于路由表（知道所有转发规则）</p>
<p>绑定：可以让交换机和队列进行关联，可以指定交换机把什么样的消息发送给哪个队列（类似于计算机网络中，两个路由器，或者网络设备相互连接，也可以理解为网线）</p>
<p>routekey：路由键，指定消息转发给哪个队列（ip地址）</p>
<p>特点：消息会根据路由键转发到指定的队列（但一个路由键可以绑定多个队列）</p>
<p>场景：特定的消息只交给特定系统（程序）来处理</p>
<p>绑定关系：完全匹配字符串</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_10-18-32.png"  alt="Snipaste_2024-02-13_10-18-32"></p>
<p>比如发日志的场景，希望用独立的程序来处理不同级别的日志，比如C1系统处理error日志，C2系统处理其他级别的日志</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_10-27-55.png"  alt="Snipaste_2024-02-13_10-27-55"></p>
<p>示例场景</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_10-25-46.png"  alt="Snipaste_2024-02-13_10-25-46"></p>
<p>生产者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class DirectProducer &#123;</span><br><span class="line"></span><br><span class="line">  private static final String EXCHANGE_NAME = &quot;direct_exchange&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    try (Connection connection = factory.newConnection();</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext())&#123;</span><br><span class="line">            String userInput = scanner.nextLine();</span><br><span class="line">            String[] strings = userInput.split(&quot; &quot;);</span><br><span class="line">            if (strings.length &lt; 1)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            String message = strings[0];</span><br><span class="line">            String routeKey = strings[1];</span><br><span class="line">            //参数：1.交换机的名称，2.路由规则</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, routeKey, null, message.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">            System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;with routing&quot; + routeKey + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class DirectConsumer &#123;</span><br><span class="line"></span><br><span class="line">  private static final String EXCHANGE_NAME = &quot;direct_exchange&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);</span><br><span class="line"></span><br><span class="line">    //创建小zhao队列，没有指定队列时随机分配一个队列名称</span><br><span class="line">     String queueName =&quot;小zhao的工作队列&quot;;</span><br><span class="line">    channel.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">    //绑定队列</span><br><span class="line">    channel.queueBind(queueName, EXCHANGE_NAME, &quot;小zhao&quot;);</span><br><span class="line"></span><br><span class="line">    //创建小ling队列，没有指定队列时随机分配一个队列名称</span><br><span class="line">     String queueName2 =&quot;小ling的工作队列&quot;;</span><br><span class="line">    channel.queueDeclare(queueName2, true, false, false, null);</span><br><span class="line">    //绑定队列</span><br><span class="line">    channel.queueBind(queueName2, EXCHANGE_NAME, &quot;小ling&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class="line"></span><br><span class="line">    DeliverCallback xiaozhaoDeliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">        System.out.println(&quot; [xiaozhao] Received &#x27;&quot; +</span><br><span class="line">            delivery.getEnvelope().getRoutingKey() + &quot;&#x27;:&#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">      DeliverCallback xiaolingDeliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">          String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">          System.out.println(&quot; [xiaoling] Received &#x27;&quot; +</span><br><span class="line">                  delivery.getEnvelope().getRoutingKey() + &quot;&#x27;:&#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">    channel.basicConsume(queueName, true, xiaozhaoDeliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    channel.basicConsume(queueName, true, xiaolingDeliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="topic交换机"><a href="#topic交换机" class="headerlink" title="topic交换机"></a>topic交换机</h5><p><a class="link"   target="_blank" rel="noopener" href="https://www.rabbitmq.com/tutorials/tutorial-five-java.html" >https://www.rabbitmq.com/tutorials/tutorial-five-java.html<i class="fas fa-external-link-alt"></i></a></p>
<p>特点：消息会根据一个<strong>模糊的</strong>路由键转发到指定的队列（可以是一个或多个队列）</p>
<p>场景：特定的一类消息可以交给特定的一类系统（程序）来处理</p>
<p>绑定关系：可以模糊匹配多个绑定</p>
<ol>
<li><p>* ：匹配⼀个单词，⽐如 *.shier ，那么 a.shier 、 b.shier 都能匹配</p>
</li>
<li><p># ：匹配 0 个或多个单词，⽐如 a.# ，那么 a.a 、 a.b 、 a.a.a 都匹配 </p>
<p>#.a.# 可以匹配 a.b 、 a1.a 等形式 a 的前⾯可以是 0 个或多个字符串，后⾯也是 0 个或者多个字符串</p>
<p>注意，这⾥的匹配和 MySQL 的 like 的 % 不⼀祥，只按照单词来匹配，每 个 ‘.’ 分隔单词，如果是 ‘#.’ ，其实可以忽略，匹配 0 个词可以的</p>
</li>
</ol>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_11-08-38.png"  alt="Snipaste_2024-02-13_11-08-38"></p>
<p>应用场景：</p>
<p>老板下发一个任务，让多个组来处理</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_11-55-09.png"  alt="Snipaste_2024-02-13_11-55-09"></p>
<p>生产者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TopicProducer &#123;</span><br><span class="line"></span><br><span class="line">  private static final String EXCHANGE_NAME = &quot;topic_exchange&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    try (Connection connection = factory.newConnection();</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext())&#123;</span><br><span class="line">            String userInput = scanner.nextLine();</span><br><span class="line">            String[] strings = userInput.split(&quot; &quot;);</span><br><span class="line">            if (strings.length &lt; 1)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            String message = strings[0];</span><br><span class="line">            String routeKey = strings[1];</span><br><span class="line">            //参数：1.交换机的名称，2.路由规则</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, routeKey, null, message.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">            System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;with routing&quot; + routeKey + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class TopicConsumer &#123;</span><br><span class="line"></span><br><span class="line">  private static final String EXCHANGE_NAME = &quot;topic_exchange&quot;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;);</span><br><span class="line"></span><br><span class="line">      //创建前端队列</span><br><span class="line">      String queueName =&quot;frontend_queue&quot;;</span><br><span class="line">      channel.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">      //绑定队列</span><br><span class="line">      channel.queueBind(queueName, EXCHANGE_NAME, &quot;#.前端.#&quot;);</span><br><span class="line"></span><br><span class="line">      //创建后端队列</span><br><span class="line">      String queueName2 =&quot;backend_queue&quot;;</span><br><span class="line">      channel.queueDeclare(queueName2, true, false, false, null);</span><br><span class="line">      //绑定队列</span><br><span class="line">      channel.queueBind(queueName2, EXCHANGE_NAME, &quot;#.后端.#&quot;);</span><br><span class="line"></span><br><span class="line">      //创建产品队列</span><br><span class="line">      String queueName3 =&quot;product_queue&quot;;</span><br><span class="line">      channel.queueDeclare(queueName3, true, false, false, null);</span><br><span class="line">      //绑定队列</span><br><span class="line">      channel.queueBind(queueName3, EXCHANGE_NAME, &quot;#.产品.#&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class="line"></span><br><span class="line">      DeliverCallback xiaoADeliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">          String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">          System.out.println(&quot; [xiaozhao] Received &#x27;&quot; +</span><br><span class="line">                  delivery.getEnvelope().getRoutingKey() + &quot;&#x27;:&#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">      &#125;;</span><br><span class="line">      DeliverCallback xiaoBDeliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">          String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">          System.out.println(&quot; [xiaoling] Received &#x27;&quot; +</span><br><span class="line">                  delivery.getEnvelope().getRoutingKey() + &quot;&#x27;:&#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      DeliverCallback xiaoCDeliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">          String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">          System.out.println(&quot; [xiaoling] Received &#x27;&quot; +</span><br><span class="line">                  delivery.getEnvelope().getRoutingKey() + &quot;&#x27;:&#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      channel.basicConsume(queueName, true, xiaoADeliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">      channel.basicConsume(queueName, true, xiaoBDeliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">      channel.basicConsume(queueName, true, xiaoCDeliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Headers交换机"><a href="#Headers交换机" class="headerlink" title="Headers交换机"></a>Headers交换机</h5><p>类似Topic交换机和Direct交换机，可以根据headers中的内容来指定发送到哪个队列</p>
<p>由于性能差，比较复杂，一般不推荐使用</p>
<h5 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h5><p>支持消息队列来模拟RPC的调用，但是一般没必要，直接用Dubbo,GRPC等RPC框架就好</p>
<p>就好比redis模拟消息队列，其实没必要，redis的应用场景就是做缓存或者分布式存储</p>
<p>实现一个场景总有更合适的、更专注的技术</p>
<p>AI学习连环问：是什么？有什么用？什么应用场景下会用？有什么优缺点？有没有示例代码？</p>
<h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h4><h5 id="消息过期机制"><a href="#消息过期机制" class="headerlink" title="消息过期机制"></a>消息过期机制</h5><p>官方文档：<a class="link"   target="_blank" rel="noopener" href="https://www.rabbitmq.com/ttl.html" >https://www.rabbitmq.com/ttl.html<i class="fas fa-external-link-alt"></i></a></p>
<p>可以给每条消息指定⼀个有效期，⼀段时间内未被消费者处理，就过期了。</p>
<p>示例场景： </p>
<p>消费者（库存系统）挂了，⼀个订单 15 分钟还没被库存系统处理，这个订单其 实已经失效了，哪怕库存系统再恢复，其实也不⽤扣减库存。 假设⼀个⽤户向⼀个新系统发送了⼀个请求，⽐如⽀付订单。订单通常有⼀个有 效期限，⽐如 15 分钟。如果在这 15 分钟内，下游系统没有及时处理该订单，这 可能意味着下游系统出现了故障，或者在这个时间段内不再需要处理该订单了。 在这种情况下，如果将该消息放⼊队列中，并设置了 15 分钟的过期时间，那么 如果 15 分钟后还没有消费者来获取该消息，该⽀付订单消息就会过期。订单在 15 分钟内没有⽀付，那么该订单就已经失效了。下游系统就不再需要处理这个订 单，也不需要更新库存或处理物流等相关操作。因此，消息过期机制⾮常适⽤于 这种过期场景的处理。通过设置合适的过期时间，可以确保及时清理⽆效的消 息，提⾼系统的效率和准确性。</p>
<p>适⽤场景：清理过期数据、模拟延迟队列的实现（不开会员就慢速）、专⻔让某个程 序处理过期请求</p>
<ol>
<li><p>订单超时取消：在电商平台中，可以设置订单的过期时间，如果⽤户在规定时间 内未⽀付订单，则将订单标记为过期取消。</p>
</li>
<li><p>预约失效处理：在医院或美容院等场所，⽤户预约服务后，可以设置预约消息的 过期时间，如果⽤户在规定时间内未到达，可以取消预约或释放时间。</p>
</li>
<li><p>缓存更新和失效：在⽹站或应⽤中，可以将数据加载到缓存中，设置过期时间以 保持数据的新鲜度，并在数据过期后重新加载最新数据。 </p>
</li>
<li><p>⽇志记录和清理：在系统中，可以将⽇志记录为消息发送到队列中，并设置过期 时间以限制⽇志数据的保留时间，以及⾃动清理过期的⽇志。</p>
</li>
<li><p>定时任务调度：可以使⽤ RabbitMQ 结合过期时间来实现定时任务调度。通过设 置消息的过期时间，将任务消息发送到队列中，并在过期后触发执⾏相应的任务 操作。</p>
</li>
</ol>
<p>类型</p>
<p>1.给队列中的消息指定过期时间</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建消息队列，指定消息过期参数</span><br><span class="line">Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(&quot;x-message-ttl&quot;, 5000);</span><br><span class="line">//args指定参数</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, false, false, false, args);</span><br></pre></td></tr></table></figure>

<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_13-46-51.png"  alt="Snipaste_2024-02-13_13-46-51"></p>
<p>消费者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class TtlConsumer &#123;</span><br><span class="line">private final static String QUEUE_NAME = &quot;ttl_queue&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    //创建链接</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    //创建消息队列，指定消息过期参数</span><br><span class="line">    Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();</span><br><span class="line">    args.put(&quot;x-message-ttl&quot;, 5000);</span><br><span class="line">    //args指定参数</span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, false, false, false, args);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class="line">    //定义了如何处理消息</span><br><span class="line">    DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        String message = new String(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(&quot; [x] Received &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    //消费消息，会持续阻塞。autoAck参数表示参数取出来后就是表示自动完成消费了</span><br><span class="line">    channel.basicConsume(QUEUE_NAME, false, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class TtlProducer &#123;</span><br><span class="line">private final static String QUEUE_NAME = &quot;ttl_queue&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    //创建链接工厂</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">//    factory.setUsername();</span><br><span class="line">//    factory.setPassword();</span><br><span class="line">//    factory.setPort();</span><br><span class="line">    //建立链接，创建频道</span><br><span class="line">    try (Connection connection = factory.newConnection();</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line">        //发送消息</span><br><span class="line">        String message = &quot;Hello World!&quot;;</span><br><span class="line">        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在过期时间内，还没有消费者取消息，消息才会过期</p>
<p>注意：如果消息已经接收到，但是没确认，是不会过期的。</p>
<p>如果消息处于待消费状态并且过期时间到达后，消息将被标记为过期。但是，如果 消息已经被消费者消费，并且正在处理过程中，即使过期时间到达，消息仍然会被 正常处理。</p>
<p>一般消费者先启动，保证后面生产者发的消息都能监听到，而不是生产者发了很多消息，消息都存在积压了，而消费者才启动</p>
<p>2.给某条消息指定过期时间</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//给消息指定过期时间</span><br><span class="line">AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()</span><br><span class="line">        .expiration(&quot;1000&quot;)</span><br><span class="line">        .build();</span><br><span class="line">channel.basicPublish(&quot;my-exchange&quot;, &quot;routing-key&quot;, properties,message.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>

<p>生产者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TtlProducer &#123;</span><br><span class="line">private final static String QUEUE_NAME = &quot;ttl_queue&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    //创建链接工厂</span><br><span class="line">    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">    factory.setHost(&quot;localhost&quot;);</span><br><span class="line">    //建立链接，创建频道</span><br><span class="line">    try (Connection connection = factory.newConnection();</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line">        //发送消息</span><br><span class="line">        String message = &quot;Hello World!&quot;;</span><br><span class="line"></span><br><span class="line">        //给消息指定过期时间</span><br><span class="line">        AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()</span><br><span class="line">                .expiration(&quot;1000&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        channel.basicPublish(&quot;my-exchange&quot;, &quot;routing-key&quot;, properties,message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h5 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h5><p>官方文档：<a class="link"   target="_blank" rel="noopener" href="https://www.rabbitmq.com/confirms.html" >https://www.rabbitmq.com/confirms.html<i class="fas fa-external-link-alt"></i></a></p>
<p>之前讲过</p>
<h5 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h5><p>官方文档：<a class="link"   target="_blank" rel="noopener" href="https://www.rabbitmq.com/dlx.html" >https://www.rabbitmq.com/dlx.html<i class="fas fa-external-link-alt"></i></a></p>
<p>为了保证消息的可靠性，比如每条消息都成功消费，需要提供一个容错机制，即：失败的消息怎么处理？</p>
<p>死信：过期的消息、拒收的消息、消息队列满了、处理失败的消息的统称</p>
<p>死信队列：专门处理死信的队列（注意它就是一个普通队列，只不过是专门用来处理死信的，甚至可以理解这个队列的名称叫“死信队列”）</p>
<p>死信交换机：专门给死信队列转发消息的交换机（注意：它就是一个普通的交换机，只不过专门给死信队列发消息而已，理解这个交换机的名称就叫“死信交换机”），也存在路由绑定</p>
<p>死信可以通过死信交换机绑定到死信队列</p>
<p>示例场景</p>
<p>实现：</p>
<p>1.创建死信交换机和死信队列，并且绑定关系</p>
<p><img   src="/%E5%AE%A2%E6%B5%81%E9%87%8F%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%5CSnipaste_2024-02-13_20-05-48.png"  alt="Snipaste_2024-02-13_20-05-48"></p>
<p>2.给失败之后需要容错处理的队列绑定死信交换机</p>
<p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//指定死信队列参数</span><br><span class="line">Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();</span><br><span class="line">//要绑定到哪个交换机</span><br><span class="line">args.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE_NAME);</span><br><span class="line">//指定死信要转发到哪个队列</span><br><span class="line">args.put(&quot;x-dead-letter-routing-key&quot;, &quot;waibao&quot;);</span><br><span class="line"></span><br><span class="line">//创建队列，没有指定队列时随机分配一个队列名称</span><br><span class="line"> String queueName =&quot;xiaodog_queue&quot;;</span><br><span class="line">channel.queueDeclare(queueName, true, false, false, args);</span><br><span class="line">//绑定队列</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, &quot;xiaodog&quot;);</span><br></pre></td></tr></table></figure>

<p>3.可以给要容错的队列指定死信之后的转发规则，死信应该再转发到哪个死信队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//指定死信要转发到哪个队列</span><br><span class="line">args.put(&quot;x-dead-letter-routing-key&quot;, &quot;waibao&quot;);</span><br></pre></td></tr></table></figure>







<h4 id="RabbitMQ的重要特性（面试考点）"><a href="#RabbitMQ的重要特性（面试考点）" class="headerlink" title="RabbitMQ的重要特性（面试考点）"></a>RabbitMQ的重要特性（面试考点）</h4><p>1.消息队列的概念、模型、应用场景</p>
<p>2.交换机的类别，路由绑定的关系</p>
<p>3.消息可靠性</p>
<p>​	a.消息确认机制（ack,nack,reject）</p>
<p>​	b.消息持久化(durable)</p>
<p>​	c.消息过期机制</p>
<p>​	d.死信队列</p>
<p>4.延迟队列（类似死信队列）</p>
<p>5.顺序消费、消费幂等性（本次不讲）</p>
<p>6.可扩展性（仅做了解）</p>
<p>​	a.集群</p>
<p>​	b.故障的恢复机制</p>
<p>​	c.镜像</p>
<p>7.运维监控告警（仅做了解）</p>
<h4 id="RabbitMQ项目实战"><a href="#RabbitMQ项目实战" class="headerlink" title="RabbitMQ项目实战"></a>RabbitMQ项目实战</h4><h5 id="选择客户端"><a href="#选择客户端" class="headerlink" title="选择客户端"></a>选择客户端</h5><p>1.使⽤官⽅的客户端 </p>
<p>优点：兼容性好，换语⾔成本低，⽐较灵活 </p>
<p>缺点：太灵活，要⾃⼰去处理⼀些事情。⽐如要⾃⼰维护管理链接，很麻烦。 </p>
<p>2.使⽤封装好的客户端，⽐如 Spring Boot RabbitMQ Starter </p>
<p>优点：简单易⽤，直接配置直接⽤，更⽅便地去管理连接 </p>
<p>缺点：封装的太好了，你没学过的话反⽽不知道怎么⽤。不够灵活，被框架限制。 </p>
<p>根据场景来选择，没有绝对的优劣，类似 jdbc 和 MyBatis</p>
<p> 优点：</p>
<ol>
<li><p>强⼤的功能⽀持：RabbitMQ Java 客户端提供了丰富的功能和特性，例如消息 确认、事务⽀持、消费者拉取、消息重试、可靠性消息传递等。 </p>
</li>
<li><p>可靠性和稳定性：通过使⽤可靠的消息确认机制和事务⽀持，Java 客户端可以 确保消息的可靠传递和处理。 </p>
</li>
<li><p>开发⼈员社区⽀持：RabbitMQ Java 客户端拥有⼴泛的开发⼈员社区⽀持，并 且有⼤量的⽂档和示例代码可供参考。</p>
</li>
<li><p>良好的性能：Java 客户端采⽤了⾼性能的⽹络通信协议和线程模型，可以在⾼ 并发的场景下表现出较好的性能。</p>
<p>缺点： </p>
<ol>
<li>复杂性：相对于其他语⾔的 RabbitMQ 客户端，Java 客户端可能会更加复杂和 臃肿，需要更多的代码和配置。 </li>
<li>内存占⽤：由于 Java 客户端的⼀些设计和依赖，可能会占⽤较多的内存资源， 尤其在⾼并发的情况下。</li>
</ol>
</li>
</ol>
<p>3.本次使⽤ Spring Boot RabbitMQ Starter (因为我们是 Spring Boot 项⽬) 如果你有⼀定⽔平，有基础，英⽂好，建议看官⽅⽂档，不要看过期博客！ 官⽹地址：<a class="link"   target="_blank" rel="noopener" href="https://spring.io/guides/gs/messaging-rabbitmq" >https://spring.io/guides/gs/messaging-rabbitmq<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="项目引入RabbitMQ"><a href="#项目引入RabbitMQ" class="headerlink" title="项目引入RabbitMQ"></a>项目引入RabbitMQ</h5><p>1.安装依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-amqp --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>注意：使用的版本和springboot使用的版本一致</p>
<p>2.在yml中引入配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    rabbitmq:</span><br><span class="line">      host: localhost</span><br><span class="line">      port: 5672</span><br><span class="line">      password: guest</span><br><span class="line">      username: guest</span><br></pre></td></tr></table></figure>

<p>3.创建交换机和队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用于创建测试程序用到的交换机和队列（只用在程序启动前执行一次）</span><br><span class="line"> */</span><br><span class="line">public class MqInitMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">            factory.setHost(&quot;localhost&quot;);</span><br><span class="line">            Connection connection = factory.newConnection();</span><br><span class="line">            Channel channel = connection.createChannel();</span><br><span class="line">            String EXCHANGE_NAME = &quot;code_exchange&quot;;</span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);</span><br><span class="line">            //创建小zhao队列，没有指定队列时随机分配一个队列名称</span><br><span class="line">            String queueName =&quot;code_queue&quot;;</span><br><span class="line">            channel.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">            //绑定队列</span><br><span class="line">            channel.queueBind(queueName, EXCHANGE_NAME, &quot;my_routingKey&quot;);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.生产者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyMessageProducer &#123;</span><br><span class="line"></span><br><span class="line">    //根据yml配置生成对象</span><br><span class="line">    @Resource</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 消费者发送消息方法</span><br><span class="line">     *</span><br><span class="line">     * @param exchange 交换机</span><br><span class="line">     * @param routeKey 路由键</span><br><span class="line">     * @param message 消息</span><br><span class="line">     */</span><br><span class="line">    public void sendMessage(String exchange, String routeKey, String message)&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routeKey, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.消费者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class MyMessageConsumer &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //不想抛异常可以使用@SneakyThrows注解，不建议这样做</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    //指定程序监听的消息队列和确认机制</span><br><span class="line">    @RabbitListener(queues = &#123;&quot;code_queue&quot;&#125;,ackMode = &quot;MANUAL&quot;)</span><br><span class="line">    public void receiveMessage(String message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliverTag)&#123;</span><br><span class="line">        log.info(&quot;receiveMessage = &#123;&#125;&quot;,message);</span><br><span class="line">        channel.basicAck(deliverTag, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.单元测试执行</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class MyMessageProducerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private MyMessageProducer myMessageProducer;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void sendMessage() &#123;</span><br><span class="line">        myMessageProducer.sendMessage(&quot;code_exchange&quot;,&quot;my_routingKey&quot;,&quot;你好&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先debug启动yml，在测试sendMessage方法</p>
<hr>
<h4 id="BI项目改造"><a href="#BI项目改造" class="headerlink" title="BI项目改造"></a>BI项目改造</h4><h5 id="改造前"><a href="#改造前" class="headerlink" title="改造前"></a>改造前</h5><p>以前是把任务提交到线程池，然后在线程池提交中编写处理程序的代码，线程池内排 队。 如果程序中断了，任务就没了，就丢了。</p>
<h5 id="改造后"><a href="#改造后" class="headerlink" title="改造后"></a>改造后</h5><p>改造后的流程： </p>
<ol>
<li><p>把任务提交改为向队列发送消息 </p>
</li>
<li><p>写⼀个专引⻔的接受消息的程序，处理任务 </p>
</li>
<li><p>如果程序中断了，消息未被确认，还会重发 </p>
</li>
<li><p>现在，消息全部集中发到消息队列，可以部署多个后端，都从同⼀个地⽅取任 务，从⽽实现了分布式负载均衡</p>
<p>通过这样的改进，我们实现了⼀种更可靠的任务处理⽅式。任务不再依赖于线程池， ⽽是通过消息队列来进⾏分发和处理，即使程序中断或出现故障，任务也能得到保证 并得到正确处理。同时，我们还可以通过部署多个后端程序来实现负载均衡，提⾼系 统的处理能⼒和可靠性。</p>
<p> 实现步骤： </p>
<ol>
<li><p>创建交换机和队列 </p>
</li>
<li><p>将线程池中的执⾏代码移到消费者类中 </p>
</li>
<li><p>根据消费者的需求来确认消息的格式(chartld) </p>
</li>
<li><p>将提交线程池改造为发送消息到队列 </p>
<p>验证 </p>
<p>验证发现，如果程序中断了，没有 ack、也没有 nack (服务中断，没有任何响应)， 那么这条消息会被重新放到消息队列中，从⽽实现了每个任务都会执⾏。</p>
</li>
</ol>
</li>
</ol>
<p>注：线程池更适用于需要多线程处理任务，而MQ更适用于服务间通信，应用解耦，消息保障性</p>
<p>准备：</p>
<p>1.创建队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用于创建测试程序用到的交换机和队列（只用在程序启动前执行一次）</span><br><span class="line"> */</span><br><span class="line">public class BiInitMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">            factory.setHost(&quot;localhost&quot;);</span><br><span class="line">            Connection connection = factory.newConnection();</span><br><span class="line">            Channel channel = connection.createChannel();</span><br><span class="line">            String EXCHANGE_NAME = BiMqConstant.BI_EXCHANGE_NAME;</span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);</span><br><span class="line">            //创建队列，没有指定队列时随机分配一个队列名称</span><br><span class="line">            String queueName =BiMqConstant.BI_QUEUE_NAME;</span><br><span class="line">            channel.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">            //绑定队列</span><br><span class="line">            channel.queueBind(queueName, EXCHANGE_NAME, BiMqConstant.BI_ROUTING_KEY);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.建立BiConstant:存常量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface BiMqConstant &#123;</span><br><span class="line">    String BI_QUEUE_NAME = &quot;bi_queue&quot;;</span><br><span class="line">    String BI_EXCHANGE_NAME = &quot;bi_exchange&quot;;</span><br><span class="line">    String BI_ROUTING_KEY = &quot;bi_routingKey&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.设置BI生产者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class BiMessageProducer &#123;</span><br><span class="line"></span><br><span class="line">    //根据yml配置生成对象</span><br><span class="line">    @Resource</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 消费者发送消息方法</span><br><span class="line">     *</span><br><span class="line">     * @param message 消息</span><br><span class="line">     */</span><br><span class="line">    public void sendMessage( String message)&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(BiMqConstant.BI_EXCHANGE_NAME, BiMqConstant.BI_ROUTING_KEY, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.设置BI消费者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class BiMessageConsumer &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //不想抛异常可以使用@SneakyThrows注解，不建议这样做</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    //指定程序监听的消息队列和确认机制</span><br><span class="line">    @RabbitListener(queues = &#123;BiMqConstant.BI_EXCHANGE_NAME&#125;,ackMode = &quot;MANUAL&quot;)</span><br><span class="line">    public void receiveMessage(String message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliverTag)&#123;</span><br><span class="line">        log.info(&quot;receiveMessage = &#123;&#125;&quot;,message);</span><br><span class="line">        channel.basicAck(deliverTag, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>chartContoller里新建接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 智能分析（异步消息队列）</span><br><span class="line">     *</span><br><span class="line">     * @param multipartFile</span><br><span class="line">     * @param genChartByAiRequest</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/gen/async/mq&quot;)</span><br><span class="line">    public BaseResponse&lt;BiResponse&gt; genChartByAiAsyncMq(@RequestPart(&quot;file&quot;) MultipartFile multipartFile,</span><br><span class="line">                                                      GenChartByAiRequest genChartByAiRequest, HttpServletRequest request) &#123;</span><br><span class="line">        String name = genChartByAiRequest.getName();</span><br><span class="line">        String goal = genChartByAiRequest.getGoal();</span><br><span class="line">        String chartType = genChartByAiRequest.getChartType();</span><br><span class="line">        //校验</span><br><span class="line">        ThrowUtils.throwIf(StringUtils.isBlank(goal), ErrorCode.PARAMS_ERROR, &quot;目标为空&quot;);</span><br><span class="line">        ThrowUtils.throwIf(StringUtils.isNotBlank(name) &amp;&amp; name.length() &gt; 100, ErrorCode.PARAMS_ERROR, &quot;名称过长&quot;);</span><br><span class="line">        //校验文件</span><br><span class="line">        long size = multipartFile.getSize();</span><br><span class="line">        String originalFilename = multipartFile.getOriginalFilename();</span><br><span class="line">        //校验文件大小</span><br><span class="line">        final long ONE_MB = 1024 * 1024L;</span><br><span class="line">        ThrowUtils.throwIf(size &gt; ONE_MB, ErrorCode.PARAMS_ERROR, &quot;文件超过1M&quot;);</span><br><span class="line">        //校验文件后缀 aaa.png</span><br><span class="line">        String suffix = FileUtil.getSuffix(originalFilename);</span><br><span class="line">        final List&lt;String&gt; validFileSuffixList = Arrays.asList(&quot;xlsx&quot;, &quot;xls&quot;);</span><br><span class="line">        ThrowUtils.throwIf(!validFileSuffixList.contains(suffix), ErrorCode.PARAMS_ERROR, &quot;文件后缀非法&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //获取当前用户信息</span><br><span class="line">        User loginUser = userService.getLoginUser(request);</span><br><span class="line">        //限流判断,每个用户一个限流器,</span><br><span class="line">        // 参数这样写的好处是每个方法的限流器不会冲突，一个方法的调用了的次数，不会影响其他方法的使用</span><br><span class="line">//        redisLimiterManager.doRateLimit(&quot;genChartByAi_&quot;+loginUser.getId());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        StringBuilder userInput = new StringBuilder();</span><br><span class="line">        userInput.append(&quot;分析需求：&quot;).append(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">        // 拼接分析目标</span><br><span class="line">        String userGoal = goal;</span><br><span class="line">        if (StringUtils.isNotBlank(chartType)) &#123;</span><br><span class="line">            userGoal += &quot;，请使用&quot; + chartType;</span><br><span class="line">        &#125;</span><br><span class="line">        userInput.append(userGoal).append(&quot;\n&quot;);</span><br><span class="line">        userInput.append(&quot;原始数据：&quot;).append(&quot;\n&quot;);</span><br><span class="line">        // 压缩后的数据</span><br><span class="line">        String csvData = ExcelUtils.excelToCsv(multipartFile);</span><br><span class="line">        userInput.append(csvData).append(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //插入到数据库</span><br><span class="line">        Chart chart = new Chart();</span><br><span class="line">        chart.setName(name);</span><br><span class="line">        chart.setGoal(goal);</span><br><span class="line">        chart.setChartData(csvData);</span><br><span class="line">        chart.setChartType(chartType);</span><br><span class="line">        chart.setStatus(&quot;wait&quot;);</span><br><span class="line"></span><br><span class="line">        chart.setUserId(loginUser.getId());</span><br><span class="line">        boolean saveResult = chartService.save(chart);</span><br><span class="line">        ThrowUtils.throwIf(!saveResult, ErrorCode.SYSTEM_ERROR, &quot;图表保存失败&quot;);</span><br><span class="line">        long newChartId = chart.getId();</span><br><span class="line">        //现在改为在消费者中单独处理任务，而不是在线程池中处理</span><br><span class="line">        biMessageProducer.sendMessage(String.valueOf(newChartId));</span><br><span class="line"></span><br><span class="line">        BiResponse biResponse = new BiResponse();</span><br><span class="line">        biResponse.setChartId(newChartId);</span><br><span class="line">        return ResultUtils.success(biResponse);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


                    
                </div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/2024/07/15/OJ%E5%88%A4%E9%A2%98/"
                                   title=""
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis"></span>
                                        <span class="post-nav-item">Prev posts</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
        &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2024
        
            &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">Keep Team</a>
        
    </div>

    <div class="theme-info info-item">
        Powered by&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;&&nbsp;Theme&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div>

    

    

    
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="post-tools-list border-box">
        <!-- PC encrypt again -->
        

        <!-- PC TOC show toggle -->
        

        <!-- PC go comment -->
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-toggle-theme-mode flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    

    <!-- tablet toc -->
    
</main>



<!-- common -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local-search -->


<!-- lazyload -->


<div class="">
    <!-- home page -->
    

    <!-- post page -->
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        

        <!-- copyright-info -->
        

        <!-- share -->
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->



</body>
</html>
